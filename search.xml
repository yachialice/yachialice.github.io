<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Leetcode-71. Combination</title>
    <url>/2021/03/06/Leetcode-71-Combination/</url>
    <content><![CDATA[<h1 id="Leetcode-77-Combination"><a href="#Leetcode-77-Combination" class="headerlink" title="Leetcode-77. Combination"></a>Leetcode-77. Combination</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given two integers <em>n</em> and <em>k</em>, return all possible combinations of <em>k</em> numbers out of 1 … <em>n</em>.</p>
<p>For example,<br>If <em>n</em> = 4 and <em>k</em> = 2, a solution is:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><img src="/Users/alice/Blog/blog/source/img/Leetcode-71.png" style="zoom:80%;" />





<p>Make use of DFS.  First, choose number in a specific layer, then step into the next layer to choose another number. If the size of Vector Out is k, then we get one combination. Once Out is k, return to the upper layer and try to choose another number. If the layer reaches the end, but Out is still smaller than k, then it can’t meets the requirements and is dropped out. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line">        </span><br><span class="line">        dsp(n, k, <span class="number">1</span>, out, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dsp</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> level, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; out, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(out.size() == k)&#123;</span><br><span class="line">            res.push_back(out); </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = level; i&lt;=n; i++)&#123;</span><br><span class="line">            out.push_back(i);</span><br><span class="line">            <span class="comment">//深度搜索，在out中加入下一个数字</span></span><br><span class="line">            dsp(n, k ,i+<span class="number">1</span>, out, res);</span><br><span class="line">        </span><br><span class="line">            out.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Backtracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-78 Subsets</title>
    <url>/2021/03/08/Leetcode-78-Subsets/</url>
    <content><![CDATA[<h1 id="Leetcode-78-Subsets"><a href="#Leetcode-78-Subsets" class="headerlink" title="Leetcode-78. Subsets"></a>Leetcode-78. Subsets</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a set of distinct integers, <em>S</em>, return all possible subsets.</p>
<p>Note:</p>
<ul>
<li>Elements in a subset must be in non-descending order.</li>
<li>The solution set must not contain duplicate subsets.</li>
</ul>
<p>For example,<br>If <em>S</em> = <code>[1,2,3]</code>, a solution is:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>DFS, similiar to 77. Combination</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>, res, out, nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> level, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; out, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        res.push_back(out);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = level; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            out.push_back(nums[i]);</span><br><span class="line">            dfs(i+<span class="number">1</span>, res, out, nums);</span><br><span class="line">            out.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>Add current number into the back of every existing element to form new elements in the 2D vector.</p>
<p>For example, res = [[], [1], [2], [1,2]], i = 3.</p>
<p>Then, we form [3], [1,3], [2,3], [1, 2, 3]by adding 3 into [], [1], [2], [1, 2]. </p>
<p>res = [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]].</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">//注意，此处为res(1)</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> size = res.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++)&#123;</span><br><span class="line">                res.push_back(res[j]);</span><br><span class="line">                res.back().push_back(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Backtracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-79. Word Search</title>
    <url>/2021/03/08/Leetcode-79-Word-Search/</url>
    <content><![CDATA[<h1 id="Leetode-79-Word-Search"><a href="#Leetode-79-Word-Search" class="headerlink" title="Leetode-79. Word Search"></a>Leetode-79. Word Search</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p>For example,<br>Given board =</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [&quot;ABCE&quot;],</span><br><span class="line">  [&quot;SFCS&quot;],</span><br><span class="line">  [&quot;ADEE&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>word = <code>&quot;ABCCED&quot;</code>, -&gt; returns <code>true</code>,<br>word = <code>&quot;SEE&quot;</code>, -&gt; returns <code>true</code>,<br>word = <code>&quot;ABCB&quot;</code>, -&gt; returns <code>false</code>.</p>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>Resurse the board to find the word’s firt matching letter. Once the correspond letter is found, use dfs algorithm to dfs the rest letters in the neighbourhood of the current letter.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i&lt;board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt;board[<span class="number">0</span>].size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, word, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   <span class="keyword">int</span> m = board.size();</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span> (index==word.size()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||i&gt;=m||j&gt;=n||board[i][j]!=word[index]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">char</span> t = board[i][j];</span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">        res = (dfs(board, word, i<span class="number">-1</span>, j, index+<span class="number">1</span>)||</span><br><span class="line">        dfs(board, word, i, j<span class="number">-1</span>, index+<span class="number">1</span>)||dfs(board, word, i+<span class="number">1</span>,j, index+<span class="number">1</span>)||dfs(board, word, i, j+<span class="number">1</span>, index+<span class="number">1</span>)) ;</span><br><span class="line">        board[i][j] = t;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Backtracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-80. Remove Dupilicateds from Sorted Array</title>
    <url>/2021/03/08/Leetcode-80-Remove-Dupilicateds-from-Sorted-Array/</url>
    <content><![CDATA[<h1 id="Leetcode-80-Remove-Dupilicateds-from-Sorted-Array"><a href="#Leetcode-80-Remove-Dupilicateds-from-Sorted-Array" class="headerlink" title="Leetcode-80. Remove Dupilicateds from Sorted Array ||"></a>Leetcode-80. Remove Dupilicateds from Sorted Array ||</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a> such that duplicates appeared at most <em>twice</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a> with O(1) extra memory.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [1,1,1,2,2,3],</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [0,0,1,1,1,1,2,3,3],</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>Use variable gap to represent the number of nums that appeared more than twice and should be deleted. The current num should be moved left for gap position and the final Array Size equals original size minus gap.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> gap = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> prev = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums.size();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == prev) count++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">                prev = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">2</span>) gap++;</span><br><span class="line">            </span><br><span class="line">            nums[i-gap] = nums[i];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums.size() - gap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Array</category>
        <category>Two Pointers</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-81. Search in Rotated Sorted Array ||</title>
    <url>/2021/03/09/Leetcode-81-Search-in-Rotated-Sorted-Array/</url>
    <content><![CDATA[<h1 id="Leetcode-81-Search-in-Rotated-Sorted-Array"><a href="#Leetcode-81-Search-in-Rotated-Sorted-Array" class="headerlink" title="Leetcode-81. Search in Rotated Sorted Array ||"></a>Leetcode-81. Search in Rotated Sorted Array ||</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>[0,0,1,2,2,5,6]</code> might become <code>[2,5,6,0,0,1,2]</code>).</p>
<p>You are given a target value to search. If found in the array return <code>true</code>, otherwise return <code>false</code>.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>Follow up:</p>
<ul>
<li>This is a follow up problem to <a href="https://leetcode.com/problems/search-in-rotated-sorted-array/description/">Search in Rotated Sorted Array</a>, where <code>nums</code> may contain duplicates.</li>
<li>Would this affect the run-time complexity? How and why?</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>It is similar to Leetcode 33., but since there are same numbers in the array, the case that nums[mid]==nums[l] needs to be taken into consideration.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = nums.size()<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target == nums[mid]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//nums[l]&lt;nums[mid]表示mid左边数组有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[l] &lt; nums[mid])&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[l]&lt;=target&amp;&amp;target&lt;nums[mid])&#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;                </span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//nums[mid]&lt;nums[l]表示mid右边数组有序</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;nums[l])&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid]&lt;target&amp;&amp;target&lt;=nums[r])&#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    r = mid<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//nums[mid]==nums[l]时， 例如[1,1,3,1],[1,3,1，1，1]的情况下不确定哪边有序，target 3 可能在mid左边也可能在右边，对l++</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                l++;   </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Binary Search</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 82. Remove Duplicates from Sorted List ||</title>
    <url>/2021/03/09/Leetcode-82-Remove-Duplicates-from-Sorted-List/</url>
    <content><![CDATA[<h1 id="Leetcode-82-Remove-Duplicates-from-Sorted-List"><a href="#Leetcode-82-Remove-Duplicates-from-Sorted-List" class="headerlink" title="Leetcode 82. Remove Duplicates from Sorted List ||"></a>Leetcode 82. Remove Duplicates from Sorted List ||</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <em>distinct</em> numbers from the original list.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class="line">Output: 1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;1-&gt;2-&gt;3</span><br><span class="line">Output: 2-&gt;3</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在head前再加一个节点dumpy，在head就是重复值的情况下，可以简化删除head节点的过程</span></span><br><span class="line">        <span class="keyword">if</span>(!head||!head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *dumpy = <span class="keyword">new</span> ListNode();</span><br><span class="line">        dumpy-&gt;next = head;</span><br><span class="line">        ListNode *prev = dumpy;</span><br><span class="line">        ListNode *current = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(prev-&gt;next)&#123;</span><br><span class="line">            current = prev-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(current-&gt;next &amp;&amp; current-&gt;val == current-&gt;next-&gt;val)&#123;</span><br><span class="line">                current = current-&gt;next;   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(prev-&gt;next != current) prev-&gt;next = current-&gt;next;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                prev = prev-&gt;next;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dumpy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Linked List</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-83. Remove Duplicates from Sorted List</title>
    <url>/2021/03/11/Leetcode-83-Remove-Duplicates-from-Sorted-List/</url>
    <content><![CDATA[<h1 id="Leetcode-83-Remove-Duplicates-from-Sorted-List"><a href="#Leetcode-83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="Leetcode-83. Remove Duplicates from Sorted List"></a>Leetcode-83. Remove Duplicates from Sorted List</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2</span><br><span class="line">Output: 1-&gt;2</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>Easy Method</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* current = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(current&amp;&amp;current-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current-&gt;val == current-&gt;next-&gt;val)&#123;</span><br><span class="line">                current-&gt;next = current-&gt;next-&gt;next;   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                current = current-&gt;next;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>Recursion Method</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        head-&gt;next = deleteDuplicates(head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> (head-&gt;val == head-&gt;next-&gt;val) ? head-&gt;next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Linked List</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-86. Partition List</title>
    <url>/2021/03/11/Leetcode-86-Partition-List/</url>
    <content><![CDATA[<h1 id="Leetcode-86-Partition-List"><a href="#Leetcode-86-Partition-List" class="headerlink" title="Leetcode-86. Partition List"></a>Leetcode-86. Partition List</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a linked list and a value <em>x</em>, partition it such that all nodes less than <em>x</em> come before nodes greater than or equal to <em>x</em>.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p>For example,<br>Given <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2</code> and <em>x</em> = 3,<br>return <code>1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</code>.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>Create a new list with the Nodes less than x in the original list. At the same time delete the Nodes less than x in the original list. Finally, combine the two list to form the result.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;        </span><br><span class="line">        </span><br><span class="line">        ListNode* dumpy_s = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* current_s = dumpy_s;</span><br><span class="line">        ListNode* dumpy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        dumpy-&gt;next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode* current = head;</span><br><span class="line">        ListNode* prev = dumpy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(current)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current-&gt;val&lt;x)&#123;</span><br><span class="line">                current_s-&gt;next = current;</span><br><span class="line">                current_s = current_s-&gt;next;</span><br><span class="line">                </span><br><span class="line">                prev-&gt;next = current-&gt;next;</span><br><span class="line">                </span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">                </span><br><span class="line">                current_s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">                prev = prev-&gt;next;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        current_s-&gt;next = dumpy-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dumpy_s-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Linked List</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-88. Merge Sorted Array</title>
    <url>/2021/03/13/Leetcode-88-Merge-Sorted-Array/</url>
    <content><![CDATA[<h1 id="Leetcode-88-Merge-Sorted-Array"><a href="#Leetcode-88-Merge-Sorted-Array" class="headerlink" title="Leetcode-88. Merge Sorted Array"></a>Leetcode-88. Merge Sorted Array</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>
<p>Note:</p>
<ul>
<li>The number of elements initialized in <em>nums1</em>and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</li>
<li>You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>.</li>
</ul>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3</span><br><span class="line">nums2 &#x3D; [2,5,6],       n &#x3D; 3</span><br><span class="line"></span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = m<span class="number">-1</span>, j = n<span class="number">-1</span>, k = m+n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                nums1[k--] = (i&gt;=<span class="number">0</span>&amp;&amp;nums1[i]&gt;=nums2[j]) ? nums1[i--] : nums2[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Two Pointers</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-90. Subsets||</title>
    <url>/2021/03/15/Leetcode-90-Subsets/</url>
    <content><![CDATA[<h1 id="Leetcode-90-Subsets"><a href="#Leetcode-90-Subsets" class="headerlink" title="Leetcode-90. Subsets ||"></a>Leetcode-90. Subsets ||</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a collection of integers that might contain duplicates, <em>S</em>, return all possible subsets.</p>
<p>Note:</p>
<ul>
<li>Elements in a subset must be in non-descending order.</li>
<li>The solution set must not contain duplicate subsets.</li>
</ul>
<p>For example,<br>If <em>S</em> = <code>[1,2,2]</code>, a solution is:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>Similiar to 78.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line">        </span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> prev_size = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> prev_num = *nums.begin()<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> start;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != prev_num)&#123;</span><br><span class="line">                start = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                start = prev_size;  </span><br><span class="line">            &#125;</span><br><span class="line">            prev_size = res.size();</span><br><span class="line">            prev_num = nums[i];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> Size = res.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = start; j&lt;Size; j++)&#123;</span><br><span class="line">                res.push_back(res[j]);</span><br><span class="line">                res.back().push_back(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>Similiar to 78.</p>
<p>dfs method.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line">        </span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        dfs(nums, out, res, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; out, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        res.push_back(out);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = level; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            out.push_back(nums[i]);</span><br><span class="line">            dfs(nums, out, res, i+<span class="number">1</span>);</span><br><span class="line">            out.pop_back();</span><br><span class="line">            <span class="keyword">while</span>(i+<span class="number">1</span>&lt;nums.size() &amp;&amp; nums[i] == nums[i+<span class="number">1</span>]) i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Backtracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-91. Decode Ways</title>
    <url>/2021/03/20/Leetcode-91-Decode-Ways/</url>
    <content><![CDATA[<h1 id="Leetcode-91-Decode-Ways"><a href="#Leetcode-91-Decode-Ways" class="headerlink" title="Leetcode-91. Decode Ways"></a>Leetcode-91. Decode Ways</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>A message containing letters from <code>A-Z</code> is being encoded to numbers using the following mapping:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;A&#39; -&gt; 1</span><br><span class="line">&#39;B&#39; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; 26</span><br></pre></td></tr></table></figure>

<p>Given a non-empty string containing only digits, determine the total number of ways to decode it.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;12&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: It could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;226&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: It could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6)</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>It’s a dynamic programming problem. </p>
<p>if s[i] != ‘0’ and ‘10’&lt;=s[i-1]s[i]&lt;=’26’ : opt[i] = opt[i-1] + opt[i-2];</p>
<p>if s[i] != ‘0’ and (s[i-1]s[i]&lt;’10’ || s[i-1]s[i]&gt;’26’) opt[i] = opt[i-1];</p>
<p>if s[i] == ‘0’ and ‘10’&lt;=s[i-1]s[i]&lt;=’26’: opt[i] = opt[i-2]</p>
<p>else opt[i] = 0;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s.empty() || s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">opt</span><span class="params">(s.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        opt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        opt[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; opt.size(); i++)&#123;</span><br><span class="line">            <span class="comment">//注意此处，判定当前元素是否为0，若为0， 则不能加opt[i-1]，因为0不能映射</span></span><br><span class="line">            opt[i] = (s[i<span class="number">-1</span>] == <span class="string">&#x27;0&#x27;</span>) ? <span class="number">0</span> : opt[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span> &amp;&amp; (s[i<span class="number">-2</span>] == <span class="string">&#x27;1&#x27;</span> || (s[i<span class="number">-2</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s[i<span class="number">-1</span>] &lt;= <span class="string">&#x27;6&#x27;</span>)))</span><br><span class="line">                opt[i] += opt[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> opt.back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-92. Reverse Linked List</title>
    <url>/2021/03/23/Leetcode-92-Reverse-Linked-List/</url>
    <content><![CDATA[<h2 id="Leetcode-92-Reverse-Linked-List"><a href="#Leetcode-92-Reverse-Linked-List" class="headerlink" title="Leetcode-92. Reverse Linked List ||"></a>Leetcode-92. Reverse Linked List ||</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in one-pass.</p>
<p>Note: 1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m &#x3D; 2, n &#x3D; 4</span><br><span class="line">Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* prev = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= left<span class="number">-1</span>; i++) prev = prev-&gt;next;</span><br><span class="line">        ListNode* current = prev-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left<span class="number">-1</span>; i &lt;= right<span class="number">-2</span>; i++)&#123;</span><br><span class="line">            ListNode* t = current-&gt;next;</span><br><span class="line">            current-&gt;next = t-&gt;next;</span><br><span class="line">            t-&gt;next = prev-&gt;next;</span><br><span class="line">            prev-&gt;next = t;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Linked List</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-93. Restore IP Addresses</title>
    <url>/2021/03/23/Leetcode-93-Restore-IP-Addresses/</url>
    <content><![CDATA[<h2 id="Leetcode-93-Restore-IP-Addresses"><a href="#Leetcode-93-Restore-IP-Addresses" class="headerlink" title="Leetcode-93. Restore IP Addresses"></a>Leetcode-93. Restore IP Addresses</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;25525511135&quot;</span><br><span class="line">Output: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure>



<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>It is a backtracting problem.</p>
<p>When comparing a string number and 255, we can use atoi(s.c_str()). SInce atoi() is a C function, string s has to be turned into C format to use this function. </p>
<p>s.substr(pos, n) is used to find substring of s, pos is the start index of the substring and n is the length of the substring.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">restoreIpAddresses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        helper(s, <span class="number">0</span>, <span class="string">&quot;&quot;</span>, res);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n, <span class="built_in">string</span> out, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.empty()) res.push_back(out);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.size() &lt; k) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> val = atoi(s.substr(<span class="number">0</span>, k).c_str());</span><br><span class="line">                <span class="keyword">if</span> (val &gt; <span class="number">255</span> || k != <span class="built_in">std</span>::to_string(val).size()) <span class="keyword">continue</span>;</span><br><span class="line">                helper(s.substr(k), n + <span class="number">1</span>, out + s.substr(<span class="number">0</span>, k) + (n == <span class="number">3</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;.&quot;</span>), res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Backtracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-95. Unique Binary Search Trees ||</title>
    <url>/2021/03/24/LeetCode-95-Unique-Binary-Search-Trees-%7C%7C/</url>
    <content><![CDATA[<h2 id="LeetCode-95-Unique-Binary-Search-Trees"><a href="#LeetCode-95-Unique-Binary-Search-Trees" class="headerlink" title="LeetCode-95. Unique Binary Search Trees ||"></a>LeetCode-95. Unique Binary Search Trees ||</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given an integer <em>n</em>, generate all structurally unique BST’s (binary search trees) that store values 1 … <em>n</em>.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">Explanation:</span><br><span class="line">The above output corresponds to the 5 unique BST&#39;s shown below:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>



<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>在一定的range[1,n]中，若选择i作为根结点，则1～i-1构成左子树，i+1~n构成右子树。用递归获取左右子树可能的根结点序列，将左右子树与根结点i连接。每一层递归像上一层返回一个vector，饱含所有可能的根结点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> recursion(<span class="number">1</span>,n);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">//此句必须加上，否则返回的res会为[] </span></span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; left = recursion(start, i<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; right = recursion(i+<span class="number">1</span>, end);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> m:left)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> n:right)&#123;</span><br><span class="line">                   TreeNode *root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root-&gt;left = m;</span><br><span class="line">                    root-&gt;right = n;</span><br><span class="line">                    res.push_back(root);</span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Dynamic Programming</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-96. Unique Binary Search Trees</title>
    <url>/2021/03/24/Leetcode-96-Unique-Binary-Search-Trees/</url>
    <content><![CDATA[<h1 id="Leetcode-96-Unique-Binary-Search-Trees"><a href="#Leetcode-96-Unique-Binary-Search-Trees" class="headerlink" title="Leetcode-96. Unique Binary Search Trees"></a>Leetcode-96. Unique Binary Search Trees</h1><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given <em>n</em>, how many structurally unique BST’s (binary search trees) that store values 1 … <em>n</em>?</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">Given n &#x3D; 3, there are a total of 5 unique BST&#39;s:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>



<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h4><p>类似于95题的递归思路，当前递归层的组合数量 += 左子树数量 * 右子树数量。</p>
<p>并用map容器保存节点个数为i的树的种类个数，减少重复递归。因为若树的节点数确定，则其能够组合成的二叉搜索树种类数量也可确定，所以若已计算过当前节点数能组成的搜索树数量，则不必反复计算。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dic;</span><br><span class="line">        <span class="keyword">return</span> recursion(<span class="number">1</span>, n, dic);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; dic)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> length = end - start + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dic.count(length))</span><br><span class="line">            <span class="keyword">return</span> dic[length];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i&lt;=end; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = recursion(start, i<span class="number">-1</span>, dic);</span><br><span class="line">            <span class="keyword">int</span> right = recursion(i+<span class="number">1</span>, end, dic);</span><br><span class="line">            num = num + left*right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dic[length] = num;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h4><p>实际上是个动态规划法的数列计算。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=i; j++)&#123;</span><br><span class="line">                dp[i] += dp[j<span class="number">-1</span>] * dp[i-j];   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Dynamic Programming</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Essential C+ + 笔记</title>
    <url>/2021/03/24/Essential-C-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>Essential C+ + 笔记</p>
<p>Essential C+ + 笔记</p>
<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h4 id="1-include，-using-namespace"><a href="#1-include，-using-namespace" class="headerlink" title="1. include， using namespace"></a>1. include， using namespace</h4><p><code>#include &lt;iostream&gt;</code>——C+ +标准的输入输出库，包含了相关的整套class，用以对终端和文件的输入输出<br><code>#include &lt;string&gt; </code>——包含string类型<br><code>using namespace std;</code>——实用std命名空间。std是标准库所驻的命名空间。命名空间的作用是将库名称封装起来，避免和应用程序发生命名冲突。</p>
<h4 id="2-cout，-cin"><a href="#2-cout，-cin" class="headerlink" title="2. cout， cin"></a>2. cout， cin</h4><p>cout将信息写到用户终端中，运算符&lt;&lt;将数据定向到cout<br><code>cout  &lt;&lt;  “please enter your name”</code><br>cin读取终端上的输入内容，通过&gt;&gt;将输入内容定向到具有适合类型的对象上。<br><code>cin &gt;&gt; user_name</code></p>
<h4 id="3-const关键字"><a href="#3-const关键字" class="headerlink" title="3. const关键字"></a>3. const关键字</h4><p>用const定义的对象，在获得初值后，无法再进行修改，否则会报错。<br>以下几种写法错误：<br>（1）<br><code>const int a; //没有初始化</code><br>（2）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span>; <span class="comment">//修改了const对象</span></span><br></pre></td></tr></table></figure>



<h3 id="1-5-如何运用Array和Vector"><a href="#1-5-如何运用Array和Vector" class="headerlink" title="1.5 如何运用Array和Vector"></a>1.5 如何运用Array和Vector</h3><p>1、Array定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> seq_size = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">int</span> pell_seq[seq_size];定义<span class="built_in">array</span>的时候要指出尺度大小（不指出则根据初值的数量，自行计算<span class="built_in">array</span>的大小），并且此大小需为一个常量表达式，<span class="keyword">const</span>可以，但是变量不行。</span><br></pre></td></tr></table></figure>

<p>2、Vector定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pell_seq</span><span class="params">(seq_size)</span></span>;<span class="built_in">vector</span>可以用变量赋值。</span><br></pre></td></tr></table></figure>

<p>3、Array赋值</p>
<p>int a[] = {1,2,3,4};</p>
<p>4、Vector赋值<br>法一：冗长写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vecctor&lt;<span class="keyword">int</span>&gt; a&#123;<span class="number">10</span>&#125;;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>法二：利用一个已经初始化的array赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> value&#123;<span class="number">6</span>&#125; = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a&#123;value, value+<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>5、遍历vector<br>vector.size()会返回vector的大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;a.size(); i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;‘ ‘;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-6-指针"><a href="#1-6-指针" class="headerlink" title="1.6 指针"></a>1.6 指针</h3><p>1、指针必须要初始化。如果指针定位到某个对象，则对指针进行提领（dereference）操作没有错误；如果指针不指向对象，则进行dereference会导致未知执行结果。<br>若指针不指向任何对象，则赋地址值为0，成为null指针:<br>int *pi = 0;<br>一般为了防止对null进行提领，则提领前检测地址是否为0:</p>
<p>if (pi &amp;&amp; *pi !=1)</p>
<p>2、一些容易混淆的表达<br>指针的表达形式：<br>type_of_object_pointed_to * name_of_pointer_object<br>例如：<br>vector<int> *pv = 0;<br>pv指向的对象为vector<int>类型</p>
<p>例2:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *seq_addrs[seq_cnt] = &#123;&amp;fibonacci, &amp;lucas, &amp;pell&#125;;</span><br><span class="line"><span class="comment">//seq_addrs为一个数组，数组元素类型为vector&lt;int&gt; *；称seq_addrs为指针数组</span></span><br></pre></td></tr></table></figure>



<p>3、指针使用箭头-&gt;作为成员选择运算符<br>例如：pv-&gt;empty();</p>
<p>4、指针数组vs数组指针</p>
<p>指针数组：多个指针组成的数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * p[<span class="number">10</span>]</span><br><span class="line"><span class="comment">//[]优先级高于*，故而p先与[]结合，组成一个数组，数组的元素类型为int *</span></span><br></pre></td></tr></table></figure>

<p>数组指针：一个指向数组的指针<br>int (*p)[10]<br>实质上，这里根据语义应该写成<code>int (*)[10] p </code>，代表p为<code>int(*)[10]</code>类型的变量，但是不是这么规定的orz。<br>对数组指针赋值的时候：<br>(img)<br>&amp;a与a实际上值一致，但&amp;a为整个数组首地址，a为数组首元素的首地址；而<code>char (*p)[5]</code>定义的是指向数组的指针，所以此处用p3赋值方式更好。</p>
<p>(img)</p>
<h3 id="1-7-文件的读写"><a href="#1-7-文件的读写" class="headerlink" title="1.7 文件的读写"></a>1.7 文件的读写</h3><p>#include <fstream><br>ofstream、ifstream、fstream</p>
<h2 id="第二章-面向过程的编程风格"><a href="#第二章-面向过程的编程风格" class="headerlink" title="第二章 面向过程的编程风格"></a>第二章 面向过程的编程风格</h2><h3 id="2-2-调用函数"><a href="#2-2-调用函数" class="headerlink" title="2.2 调用函数"></a>2.2 调用函数</h3><p>（一）传入reference或者指针<br>（1）错误写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> val1, <span class="keyword">int</span> val2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = val1;</span><br><span class="line">        val1 = val2;</span><br><span class="line">        val2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2)使用reference</p>
<p>用以下例子理解reference</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *pi = &amp;ival;   <span class="comment">//指针pi指向ival这个对象，pi的值为ival的地址</span></span><br><span class="line"><span class="keyword">int</span> &amp;rval = ival;  <span class="comment">//reference，rval代表ival这个整型对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> jval = <span class="number">4096</span>;</span><br><span class="line">rval = jval;</span><br></pre></td></tr></table></figure>

<p><b>上述语句时将jval的值赋给了rval所代表的ival。无法令rval转而代表jval！！！C+  +不允许改变reference 所代表的对象！！！</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pi = &amp;rval</span><br></pre></td></tr></table></figure>

<p><b>上述语句代表将ival的值赋给pi</b></p>
<p><b>所以我们可以发现，对reference的所有操作方式，和对reference所代表对象的操作方式一模一样。即上述中对rval操作的写法，与直接对ival操作的写法一致。</b></p>
<p><b>但是，reference的不同点在于，以by reference方式将对象作为函数参数传入时，对象本身不会复制出另一份，复制的是对象的地址。函数中对对象的任何操作，相当于对传入对象本身进行简介操作。</b></p>
<p>用reference进行swap的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;val1, <span class="keyword">int</span> &amp;val2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = val1;</span><br><span class="line">        val1 = val2;</span><br><span class="line">        val2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        swap(val1,val2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用swap也可以降低复制大型对象的额外负担，因为他只复制地址。例如可以将const vector<int> &amp;vec作为形参。</p>
<p>(3)使用指针<br>使用指针效果和reference相同，传递的是对象地址。<br><b>使用指针一定要先确认指针是否为空指针！！！</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> * val1, <span class="keyword">int</span> *val2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!val1 || !val2)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; point is <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        temp = *val1;</span><br><span class="line">        *val1 = *val2;</span><br><span class="line">        *val2 = tem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        swap(&amp;val1, &amp;val2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（二）作用域<br>local scope：对象仅在local scope之内可见，在local scope之外不可见，如函数内的对象</p>
<p>file scope：对象若拥有file scope，则从声明点至文件末尾都可见。file scope内的对象也具备static extent（？？？static变量？？？？），从main()开始执行之前便分配好，一直存在至程序结束。</p>
<p>内置类型对象：定义在file scope之内，必定被初始化为0；定义在local scope之内，除非指定初值，否则不会初始化。</p>
<p>（三）动态内存管理<br>dynamic extent（动态范围）——由程序员自行管理，利用new和delete函数分配和释放，内存由空闲空间分配而来，成为heap memory（堆内存）。</p>
<p>new和delete应成对使用，否则heap分配的对象永远不会释放，导致内存泄漏（memeory leak）。<br>(1) new函数的使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Type;</span><br><span class="line"><span class="keyword">new</span> Type(initial value);</span><br></pre></td></tr></table></figure>

<p>可以声明initial value也可以不声明<br>例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1, p2;</span><br><span class="line">p1 = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">//由heap分配一个类型为int的对象，将地址赋给p1。不赋值直接输出*p1，会是随机数字（？）</span></span><br><span class="line">p2 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2014</span>); <span class="comment">//由heap分配一个类型为int的对象，初值设为2014，将地址赋给p2</span></span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">24</span>];</span><br></pre></td></tr></table></figure>


<p>分配一个有24个整数组成的数组，将第一个元素的地址赋给p。数组中的元素都没有进行初始化。</p>
<p>（2）delete函数的使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;  <span class="comment">//释放值</span></span><br><span class="line"><span class="keyword">delete</span> [] p; <span class="comment">//释放数组</span></span><br></pre></td></tr></table></figure>



<h3 id="2-3-提供默认参数值"><a href="#2-3-提供默认参数值" class="headerlink" title="2.3  提供默认参数值"></a>2.3  提供默认参数值</h3><p>​    传参的时候，可以给一些形参赋予默认值，调用函数的时候，如果不指明这些参数的值，则这些值用默认值初始化。<br>（1）默认值的解析从最右开始，若为某个参数提供了默认值，则参数右侧的所有参数都必须有默认值<br>（2）默认值只能指定一次。可以在函数声明时，也可以在函数定义处；不能够在两个地方都指定。</p>
<h3 id="2-4使用局部静态对象"><a href="#2-4使用局部静态对象" class="headerlink" title="2.4使用局部静态对象"></a>2.4使用局部静态对象</h3><p>在局部作用域内部可见，外部不可见，且持续存在。<br>例:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a; <span class="comment">// 错误，函数外部a不可见</span></span><br><span class="line">        display();  <span class="comment">// 1</span></span><br><span class="line">        display();  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>C+ + string怎么用？？？</p>
<h3 id="2-5-声明inline函数"><a href="#2-5-声明inline函数" class="headerlink" title="2.5 声明inline函数"></a>2.5 声明inline函数</h3><p>没看懂，好像没什么用？？可以节约函数调用时间？</p>
<h3 id="2-6-2-7-重载函数-vs-模版函数"><a href="#2-6-2-7-重载函数-vs-模版函数" class="headerlink" title="2.6-2.7 重载函数 vs 模版函数"></a>2.6-2.7 重载函数 vs 模版函数</h3><p>（1）重载函数<br>多个不同的函数使用同样的函数名，可以接收不同的参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_message</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displya_message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">int</span>)</span></span>;编译器会将调用者提供的参数与每个重载函数的参数对比，找出最合适的一个调用。</span><br></pre></td></tr></table></figure>

<p>（2）模版函数<br>函数主体不变，仅仅改变用到的数据类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;msg, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;elemType&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">        …</span><br><span class="line">        elemType t = vec[ix];</span><br><span class="line"><span class="comment">//使用elemType代表函数类型</span></span><br></pre></td></tr></table></figure>



<h3 id="2-8函数指针"><a href="#2-8函数指针" class="headerlink" title="2.8函数指针"></a>2.8函数指针</h3><p><b>函数指针：指向函数的指针</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; * (*seq_ptr)(<span class="keyword">int</span>); <span class="comment">//指针seq_ptr指向一个函数，此函数参数为int，返回值为const vector&lt;int&gt; *类型</span></span><br><span class="line">seq_ptr = pell_seq;  <span class="comment">//将函数pell_seq()的地址赋给pell_seq</span></span><br><span class="line">seq_ptr(<span class="number">1</span>); <span class="comment">//函数指针和一般函数调用方法相同</span></span><br></pre></td></tr></table></figure>



<h3 id="2-9-设定头文件"><a href="#2-9-设定头文件" class="headerlink" title="2.9 设定头文件"></a>2.9 设定头文件</h3><p>（1）函数声明放在头文件中，定义放在程序文件中；因为定义只能有一份，声明可以有多份。<br>（2）例外：inline函数的定义放在头文件里；const对象的定义可以放在头文件中。<br>（3）对象的定义也必须放在程序文件中，extern可以将定义转化为声明（？？）<br>（4）系统头文件用&lt;&gt;括起，自己写的头文件用””括起</p>
<h2 id="第三章-泛型编程风格"><a href="#第三章-泛型编程风格" class="headerlink" title="第三章 泛型编程风格"></a>第三章 泛型编程风格</h2><p>STL：Standard Template Library，组成：（1）容器，vector、list、set、map等类  （2）操作容器的泛型算法，如find()、replace()、merge()。</p>
<h4 id="泛型算法理解：泛型算法的函数可以接受任意类型的容器（vector、list、set、map等），利用一对iterator——first和last来遍历容器中的元素。"><a href="#泛型算法理解：泛型算法的函数可以接受任意类型的容器（vector、list、set、map等），利用一对iterator——first和last来遍历容器中的元素。" class="headerlink" title="泛型算法理解：泛型算法的函数可以接受任意类型的容器（vector、list、set、map等），利用一对iterator——first和last来遍历容器中的元素。"></a>泛型算法理解：泛型算法的函数可以接受任意类型的容器（vector、list、set、map等），利用一对iterator——first和last来遍历容器中的元素。</h4><h3 id="3-1-指针的算数运算"><a href="#3-1-指针的算数运算" class="headerlink" title="3.1 指针的算数运算"></a>3.1 指针的算数运算</h3><p>1、数组被传送给函数，或者由函数返回，都是仅传递第一个元素的地址<br>2、访问数组下标，如array[2]，实际上相当于*(array+2)。</p>
<p><b>3、对于指针运算，指针会把指针所指类型的大小考虑进去。例如，int型array的第一个元素的地址为100，则array+2代表的其实是100+2*4（假设int占4字节）。</b></p>
<p><b>4、begin()代表返回容器第一个元素的地址，若容器为空，则返回0。end()返回0或者容器最后元素的下一个地址。</b></p>
<h3 id="3-2-Iterator（泛型指针）"><a href="#3-2-Iterator（泛型指针）" class="headerlink" title="3.2 Iterator（泛型指针）"></a>3.2 Iterator（泛型指针）</h3><p>1、对于指针操作，vecotr、array等有序元素可以直接通过pointer++的方法遍历下一个元素，但对于list容器，元素不是保存在连续的内存空间里，如果要实现泛型算法，则需要对指针操作进行抽象，可以使用iterator泛型指针。<b>iterator的值其实应该是地址？？和普通指针一样？？？只是指针运算进行了抽象封装？？？</b></p>
<p>2、iterator用法：container.begin()和container.end()都会返回iterator。iterator中++、=、*都进行了重定义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义iterator</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator iter = vec.begin();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator end_it = vec.end();</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(; iter!=end_it; ++iter)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*iter&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>3、泛型算法find()实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IteratorType, <span class="keyword">typename</span> elemType&gt;</span><br><span class="line"><span class="function">IteratorType <span class="title">find</span><span class="params">(IteratorType first, IteratorType last, <span class="keyword">const</span> elemType &amp;value)</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(:first != last; ++first)</span><br><span class="line">    <span class="keyword">if</span>(value == *first) <span class="keyword">return</span> first;</span><br><span class="line">  <span class="keyword">return</span> last;</span><br><span class="line">  <span class="comment">//这个函数返回的实际是地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>find()函数调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> ia[size] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">//初始化vector和list</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(ia, ia+size)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ilist</span><span class="params">(ia, ia+size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//array调用find()</span></span><br><span class="line">find(ia, ia+size, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//vector调用find()</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">it = find(ivec.begin(), ivec.end(), <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(it != vec.end())</span><br><span class="line">      <span class="comment">//找到了</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//list调用find()</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">iter = find(ilist.begin(), ilist.end(), <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(iter != ilist.end())</span><br><span class="line">      <span class="comment">//找到了</span></span><br></pre></td></tr></table></figure>



<h3 id="3-4-使用顺序性容器"><a href="#3-4-使用顺序性容器" class="headerlink" title="3.4 使用顺序性容器"></a>3.4 使用顺序性容器</h3><p>顺序性容器：vector、deque、list</p>
<p>vector、deque在连续内存空间存储，vector和deque都可使用下标取出元素。vector容易对末尾元素进行删除插入操作，deque容易对首元素进行删除插入操作。</p>
<p>list是双向链表，包含value、back、front指针，容易进行任意位置的元素插入或删除。</p>
<p>1、定义顺序性容器对象的方式</p>
<p>（1）产生空容器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist;</span><br></pre></td></tr></table></figure>

<p>（2）产生特定大小的容器，元素默认初始化为初值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ilist</span><span class="params">(<span class="number">1024</span>)</span></span>; <span class="comment">//1024大小的list，初值为0</span></span><br></pre></td></tr></table></figure>

<p>（3）特定大小，指定初值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; <span class="title">slist</span><span class="params">(<span class="number">16</span>, <span class="string">&quot;unassinged&quot;</span>)</span></span>; <span class="comment">//16大小的list，初值为&quot;unassinged&quot;</span></span><br></pre></td></tr></table></figure>

<p>（4）通过iterator和已定义数组产生容器，iterator用来给出初值的地址范围。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ilist</span><span class="params">(ia, ia+<span class="number">3</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>（5）复制已有容器给空容器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; <span class="title">slist2</span><span class="params">(slist)</span></span>; <span class="comment">//利用已有容器slist初始化空容器slist2</span></span><br></pre></td></tr></table></figure>

<p>2、push_back()，pop_back()两个函数list、vector、deque通用。</p>
<p>list和deque能够对首元素进行插入删除，利用pop_front()，push_front()函数</p>
<p>3、iterator insert(iterator position, elemType value)，在position前面插入value，返回插入元素的iterator。</p>
<p>4、iterator类型的指针只能进行++运算，没有+2，+3…之类的运算</p>
<h3 id="3-5-使用泛型算法"><a href="#3-5-使用泛型算法" class="headerlink" title="3.5 使用泛型算法"></a>3.5 使用泛型算法</h3><p>find()、binary_search()、count()、search()、sort()、copy()等。基本上输入参数都包括container.begin()，container.end()两个iterator指针。</p>
<h3 id="3-6-如何设计一个泛型算法"><a href="#3-6-如何设计一个泛型算法" class="headerlink" title="3.6 如何设计一个泛型算法"></a>3.6 如何设计一个泛型算法</h3><p>如何设计一个泛化的filter函数，令其与容器类型、元素类型、以及filter方法均无关。</p>
<p><b>方法一 使用函数指针，泛化函数对filter方法的依赖</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义filter方法函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">less_than</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x1 &lt; x2 ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义filter，利用指针函数bool(*pred)(int, int)传入方法函数</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">filter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> filter_value, <span class="keyword">bool</span>(*pred)(<span class="keyword">int</span>, <span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pred(vec[i], filter_value))</span><br><span class="line">            result.push_back(vec[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">32</span>,<span class="number">45</span>,<span class="number">1</span>,<span class="number">67</span> &#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(a, a + <span class="number">6</span>)</span></span>;</span><br><span class="line">  <span class="comment">//调用，指针函数直接传入函数名即可</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = filter(ivec, <span class="number">10</span>, less_than);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>方法二 利用find函数，消除for循环，并且保证每个元素只遍历一次的方法</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">filter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> filter_value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.begin();</span><br><span class="line">    <span class="comment">//令find函数每次从iter指向的地址开始找，若找到，则会返回相应元素地址。若没有便利完vector，则iter++</span></span><br><span class="line">    <span class="keyword">while</span> ((iter = find(iter, vec.end(), filter_value)) !=vec.end())&#123;</span><br><span class="line">        count++;</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123; <span class="number">10</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">45</span>,<span class="number">1</span>,<span class="number">67</span> &#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(a, a + <span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="comment">//找ivec中有几个10</span></span><br><span class="line">    <span class="keyword">int</span> count = filter(ivec, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><b>方法三 用function object替代自定义函数</b></p>
<p>​    相比于在filter中传入函数指针，传递function object效率更高。可以令call运算符成为inline，从而消除”通过函数指针来调用函数“时需要付出的额外代价。</p>
<p>​    function object是某种class的实例对象，因为对function call运算符做了重载操作，因而可以当成一般函数使用。</p>
<p>（1）使用function object需要饱含#include <functional>头文件</p>
<p>（2）常见function object及使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//function object示例</span></span><br><span class="line">greater&lt;<span class="keyword">int</span>&gt;(), less&lt;<span class="keyword">int</span>&gt;()</span><br><span class="line"><span class="comment">//使用例子,降序排序</span></span><br><span class="line">sort(vec.begin(), vec.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br></pre></td></tr></table></figure>

<p>（3）因为less<int>(), greater<int>()，等function object接受二元输入，因此需要将其转化为一元运算符。</p>
<p>需要使用<b>binder adapter</b>。</p>
<p>binder1st将指定值绑定至第一操作数。</p>
<p>binder2nd将指定值绑定至第二操作数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binder1st(less&lt;int&gt;(), value);</span><br><span class="line">binder2nd(greater&lt;int&gt;(), value);</span><br></pre></td></tr></table></figure>

<p>（4）使用function object编写泛型函数filter()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> OutputIterator, <span class="keyword">typename</span> ElemType, <span class="keyword">typename</span> Comp&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">filter</span><span class="params">(InputIterator first, InputIterator last, OutputIterator at, <span class="keyword">const</span> ElemType &amp;val, Comp pred)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((first = find_if(first, last, bind2nd(pred, val))) != last) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        *at++ = *first++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> at;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123; <span class="number">10</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">45</span>,<span class="number">1</span>,<span class="number">67</span> &#125;;</span><br><span class="line">    <span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ilist</span><span class="params">(a, a + <span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">output</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">    filter(ilist.begin(), ilist.end(), output.begin(), value, greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; output.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; output[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><b>小练习</b></p>
<p>???没做出来，sort报错？？？</p>
<h3 id="3-7-使用Map"><a href="#3-7-使用Map" class="headerlink" title="3.7 使用Map"></a>3.7 使用Map</h3><p>map使用其实类似于python中的字典使用方式。</p>
<p>map被定义为一对（pair）数值，保存key和value。</p>
<p>1、map声明与定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义名为words的map</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; words;</span><br><span class="line">words[<span class="string">&quot;apple&quot;</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>2、查询某一key的value</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于map类型的变量words来说，words[&quot;apple&quot;]可以查看apple的value，若apple不在word的key中，则会创建一个value的key，其值为0</span></span><br><span class="line"></span><br><span class="line">words[<span class="string">&quot;apple&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>3、遍历map的元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it = words.begin();</span><br><span class="line"><span class="keyword">for</span>(:, it!=words.end(); ++it)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;key: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value: &quot;</span> &lt;&lt; it-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、查询map内是否存在某个key</p>
<p>(1)把key当作索引</p>
<p>但是这样若key不在map中，则会自动创建此key，令其value为0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!(count = words[<span class="string">&quot;apple&quot;</span>]))</span><br><span class="line">    <span class="comment">//&quot;apple&quot;不在key里</span></span><br></pre></td></tr></table></figure>

<p>(2)使用map的find()函数</p>
<p>find()若找到key，则会返回指向key/value pair的iterator；若不存在key，则返回end()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">it = words.find(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(it != words.end())</span><br><span class="line">  count = it-&gt;second;</span><br></pre></td></tr></table></figure>

<p>（3）使用map的count()函数</p>
<p>count()函数会返回特定项在map内的个数，任何key在map中只有一份，因此若有key，返回1，若无key，返回0。避免了直接使用words[key]，创造新key的情况。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(words.count(<span class="string">&quot;apple&quot;</span>))</span><br><span class="line">    count = words[<span class="string">&quot;apple&quot;</span>];</span><br></pre></td></tr></table></figure>



<h3 id="3-8-使用Set"><a href="#3-8-使用Set" class="headerlink" title="3.8 使用Set"></a>3.8 使用Set</h3><p>set可以看作是集合，又一群key组成，没有value。每个key在set中只能出现一次。</p>
<p>set会默认为其中的元素从小到大排序。</p>
<p>1、set初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">10</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">45</span>, <span class="number">1</span>, <span class="number">67</span>, <span class="number">45</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">iset</span><span class="params">(ia, ia+<span class="number">7</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = iset.begin();</span><br><span class="line"><span class="keyword">for</span>(; it != iset.end(); it++)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出为1 2 10 45 67</span></span><br></pre></td></tr></table></figure>

<p>2、set中加入值</p>
<p>使用insert()函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入一个值</span></span><br><span class="line">iset.insert(ival);</span><br><span class="line"><span class="comment">//插入n个值</span></span><br><span class="line">iset.insert(vec.begin(), vec.end());</span><br></pre></td></tr></table></figure>



<h3 id="3-9-如何使用Iterator-Inserter"><a href="#3-9-如何使用Iterator-Inserter" class="headerlink" title="3.9 如何使用Iterator Inserter"></a>3.9 如何使用Iterator Inserter</h3><p>back_inserter()会以push_back()函数取代assignment运算。这样利用filter将符合条件的元素复制到output容器中时，就不必再指定output容器的具体大小。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> OutputIterator, <span class="keyword">typename</span> ElemType, <span class="keyword">typename</span> Comp&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">filter</span><span class="params">(InputIterator first, InputIterator last, OutputIterator at, <span class="keyword">const</span> ElemType &amp;val, Comp pred)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((first = find_if(first, last, bind2nd(pred, val))) != last) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        *at++ = *first++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> at;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[] = &#123;<span class="number">10</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">45</span>, <span class="number">1</span>, <span class="number">67</span>, <span class="number">45</span>&#125;;</span><br><span class="line">  <span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ilist</span><span class="params">(a, a+<span class="number">6</span>)</span></span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//使用back_inserter()</span></span><br><span class="line">  filter(ilist.begin(), ilist.end(), back_inseerter(output), <span class="number">10</span>, greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-10-使用iostream-iterator"><a href="#3-10-使用iostream-iterator" class="headerlink" title="3.10 使用iostream iterator"></a>3.10 使用iostream iterator</h3><p>istream_iterator可以从设备中读取字符串，可以构成first和last的iterator指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//first</span></span><br><span class="line"><span class="function">istream_iterator&lt;stirng&gt; <span class="title">is</span><span class="params">(<span class="built_in">cin</span>)</span></span>;</span><br><span class="line"><span class="comment">//last</span></span><br><span class="line">istream_iterator&lt;<span class="built_in">string</span>&gt; eof;</span><br><span class="line"><span class="comment">//使用,将cin中字符insert到text中</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; text;</span><br><span class="line">copy(is, eof, back_inserter(text));</span><br></pre></td></tr></table></figure>

<p>ostream_iterator可以表示字符元素的输出位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ostream_iterator&lt;<span class="built_in">string</span>&gt; <span class="title">os</span><span class="params">(<span class="built_in">cout</span>, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line">copy(text.begin(), text.end(), os);</span><br></pre></td></tr></table></figure>



<h2 id="第四章-基于对象的编程风格"><a href="#第四章-基于对象的编程风格" class="headerlink" title="第四章 基于对象的编程风格"></a>第四章 基于对象的编程风格</h2><h3 id="4-1-如何实现一个class"><a href="#4-1-如何实现一个class" class="headerlink" title="4.1 如何实现一个class"></a>4.1 如何实现一个class</h3><p>1、class的声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>;</span></span><br></pre></td></tr></table></figure>

<p>class需要有前置声明，才能进行类指针的定义，或将class作为数据类型。故而定义class前，最好先进行声明。</p>
<p>2、class的声明</p>
<p>（1）private&amp;public</p>
<p>public member：可在程序任何地方被访问</p>
<p>private member：只能被member function或者class friend内被访问。</p>
<p>（2）member function声明与定义</p>
<p>member function都必须在主体内进行声明。</p>
<p>若member function在class主体内定义，则被视为inline函数；若在煮体外定义则加上inline关键字才为inline函数。</p>
<p>class主体外定义语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Stack::empty()&#123;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>（4）注意：如果member function是inline函数，则和普通inline函数同理，函数的定义应该放在声明类的头文件中。其他non-inline函数放在.cpp文件中。</b></p>
<h3 id="4-2-构造函数和析构函数"><a href="#4-2-构造函数和析构函数" class="headerlink" title="4.2 构造函数和析构函数"></a>4.2 构造函数和析构函数</h3><p>1、构造函数</p>
<p>构造函数和类同名，可以重载。一般也会给函数参数设置默认值。</p>
<p>构造函数有以下两种初始化语法。</p>
<p>（1）普通方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Triangular(<span class="keyword">int</span> len = <span class="number">1</span>, <span class="keyword">int</span> bp = <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _length;</span><br><span class="line">    <span class="keyword">int</span> _beg_pos;</span><br><span class="line">    <span class="keyword">int</span> _next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Triangular::Triangular(<span class="keyword">int</span> len, <span class="keyword">int</span> bp)&#123;</span><br><span class="line">    _length = len &gt; <span class="number">0</span> ? len : <span class="number">1</span>;</span><br><span class="line">    _beg_pos = bp &gt; <span class="number">0</span> ? bp : <span class="number">1</span>;</span><br><span class="line">    _next = _beg_pos - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>(2)Member Initialization List（成员初始化列表）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Triangular(<span class="keyword">int</span> len = <span class="number">1</span>, <span class="keyword">int</span> bp = <span class="number">1</span>);</span><br><span class="line">    Triangular(<span class="keyword">const</span> Triangular &amp;rhs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _length;</span><br><span class="line">    <span class="keyword">int</span> _beg_pos;</span><br><span class="line">    <span class="keyword">int</span> _next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Triangular::Triangular(<span class="keyword">const</span> Triangular &amp;rhs):_length(rhs._length), _beg_pos(rhs._beg_pos), _next(rhs._beg_pos<span class="number">-1</span>)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>



<p>2、析构函数</p>
<p>析构函数不是必须的，但在某些情况下，例如类中使用了heap分配内存，需要使用析构函数释放内存。析构函数的命名为~className()。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Matrix(<span class="keyword">int</span> row, <span class="keyword">int</span> col) : _row(row), _col(col)&#123;</span><br><span class="line">        _pmat = <span class="keyword">new</span> <span class="keyword">double</span>[row*col];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Matrix()&#123;</span><br><span class="line">        <span class="keyword">delete</span> [] _pmat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _row, _col;</span><br><span class="line">    <span class="keyword">double</span>* _pmat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-3-何谓mutable和const"><a href="#4-3-何谓mutable和const" class="headerlink" title="4.3 何谓mutable和const"></a>4.3 何谓mutable和const</h3><p>有些时候class被设置为const类型，则此时class中的元素都不能被修改。所以在调用公共接口public函数时，要确保class中的元素没有被修改。此时需要在member function中加上const标注，告诉编译器此函数不会更改调用者。</p>
<p>1、例如：</p>
<p>如果length()和beg_pos()后没有添加const，则sum函数调用时会报错。</p>
<p><b>const reference class参数不能调用class中的non-const成分。</b></p>
<p><b>如果member function不在class内定义，则声明和定义时都需要加const关键字</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Triangular(<span class="keyword">int</span> len = <span class="number">1</span>, <span class="keyword">int</span> bp = <span class="number">1</span>) &#123;</span><br><span class="line">        _length = len &gt; <span class="number">0</span> ? len : <span class="number">1</span>;</span><br><span class="line">        _beg_pos = bp &gt; <span class="number">0</span> ? bp : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//注意一下member function的定义</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> _length; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">beg_pos</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> _beg_pos; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _length;</span><br><span class="line">    <span class="keyword">int</span> _beg_pos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> Triangular &amp;a)</span> </span>&#123;</span><br><span class="line">    a.beg_pos();</span><br><span class="line">    a.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>同理编译器会检查const函数是否真的没有改变class的值，若改变了则会报错。</b></p>
<p><b>2、 若member function将class中元素的地址暴露出去也是不行的，因为这样给了其他部分程序修改class中元素的机会。如以下例子，编译器会报错</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">val_class</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    val_class(<span class="keyword">const</span> BigClass&amp; v) : _val(v) &#123;&#125;;</span><br><span class="line">    <span class="comment">//以下函数将private类型的BigClass地址暴露了出去</span></span><br><span class="line">    <span class="function">BigClass&amp; <span class="title">val</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _val;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BigClass _val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3、可以利用重载函数解决2中的问题</p>
<p><b>注意以下重载不是根据参数列表不同而进行重载，而是根据调用者是否为const而进行的重载。第一个const表示返回的Big Class&amp; val是const类型，不能改变其值，第二个const表示这个member function是不会改遍class中的元素。</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">val_class</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    val_class(<span class="keyword">const</span> BigClass&amp; v) : _val(v) &#123;&#125;;</span><br><span class="line">    <span class="function">BigClass&amp; <span class="title">val</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _val;&#125;</span><br><span class="line">  <span class="comment">//const重载</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> BigClass&amp; <span class="title">val</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _val;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BigClass _val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4、mutable</p>
<p>mutable变量可以让经过mutable标识的变量发生改变时，不破坏class的常量性。即const class中的mutable变量可以改变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mutable</span> <span class="keyword">int</span> _next</span><br></pre></td></tr></table></figure>



<h3 id="4-4-什么是this指针"><a href="#4-4-什么是this指针" class="headerlink" title="4.4 什么是this指针"></a>4.4 什么是this指针</h3><p>this指针指向member function的调用者（一个对象）。</p>
<p>内部工作时，编译器自动将this指针添加到每个member function的参数列表中。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Triangular&amp; <span class="title">Triangular::copy</span><span class="params">(<span class="keyword">const</span> Triangular&amp; rhs)</span></span>&#123;</span><br><span class="line">    _length = rhs._length;</span><br><span class="line">    _beg_pos = rhs._beg_pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上写法实际上在编译器中自动转化为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Triangular&amp; <span class="title">Triangular::copy</span><span class="params">(Triangular* <span class="keyword">this</span>, <span class="keyword">const</span> Triangular&amp; rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_length = rhs._length;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_beg_pos = rhs._beg_pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-5-静态类成员"><a href="#4-5-静态类成员" class="headerlink" title="4.5 静态类成员"></a>4.5 静态类成员</h3><p>static data member可以被同一类的所有对象共同拥有，访问，他是唯一的，即在各个对象中值都一样。</p>
<p>1、声明与定义</p>
<p>在.h文件中，声明时前面加static。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//Triangular.h文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Triangular(<span class="keyword">int</span> len = <span class="number">1</span>, <span class="keyword">int</span> bp = <span class="number">1</span>) &#123;</span><br><span class="line">        _length = len &gt; <span class="number">0</span> ? len : <span class="number">1</span>;</span><br><span class="line">        _beg_pos = bp &gt; <span class="number">0</span> ? bp : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> _length; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">beg_pos</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> _beg_pos; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gen_elems</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_elems</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _length;</span><br><span class="line">    <span class="keyword">int</span> _beg_pos;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _elems;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在.cpp文件中，要对static data member进行定义，此时可以不加static标识符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Triangular.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Triangular::_elems;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Triangular::gen_elems</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ix = _elems.size();</span><br><span class="line">    <span class="keyword">if</span> (!ix)</span><br><span class="line">    &#123;</span><br><span class="line">        _elems.push_back(<span class="number">1</span>);</span><br><span class="line">        ix = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (_elems[ix - <span class="number">1</span>] &lt; value) &#123;</span><br><span class="line">        ix++;</span><br><span class="line">        _elems.push_back(ix*(ix + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Triangular::print_elems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _elems.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; _elems[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2、对于static member function来说，调用的时候可以直接ClassName::fudnctionName()调用，不用特地声明一个对象，然后用这个对象来调用。</p>
<p>注意static member function调用的参数要求都是static类型的。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//对于static成员函数gen_elems()，可以直接用Triangular::gen_elems()调用，调用时不必构造对象。</span></span><br><span class="line">    Triangular::gen_elems(<span class="number">10</span>);</span><br><span class="line">    Triangular a = Triangular();</span><br><span class="line">    Triangular b = Triangular();</span><br><span class="line"><span class="comment">//对于非static成员函数print_elems()，则必须构建对象，然后用对象调用</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    a.print_elems();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b: &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    b.print_elems();</span><br></pre></td></tr></table></figure>

<p>3、实验</p>
<p>运行1-2中的代码，输出结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">10</span><br><span class="line">b:</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>可见对象a与对象b的_elems都是相同的，静态成员被所有对象共享，甚至可以在不建立对象的情况下初始化。</p>
<h3 id="4-6-打造一个Iterator-Class（对class进行运算符重载操作）"><a href="#4-6-打造一个Iterator-Class（对class进行运算符重载操作）" class="headerlink" title="4.6 打造一个Iterator Class（对class进行运算符重载操作）"></a>4.6 打造一个Iterator Class（对class进行运算符重载操作）</h3><p>本章主要是建立一了一个Trianguar_iterator类，类中对==、=、 !=、*、++（包括前置，后置）等运算符进行了重载，并完成了class.begin(), class.end()两个函数的实现。</p>
<p>Triangular_iterator即相当于针对Triangular类的泛型指针。它维护一个索引值，通过这个索引来访问Triangular类中_elems的特定元素。</p>
<p>1、重载运算符定义</p>
<p>重载运算符的方法就像是定义member function。不过函数名称不能任意，需要按照”operator 运算符名“的格式来定义。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular_iterator</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Triangular_iterator&amp;) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line">    Triangular_iterator&amp; <span class="keyword">operator</span>++(); <span class="comment">//前置++</span></span><br><span class="line">    Triangular_iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>); <span class="comment">//后置++。后置可否也返回&amp;类型？</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _index;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">check_intergrity</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> Triangular_iterator::<span class="keyword">operator</span>==(<span class="keyword">const</span> Triangular_iterator&amp; rhs) <span class="keyword">const</span>&#123;</span><br><span class="line">  <span class="comment">//注意此处需要使用rhs的private data member。所以要进行friend关联操作，或者在Traingular_iterator中加入public函数作为访问接口。</span></span><br><span class="line">     <span class="keyword">return</span> _index == rhs._index; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重载运算符函数也可以不作为成员函数，但这样的话参数列表里应该要多加一个Traingular_iterator&amp;，作为对this指针的代替。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> Triangular_iterator::<span class="keyword">operator</span>==(<span class="keyword">const</span> Triangular_iterator&amp; a, Triangular_iterator&amp; b)&#123;</span><br><span class="line">     <span class="keyword">return</span> a._index == b._index; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、运算符重载规则</p>
<p>（1）不可以引入新的运算符。</p>
<p>（2）运算符的操作数不可以改变</p>
<p>（3）运算符的优先级不能被改变</p>
<p>（4）运算符的参数列表中，必须至少有一个参数为class类型</p>
<p>3、完整代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Triangular.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Triangular_iterator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular_iterator</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Triangular_iterator</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//意思是在Triangular的命名空间中，Triangular_iterator可以简化为iterator</span></span><br><span class="line">    <span class="keyword">typedef</span> Triangular_iterator iterator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//class.begin()</span></span><br><span class="line">    <span class="function">Triangular_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//class.end()</span></span><br><span class="line">    <span class="function">Triangular_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    Triangular(<span class="keyword">int</span> len = <span class="number">1</span>, <span class="keyword">int</span> bp = <span class="number">1</span>) &#123;</span><br><span class="line">        _length = len &gt; <span class="number">0</span> ? len : <span class="number">1</span>;</span><br><span class="line">        _beg_pos = bp &gt; <span class="number">0</span> ? bp : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> _length; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">beg_pos</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> _beg_pos; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gen_elems</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_elems</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _length;</span><br><span class="line">    <span class="keyword">int</span> _beg_pos;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _max_elems;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _elems;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Triangular.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Triangular.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Triangular::_elems;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Triangular::_max_elems = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Triangular::gen_elems</span><span class="params">(<span class="keyword">int</span> to_size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ix = _elems.size();</span><br><span class="line">    <span class="keyword">if</span> (!ix)</span><br><span class="line">    &#123;</span><br><span class="line">        _elems.push_back(<span class="number">1</span>);</span><br><span class="line">        ix = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ix &lt; to_size &amp;&amp; ix &lt; _max_elems) &#123;</span><br><span class="line">        ix++;</span><br><span class="line">        _elems.push_back(ix*(ix + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ix == _max_elems) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Exceed the max size of &quot;</span> &lt;&lt; _max_elems &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Triangular::print_elems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _elems.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; _elems[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Triangular_iterator <span class="title">Triangular::begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Triangular_iterator(_beg_pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Triangular_iterator <span class="title">Triangular::end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Triangular_iterator(_beg_pos + _length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Triangular_iterator.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Triangular.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Triangular_iterator(<span class="keyword">int</span> index) : _index(index - <span class="number">1</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Triangular_iterator&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> _index == rhs._index; &#125;;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Triangular_iterator&amp; rhs)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _index != rhs._index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    Triangular_iterator&amp; <span class="keyword">operator</span>++(); <span class="comment">//前置</span></span><br><span class="line">    Triangular_iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>); <span class="comment">//后置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">check_intergrity</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">int</span> _index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Triangular_iterator.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Triangular_iterator.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Triangular_iterator::check_intergrity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_index &gt;= Triangular::_max_elems)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;OverFlow&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_index &gt;= Triangular::_elems.size()) &#123;</span><br><span class="line">        Triangular::gen_elems(_index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Triangular_iterator&amp; Triangular_iterator:: <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    check_intergrity();</span><br><span class="line">    ++_index;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照重载的要求，后置++必须和前置++参数不同。于是后置++默认加一个int参数。可不用理会，编译器会自动处理。</span></span><br><span class="line">Triangular_iterator Triangular_iterator::<span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    check_intergrity();</span><br><span class="line">    ++_index;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Triangular_iterator::<span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">    check_intergrity();</span><br><span class="line">    <span class="comment">//如果_elems并非static类型，如何修改代码，使此函数能够确认对象的_elems是多少？</span></span><br><span class="line">    <span class="keyword">return</span> Triangular::_elems[_index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意，这里如果将成员函数设置为inline，定义在.h文件中，则Triangular类和Triangular_iterator类之间不能互相调用。会报错：使用了未定义类型“Triangular” or 使用了未定义类型”Triangular_iterator”</p>
<p>![image-20210408194045289](/Users/alice/Library/Application Support/typora-user-images/image-20210408194045289.png)</p>
<h3 id="4-7-合作关系必须建立在友谊的基础上"><a href="#4-7-合作关系必须建立在友谊的基础上" class="headerlink" title="4.7 合作关系必须建立在友谊的基础上"></a>4.7 合作关系必须建立在友谊的基础上</h3><p>class可以有friend函数和friend class。在class的声明中声明friend函数或者friend类，则其friend可以访问其private member。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular</span>&#123;</span></span><br><span class="line"><span class="comment">//friend声明可以放在任意地方，不受public和private影响</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">a</span>;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">int</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="4-9-实现一个function-object"><a href="#4-9-实现一个function-object" class="headerlink" title="4.9 实现一个function object"></a>4.9 实现一个function object</h3><p>function object：一种对象，提供有“函数调用”运算符。其实就是重载运算符”()”。</p>
<p>在3.6章中，有function object和泛型算法一起使用的例子。</p>
<p>例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LessThan</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LessThan(<span class="keyword">int</span> val) : _val(val)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">comp_val</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _val;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">comp_val</span><span class="params">(<span class="keyword">int</span> nval)</span></span>&#123;_val = nval;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//（）重载</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">LessThan::operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> value &lt; _val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_less_than</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> comp)</span></span>&#123;</span><br><span class="line">     <span class="comment">//初始化LessThan对象</span></span><br><span class="line">  <span class="function">LessThan <span class="title">it</span><span class="params">(comp)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;vec.size(); i++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(it(vec[i]))</span><br><span class="line">      count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>当编译器遇到函数调用语句，例如it(val);，则it可能是函数名称，函数指针，也可能是一个对象，此对象重载了()运算符。如果it是个对象，则编译器会在内部将此语句转化成it.operator(val);</b></p>
<h3 id="4-10-重载iostream运算符"><a href="#4-10-重载iostream运算符" class="headerlink" title="4.10 重载iostream运算符"></a>4.10 重载iostream运算符</h3><p>实质上是重载运算符&lt;&lt;和&gt;&gt;，本质没有变化。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-100. Same Tree</title>
    <url>/2021/03/25/LeetCode-100-Same-Tree/</url>
    <content><![CDATA[<h1 id="LeetCode-100-Same-Tree"><a href="#LeetCode-100-Same-Tree" class="headerlink" title="LeetCode-100. Same Tree"></a>LeetCode-100. Same Tree</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given two binary trees, write a function to check if they are the same or not.</p>
<p>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          &#x2F;           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>递归的中序遍历方法比较两棵树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p &amp;&amp; !q)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p&amp;&amp;q || p&amp;&amp;!q || p-&gt;val!=q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>非递归的先序遍历方法比较两棵树。使用栈，栈中先放右子树根结点，再放左子树根结点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s1;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s2;</span><br><span class="line">        s1.push(p);</span><br><span class="line">        s2.push(q);</span><br><span class="line">        <span class="keyword">while</span>(!s1.empty() &amp;&amp; !s2.empty())&#123;</span><br><span class="line">            p = s1.top(); s1.pop();</span><br><span class="line">            q = s2.top(); s2.pop();</span><br><span class="line">            <span class="keyword">if</span>(!p&amp;&amp;!q) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!p&amp;&amp;q || p&amp;&amp;!q || p-&gt;val!=q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            s1.push(p-&gt;right);</span><br><span class="line">            s2.push(q-&gt;right);</span><br><span class="line">            s1.push(p-&gt;left);</span><br><span class="line">            s2.push(q-&gt;left);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-97. Interleaving String</title>
    <url>/2021/03/25/Leetcode-97-Interleaving-String/</url>
    <content><![CDATA[<h1 id="Leetcode-97-Interleaving-String"><a href="#Leetcode-97-Interleaving-String" class="headerlink" title="Leetcode-97. Interleaving String"></a>Leetcode-97. Interleaving String</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given <em>s1</em>, <em>s2</em>, <em>s3</em>, find whether <em>s3</em> is formed by the interleaving of <em>s1</em> and <em>s2</em>.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbcbcac&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbbaccc&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>使用动态规划方法。<!--dp[i][j]-->表示s3中的前i+j个元素，可以由s1中的前i个元素和s2中的前j个元素构成。</p>
<p>从而可以初始化<!--dp[i][0]和dp[0][j]--></p>
<p>状态转移方程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] &#x3D; dp[i-1][j]&amp;&amp;s1[i-1]&#x3D;&#x3D;s3[i+j-1] || dp[i][j-1]&amp;&amp;s2[j-1]&#x3D;&#x3D;s3[i+j-1]</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.size()+s2.size() != s3.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = s1.size();</span><br><span class="line">        <span class="keyword">int</span> m = s2.size();</span><br><span class="line">        <span class="comment">//注意这种声明方式</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m+<span class="number">1</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] &amp;&amp; s3[i<span class="number">-1</span>] == s1[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;m+<span class="number">1</span>; j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>] &amp;&amp; s3[j<span class="number">-1</span>] == s2[j<span class="number">-1</span>];</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n+<span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;m+<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j<span class="number">-1</span>]&amp;&amp;s2[j<span class="number">-1</span>]==s3[i+j<span class="number">-1</span>] || dp[i<span class="number">-1</span>][j]&amp;&amp;s1[i<span class="number">-1</span>]==s3[i+j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">              </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-101. Symmetric Tree</title>
    <url>/2021/03/26/LeetCode-101-Symmetric-Tree/</url>
    <content><![CDATA[<h1 id="LeetCode-101-Symmetric-Tree"><a href="#LeetCode-101-Symmetric-Tree" class="headerlink" title="LeetCode-101. Symmetric Tree"></a>LeetCode-101. Symmetric Tree</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree is symmetric:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>

<p>But the following is not:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>

<p>Note:<br>Bonus points if you could solve it both recursively and iteratively.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> recursion(root-&gt;left, root-&gt;right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">recursion</span><span class="params">(TreeNode* leftNode, TreeNode* rightNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!leftNode &amp;&amp; !rightNode) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!leftNode&amp;&amp;rightNode || leftNode&amp;&amp;!rightNode || leftNode-&gt;val!=rightNode-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recursion(leftNode-&gt;left, rightNode-&gt;right) &amp;&amp; recursion(leftNode-&gt;right, rightNode-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-102. Binary Tree Level Order Traversal</title>
    <url>/2021/03/26/LeetCode-102-Binary-Tree-Level-Order-Traversal/</url>
    <content><![CDATA[<h1 id="LeetCode-102-Binary-Tree-Level-Order-Traversal"><a href="#LeetCode-102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="LeetCode-102. Binary Tree Level Order Traversal"></a>LeetCode-102. Binary Tree Level Order Traversal</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, return the <em>level order</em> traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>Given binary tree <code>&#123;3,9,20,#,#,15,7&#125;</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>return its level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>迭代方法。</p>
<p>使用队列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push_back(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">            <span class="keyword">int</span> _size = q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++)&#123;</span><br><span class="line">                TreeNode* root = q.front();</span><br><span class="line">                q.pop_front();</span><br><span class="line">                </span><br><span class="line">                level.push_back(root-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">                    q.push_back(root-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">                    q.push_back(root-&gt;right);</span><br><span class="line">                  </span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>递归方法。不需要队列存储，只要给一个层数的标识符level，用中序遍历方法遍历存储即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        recursion(root, res, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recursion</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="keyword">int</span> level)</span></span>&#123;   </span><br><span class="line">        <span class="comment">//if(!root) return;</span></span><br><span class="line">        <span class="keyword">if</span>(res.size()&lt;level) res.push_back(&#123;&#125;);</span><br><span class="line">        res[level<span class="number">-1</span>].push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) recursion(root-&gt;left, res, level+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) recursion(root-&gt;right, res, level+<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-104. Maximum Depth of Binary Tree</title>
    <url>/2021/03/27/LeetCode-104-Maximum-Depth-of-Binary-Tree/</url>
    <content><![CDATA[<h2 id="LeetCode-104-Maximum-Depth-of-Binary-Tree"><a href="#LeetCode-104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="LeetCode-104. Maximum Depth of Binary Tree"></a>LeetCode-104. Maximum Depth of Binary Tree</h2><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a binary tree, find its maximum depth.</span><br><span class="line"></span><br><span class="line">The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</span><br><span class="line"></span><br><span class="line">Note: A leaf is a node with no children.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">return its depth &#x3D; 3.</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = Depth(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(TreeNode* root, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> level;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(Depth(root-&gt;left, level+<span class="number">1</span>), Depth(root-&gt;right,level+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-103. Binary Tree Zigzag Level Order Traversal</title>
    <url>/2021/03/27/LeetCode-103-Binary-Tree-Zigzag-Level-Order-Traversal/</url>
    <content><![CDATA[<h1 id="LeetCode-103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#LeetCode-103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="LeetCode-103. Binary Tree Zigzag Level Order Traversal"></a>LeetCode-103. Binary Tree Zigzag Level Order Traversal</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, return the <em>zigzag level order</em> traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>return its zigzag level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>使用递归，以下做法是错误的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        recursion(root, <span class="number">1</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recursion</span><span class="params">(TreeNode* root, <span class="keyword">int</span> level, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(res.size() &lt; level)&#123;</span><br><span class="line">            res.push_back(&#123;&#125;);   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res[level<span class="number">-1</span>].push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(level%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">                recursion(root-&gt;right, level+<span class="number">1</span>, res);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">                recursion(root-&gt;left, level+<span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">                recursion(root-&gt;left, level+<span class="number">1</span>, res);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">                recursion(root-&gt;right, level+<span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>正确做法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        recursion(root, <span class="number">1</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recursion</span><span class="params">(TreeNode* root, <span class="keyword">int</span> level, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(res.size() &lt; level)&#123;</span><br><span class="line">            res.push_back(&#123;&#125;);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(level%<span class="number">2</span>==<span class="number">0</span>) res[level<span class="number">-1</span>].insert(res[level<span class="number">-1</span>].begin(),root-&gt;val);</span><br><span class="line">        <span class="keyword">else</span> res[level<span class="number">-1</span>].push_back(root-&gt;val);</span><br><span class="line">        </span><br><span class="line">        recursion(root-&gt;left, level+<span class="number">1</span>, res);</span><br><span class="line">        recursion(root-&gt;right, level+<span class="number">1</span>, res);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-107. Binary Tree Level Order Traversal ||</title>
    <url>/2021/03/30/LeetCode-107-Binary-Tree-Level-Order-Traversal/</url>
    <content><![CDATA[<h1 id="LeetCode-107-Binary-Tree-Level-Order-Traversal"><a href="#LeetCode-107-Binary-Tree-Level-Order-Traversal" class="headerlink" title="LeetCode-107. Binary Tree Level Order Traversal ||"></a>LeetCode-107. Binary Tree Level Order Traversal ||</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br>Given binary tree <code>&#123;3,9,20,#,#,15,7&#125;</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>return its bottom-up level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>正常按层次遍历，然后再反过来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        recursion(root, <span class="number">1</span>, res);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; (res.rbegin(), res.rend());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recursion</span><span class="params">(TreeNode* root, <span class="keyword">int</span> level, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(res.size()&lt;level)&#123;</span><br><span class="line">            res.push_back(&#123;&#125;);  </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res[level<span class="number">-1</span>].push_back(root-&gt;val);</span><br><span class="line">        recursion(root-&gt;left, level+<span class="number">1</span>, res);</span><br><span class="line">        recursion(root-&gt;right, level+<span class="number">1</span>, res);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-108. Convert Sorted Array to Binary Search Tree</title>
    <url>/2021/03/30/LeetCode-108-Convert-Sorted-Array-to-Binary-Search-Tree/</url>
    <content><![CDATA[<h1 id="LeetCode-108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#LeetCode-108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="LeetCode-108. Convert Sorted Array to Binary Search Tree"></a>LeetCode-108. Convert Sorted Array to Binary Search Tree</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em>node never differ by more than 1.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given the sorted array: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        TreeNode* root = recursion(<span class="number">0</span>, nums.size()<span class="number">-1</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root-&gt;left = recursion(left, mid<span class="number">-1</span>, nums);</span><br><span class="line">        root-&gt;right = recursion(mid+<span class="number">1</span>, right, nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-109. Convert Sorted List to Binary Search Tree</title>
    <url>/2021/03/30/LeetCode-109-Convert-Sorted-List-to-Binary-Search-Tree/</url>
    <content><![CDATA[<h1 id="LeetCode-109-Convert-Sorted-List-to-Binary-Search-Tree"><a href="#LeetCode-109-Convert-Sorted-List-to-Binary-Search-Tree" class="headerlink" title="LeetCode-109. Convert Sorted List to Binary Search Tree"></a>LeetCode-109. Convert Sorted List to Binary Search Tree</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given the sorted linked list: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>不同于108，将数组转化为平衡搜索树，list没有用下标取值操作。所以要使用快慢指针。快慢指针可以用来找中点，即fast指针一次向前移动两次，slow指针一次向前移动一次。</p>
<p>本题中，需要每次把当前list划分为中点、中点左侧的list和中点右侧的list。因此当前list需要传入首指针和末尾指针。末尾指针指的是list末尾元素的下一个地址，类似于iterator指针中的end()。但这里不能直接使用iterator，因为输入的是一个listNode类，而不是list<int>类。</p>
<p>此处刚开始遍历时，注意令末尾指针为NULL，也可以代表末尾元素的下一个地址。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* root = recursion(head, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">recursion</span><span class="params">(ListNode* start, ListNode* end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* fast = start;</span><br><span class="line">        ListNode* slow = start;</span><br><span class="line">        <span class="keyword">while</span>(fast!=end &amp;&amp; fast-&gt;next!=end)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = slow-&gt;next;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(slow-&gt;val);</span><br><span class="line">        root-&gt;left = recursion(start, slow);</span><br><span class="line">        root-&gt;right = recursion(slow-&gt;next, end);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-110. Balanced Binary Tree</title>
    <url>/2021/03/30/Leetcode-110-Balanced-Binary-Tree/</url>
    <content><![CDATA[<h1 id="LeetCode-110-Balanced-Binary-Tree"><a href="#LeetCode-110-Balanced-Binary-Tree" class="headerlink" title="LeetCode-110. Balanced Binary Tree"></a>LeetCode-110. Balanced Binary Tree</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as:</p>
<blockquote>
<p>a binary tree in which the depth of the two subtrees of <em>every</em>node never differ by more than 1.</p>
</blockquote>
<p>Example 1:</p>
<p>Given the following tree <code>[3,9,20,null,null,15,7]</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>Return true.</p>
<p>Example 2:</p>
<p>Given the following tree <code>[1,2,2,3,3,null,null,4,4]</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      1</span><br><span class="line">     &#x2F; \</span><br><span class="line">    2   2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   3</span><br><span class="line"> &#x2F; \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure>

<p>Return false.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>还是要求树的深度。本质上是判断树的左右子树深度相差是否小于等于1。这里要注意的是，递归是从底至上return值，如果子树已经不平衡了，则已不满足条件，返回标识符-1，没有必要继续递归下去了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(level(root) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">level</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = level(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = level(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="built_in">abs</span>(left-right);</span><br><span class="line">        <span class="keyword">if</span>(diff&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+max(left, right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-111. Minimum Depth of Binary Tree</title>
    <url>/2021/03/31/LeetCode-111-Minimum-Depth-of-Binary-Tree/</url>
    <content><![CDATA[<h1 id="LeetCode-111-Minimum-Depth-of-Binary-Tree"><a href="#LeetCode-111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="LeetCode-111. Minimum Depth of Binary Tree"></a>LeetCode-111. Minimum Depth of Binary Tree</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p>Note: A leaf is a node with no children.</p>
<p>Example:</p>
<p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>return its minimum depth = 2</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>注意，这道题不能直接返回min(minDepth(root-&gt;left), minDepth(root-&gt;right))+1。这道题和求树的最大深度不一样。</p>
<p>求树的最大深度代码如下：</p>
<p>求最大深度因为是取max，所以能保证一定会递归到叶子结点。但是取min的话，如果当前节点缺失一边的子节点，则会停止计数，然而实际上没有计算到叶子结点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>本题需要分情况讨论，讨论当前节点有没有左右节点。</p>
<p>我的做法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!root-&gt;left &amp;&amp; root-&gt;right)</span><br><span class="line">            <span class="keyword">return</span> minDepth(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!root-&gt;right &amp;&amp; root-&gt;left)</span><br><span class="line">            <span class="keyword">return</span> minDepth(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> min(minDepth(root-&gt;left), minDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更简单的分类讨论：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left) <span class="keyword">return</span> <span class="number">1</span> + minDepth(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;right) <span class="keyword">return</span> <span class="number">1</span> + minDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + min(minDepth(root-&gt;left), minDepth(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-114. Flatten Binary Tree to Linked List</title>
    <url>/2021/03/31/LeetCode-114-Flatten-Binary-Tree-to-Linked-List/</url>
    <content><![CDATA[<h1 id="LeetCode-114-Flatten-Binary-Tree-to-Linked-List"><a href="#LeetCode-114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="LeetCode-114. Flatten Binary Tree to Linked List"></a>LeetCode-114. Flatten Binary Tree to Linked List</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   5</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3   4   6</span><br></pre></td></tr></table></figure>

<p>The flattened tree should look like:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure>

<p><a href="https://oj.leetcode.com/problems/flatten-binary-tree-to-linked-list/">click to show hints.</a></p>
<p>Hints:</p>
<p>If you notice carefully in the flattened tree, each node’s right child points to the next node of a pre-order trave</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>先序遍历树，一边遍历，一边更新链表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        TreeNode* dumpy = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        TreeNode* prev = dumpy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            TreeNode* curr = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;right) q.push(curr-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;left) q.push(curr-&gt;left);            </span><br><span class="line">            </span><br><span class="line">            prev-&gt;right = curr;</span><br><span class="line">            prev-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            prev = curr;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        root =  dumpy-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-116. Populating Next Right Pointers in Each Node</title>
    <url>/2021/04/07/LeetCode-116-Populating-Next-Right-Pointers-in-Each-Node/</url>
    <content><![CDATA[<h1 id="LeetCode-116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#LeetCode-116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="LeetCode-116. Populating Next Right Pointers in Each Node"></a>LeetCode-116. Populating Next Right Pointers in Each Node</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>
<p>Initially, all next pointers are set to <code>NULL</code>.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) root-&gt;right-&gt;next = root-&gt;next ? root-&gt;next-&gt;left : <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        connect(root-&gt;left);</span><br><span class="line">        connect(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-117. Populating Next Right Pointers in Each Node ||</title>
    <url>/2021/04/07/LeetCode-117-Populating-Next-Right-Pointers-in-Each-Node/</url>
    <content><![CDATA[<h1 id="LeetCode-117-Populating-Next-Right-Pointers-in-Each-Node"><a href="#LeetCode-117-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="LeetCode-117. Populating Next Right Pointers in Each Node ||"></a>LeetCode-117. Populating Next Right Pointers in Each Node ||</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>
<p>Initially, all next pointers are set to <code>NULL</code>.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        Node* p = root-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left)&#123;</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right)&#123;</span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) root-&gt;left-&gt;next = root-&gt;right ? root-&gt;right : p;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) root-&gt;right-&gt;next = p;</span><br><span class="line">        <span class="comment">//这里必须先遍历右子节点，再遍历左子节点。因为希望在连接当前层节点时，上一层root和root右侧的next指针都已经连接好。这样p才可以定位到正确的位置。如果上层root右侧节点的next指针还没有连好，则p = p-&gt;next会中断，引起错误。</span></span><br><span class="line">        connect(root-&gt;left);        </span><br><span class="line">        connect(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-118. Pascal&#39;s Triangle</title>
    <url>/2021/04/08/LeetCode-118-Pascal-s-Triangle/</url>
    <content><![CDATA[<h1 id="LeetCode-118-Pascal’s-Triangle"><a href="#LeetCode-118-Pascal’s-Triangle" class="headerlink" title="LeetCode-118. Pascal’s Triangle"></a>LeetCode-118. Pascal’s Triangle</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a non-negative integer <em>numRows</em>, generate the first <em>numRows</em> of Pascal’s triangle.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="img"><br>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Given a non-negative integer numRows, generate the first numRows of Pascal<span class="number">&#x27;</span>s triangle.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In Pascal<span class="number">&#x27;</span>s triangle, each number is the sum of the two numbers directly above it.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: <span class="number">5</span></span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">     [<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">   [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-119. Pascal&#39;s Triangle ||</title>
    <url>/2021/04/08/LeetCode-119-Pascal-s-Triangle/</url>
    <content><![CDATA[<h1 id="LeetCode-119-Pascal’s-Triangle"><a href="#LeetCode-119-Pascal’s-Triangle" class="headerlink" title="LeetCode-119. Pascal’s Triangle ||"></a>LeetCode-119. Pascal’s Triangle ||</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a non-negative index <em>k</em> where <em>k</em> ≤ 33, return the <em>k</em>th index row of the Pascal’s triangle.</p>
<p>Note that the row index starts from 0.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="img"><br>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: [1,3,3,1]</span><br></pre></td></tr></table></figure>

<p>Follow up:</p>
<p>Could you optimize your algorithm to use only <em>O</em>(<em>k</em>) extra space?</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>主要是要求O(k)的占用空间不太好想。把握住，每一层的第i个数，和第i-1个数相加，就能形成下一行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">row</span><span class="params">(rowIndex+<span class="number">1</span>)</span></span>;</span><br><span class="line">        row[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=rowIndex; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">                row[j] += row[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> row;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-120. Triangle</title>
    <url>/2021/04/09/LeetCode-120-Triangle/</url>
    <content><![CDATA[<h1 id="LeetCode-120-Triangle"><a href="#LeetCode-120-Triangle" class="headerlink" title="LeetCode-120. Triangle"></a>LeetCode-120. Triangle</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>
<p>For example, given the following triangle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>The minimum path sum from top to bottom is <code>11</code> (i.e., 2 + 3 + 5 + 1 = 11).</p>
<p>Note:<br>Bonus point if you are able to do this using only <em>O</em>(<em>n</em>) extra space, where <em>n</em> is the total number of rows in the triangle.</p>
<h2 id="Soution"><a href="#Soution" class="headerlink" title="Soution"></a>Soution</h2><p>典型的动态规划题，要记住学会建立二维数组，对每一点都动态规划到。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;prices.size(); i++)&#123;</span><br><span class="line">            start = min(start, prices[i]);</span><br><span class="line">            res = max(res, prices[i]-start);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-121. Best Time to Buy and Sell Stock</title>
    <url>/2021/04/09/LeetCode-121-Best-Time-to-Buy-and-Sell-Stock/</url>
    <content><![CDATA[<h1 id="LeetCode-121-Best-Time-to-Buy-and-Sell-Stock"><a href="#LeetCode-121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="LeetCode-121. Best Time to Buy and Sell Stock"></a>LeetCode-121. Best Time to Buy and Sell Stock</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>只遍历一遍数组，不断更新最小的买入点start，res保留最大的收益值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;prices.size(); i++)&#123;</span><br><span class="line">            start = min(start, prices[i]);</span><br><span class="line">            res = max(res, prices[i]-start);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-122. Best Time to Buy and Sell Stock ||</title>
    <url>/2021/04/10/LeetCode-122-Best-Time-to-Buy-and-Sell-Stock/</url>
    <content><![CDATA[<h1 id="LeetCode-122-Best-Time-to-Buy-and-Sell-Stock"><a href="#LeetCode-122-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="LeetCode-122. Best Time to Buy and Sell Stock ||"></a>LeetCode-122. Best Time to Buy and Sell Stock ||</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>涨的话就一直持有，所以今天只要比昨天价高，就将今天-昨天的利润加入res。跌的话，当卖掉了，不做res的修改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i<span class="number">-1</span>])&#123;</span><br><span class="line">                res += prices[i]-prices[i<span class="number">-1</span>];   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-125. Valid Palindrome</title>
    <url>/2021/04/10/LeetCode-125-Valid-Palindrome/</url>
    <content><![CDATA[<h1 id="LeetCode-125-Valid-Palindrome"><a href="#LeetCode-125-Valid-Palindrome" class="headerlink" title="LeetCode-125. Valid Palindrome"></a>LeetCode-125. Valid Palindrome</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Given a <span class="built_in">string</span>, determine <span class="keyword">if</span> it is a palindrome, considering only alphanumeric characters <span class="keyword">and</span> ignoring cases.</span><br><span class="line"></span><br><span class="line">For example,</span><br><span class="line"><span class="string">&quot;A man, a plan, a canal: Panama&quot;</span> is a palindrome.</span><br><span class="line"><span class="string">&quot;race a car&quot;</span> is <span class="keyword">not</span> a palindrome.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line">Have you consider that the <span class="built_in">string</span> might be empty? This is a good question to ask during an interview.</span><br><span class="line"></span><br><span class="line">For the purpose of <span class="keyword">this</span> problem, we define empty <span class="built_in">string</span> as valid palindrome.</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>主要注意一下ASC||码中，大写字母+32 = 小写字母。且大写字母和小写字母的码之间差了一些其他符号，不是紧密相连。</p>
<p>判断一个char是不是字母或数字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAlphaNum</span><span class="params">(<span class="keyword">char</span> &amp;ch)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&#x27;a&#x27;</span>&lt;=ch &amp;&amp; ch&lt;=<span class="string">&#x27;z&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&#x27;A&#x27;</span>&lt;=ch &amp;&amp; ch&lt;=<span class="string">&#x27;Z&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&#x27;0&#x27;</span>&lt;=ch &amp;&amp; ch&lt;=<span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意一下当小写字母和大写字母当作相等时的写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = s.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(s[i])) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(s[j])) &#123;</span><br><span class="line">                j--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这样写是错误的，因为有可能出现数字+32=字母。比如0的ASC||为48，P的ASC||为80</span></span><br><span class="line">            <span class="comment">/*if (s[i] == s[j] || s[i] + 32 == s[j] || s[j] + 32 == s[i]) &#123;</span></span><br><span class="line"><span class="comment">                    i++;</span></span><br><span class="line"><span class="comment">                    j--;</span></span><br><span class="line"><span class="comment">                    continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            else &#123;</span></span><br><span class="line"><span class="comment">                return false;</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            <span class="keyword">if</span>((s[i]+<span class="number">32</span>-<span class="string">&#x27;a&#x27;</span>)%<span class="number">32</span> != (s[j]+<span class="number">32</span>-<span class="string">&#x27;a&#x27;</span>)%<span class="number">32</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Two Pointers</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-129. Sum Root to Leaf Numbers</title>
    <url>/2021/04/12/LeetCode-129-Sum-Root-to-Leaf-Numbers/</url>
    <content><![CDATA[<h1 id="LeetCode-129-Sum-Root-to-Leaf-Numbers"><a href="#LeetCode-129-Sum-Root-to-Leaf-Numbers" class="headerlink" title="LeetCode-129. Sum Root to Leaf Numbers"></a>LeetCode-129. Sum Root to Leaf Numbers</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree containing digits from <code>0-9</code> only, each root-to-leaf path could represent a number.</p>
<p>An example is the root-to-leaf path <code>1-&gt;2-&gt;3</code> which represents the number <code>123</code>.</p>
<p>Find the total sum of all root-to-leaf numbers.</p>
<p>Note: A leaf is a node with no children.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">Output: 25</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 1-&gt;2 represents the number 12.</span><br><span class="line">The root-to-leaf path 1-&gt;3 represents the number 13.</span><br><span class="line">Therefore, sum &#x3D; 12 + 13 &#x3D; 25.</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [4,9,0,5,1]</span><br><span class="line">    4</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9   0</span><br><span class="line"> &#x2F; \</span><br><span class="line">5   1</span><br><span class="line">Output: 1026</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.</span><br><span class="line">The root-to-leaf path 4-&gt;0 represents the number 40.</span><br><span class="line">Therefore, sum &#x3D; 495 + 491 + 40 &#x3D; 1026.</span><br></pre></td></tr></table></figure>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        recursion(root, <span class="built_in">std</span>::to_string(root-&gt;val), res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recursion</span><span class="params">(TreeNode* root, <span class="built_in">string</span> num, <span class="keyword">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> num_ = atoi(num.c_str());</span><br><span class="line">            res = res + num_;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            <span class="built_in">string</span> str_ = <span class="built_in">std</span>::to_string(root-&gt;left-&gt;val);</span><br><span class="line">            <span class="built_in">string</span> num_l = num + str_;</span><br><span class="line">            recursion(root-&gt;left, num_l, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            <span class="built_in">string</span> str_ = <span class="built_in">std</span>::to_string(root-&gt;right-&gt;val);</span><br><span class="line">            <span class="built_in">string</span> num_r = num + str_;</span><br><span class="line">            recursion(root-&gt;right, num_r, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-130 Surrounded Regions</title>
    <url>/2021/04/12/LeetCode-130-Surrounded-Regions/</url>
    <content><![CDATA[<h1 id="LeetCode-130-Surrounded-Regions"><a href="#LeetCode-130-Surrounded-Regions" class="headerlink" title="LeetCode-130 Surrounded Regions"></a>LeetCode-130 Surrounded Regions</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a 2D board containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code>(the letter O), capture all regions surrounded by <code>&#39;X&#39;</code>.</p>
<p>A region is captured by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>

<p>After running your function, the board should be:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>

<p>Explanation:</p>
<p>Surrounded regions shouldn’t be on the border, which means that any <code>&#39;O&#39;</code> on the border of the board are not flipped to <code>&#39;X&#39;</code>. Any <code>&#39;O&#39;</code> that is not on the border and it is not connected to an <code>&#39;O&#39;</code> on the border will be flipped to <code>&#39;X&#39;</code>. Two cells are connected if they are adjacent cells connected horizontally or vertically.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>大体思路比较简单，主要要想到用什么方式做四领域遍历比较好。</p>
<p>若边缘含有’O’，则从此点开始遍历。遇到‘O’，将其设为’#’，表示此点的’O’不应变为’X’。遍历完后，将’O’变为’X’，’#’’变为’O’。</p>
<p>注意board为vector&lt;vector<char>&gt;类型，因此应用’O’，而不是’#’。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;board[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((j == <span class="number">0</span> || j == board[<span class="number">0</span>].size()<span class="number">-1</span> || i ==<span class="number">0</span> || i == board.size()<span class="number">-1</span>) &amp;&amp; board[i][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                  dfs(i,j,board);  </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;board.size(); i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;board[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="comment">//注意，这两句话不能交换顺序！若是先#-&gt;O,则会进而执行O-&gt;X</span></span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>) board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;#&#x27;</span>) board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">            board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;board.size()<span class="number">-1</span> &amp;&amp; board[i+<span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                dfs(i+<span class="number">1</span>, j, board);</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; board[i<span class="number">-1</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                dfs(i<span class="number">-1</span>, j, board);</span><br><span class="line">            <span class="keyword">if</span>(j&lt;board[<span class="number">0</span>].size()<span class="number">-1</span> &amp;&amp; board[i][j+<span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">               dfs(i, j+<span class="number">1</span>, board);</span><br><span class="line">            <span class="keyword">if</span>(j&gt;<span class="number">0</span> &amp;&amp; board[i][j<span class="number">-1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">               dfs(i, j<span class="number">-1</span>, board);</span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-131. Palindrome Partitioning</title>
    <url>/2021/04/13/LeetCode-131-Palindrome-Partitioning/</url>
    <content><![CDATA[<h1 id="LeetCode-131-Palindrome-Partitioning"><a href="#LeetCode-131-Palindrome-Partitioning" class="headerlink" title="LeetCode-131. Palindrome Partitioning"></a>LeetCode-131. Palindrome Partitioning</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p>
<p>Return all possible palindrome partitioning of <em>s</em>.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;aab&quot;</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="Soution"><a href="#Soution" class="headerlink" title="Soution"></a>Soution</h2><p>经典的回溯写法。记住这种out.push_back-&gt;dfs-&gt;out.pop_back()的写法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; out;</span><br><span class="line">        dfs(res, s, out, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp;res, <span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; out, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == s.size())&#123;</span><br><span class="line">            res.push_back(out);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isPalindrome(s, start, i)) <span class="keyword">continue</span>;</span><br><span class="line">            out.push_back(s.substr(start, i-start+<span class="number">1</span>));</span><br><span class="line">            dfs(res, s, out, i+<span class="number">1</span>);</span><br><span class="line">            out.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[start]!=s[end]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Backtracking</category>
      </categories>
      <tags>
        <tag>Leecode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-133. Clone Graph</title>
    <url>/2021/04/13/LeetCode-133-Clone-Graph/</url>
    <content><![CDATA[<h1 id="LeetCode-133-Clone-Graph"><a href="#LeetCode-133-Clone-Graph" class="headerlink" title="LeetCode-133. Clone Graph"></a>LeetCode-133. Clone Graph</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a reference of a node in a <a href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph">connected</a> undirected graph, return a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy">deep copy</a> (clone) of the graph. Each node in the graph contains a val (<code>int</code>) and a list (<code>List[Node]</code>) of its neighbors.</p>
<p>Example:</p>
<p><img src="https://assets.leetcode.com/uploads/2019/02/19/113_sample.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">&#123;&quot;$id&quot;:&quot;1&quot;,&quot;neighbors&quot;:[&#123;&quot;$id&quot;:&quot;2&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;1&quot;&#125;,&#123;&quot;$id&quot;:&quot;3&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&#123;&quot;$id&quot;:&quot;4&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;3&quot;&#125;,&#123;&quot;$ref&quot;:&quot;1&quot;&#125;],&quot;val&quot;:4&#125;],&quot;val&quot;:3&#125;],&quot;val&quot;:2&#125;,&#123;&quot;$ref&quot;:&quot;4&quot;&#125;],&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Node 1&#39;s value is 1, and it has two neighbors: Node 2 and 4.</span><br><span class="line">Node 2&#39;s value is 2, and it has two neighbors: Node 1 and 3.</span><br><span class="line">Node 3&#39;s value is 3, and it has two neighbors: Node 2 and 4.</span><br><span class="line">Node 4&#39;s value is 4, and it has two neighbors: Node 1 and 3.</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>The number of nodes will be between 1 and 100.</li>
<li>The undirected graph is a <a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)#Simple_graph">simple graph</a>, which means no repeated edges and no self-loops in the graph.</li>
<li>Since the graph is undirected, if node <em>p</em> has node <em>q</em> as neighbor, then node <em>q</em> must have node <em>p</em> as neighbor too.</li>
<li>You must return the copy of the given node as a reference to the cloned graph.</li>
</ol>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>deep copy &amp; shallow copy</p>
<p>以python语法为例</p>
<p>（1）a=b，则a，b都指向同一个对象</p>
<p>（2）浅拷贝，b=a.copy()，则b新建了一个对象，但这个对象的子对象还是和a同一个对象。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br><span class="line">b = a.copy()</span><br><span class="line">a[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line">&gt;&gt;a</span><br><span class="line">&#123;<span class="number">1</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]&#125;</span><br><span class="line">&gt;&gt;b</span><br><span class="line">&#123;<span class="number">1</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（3）深拷贝，b = copy.deepcopy(a)，b完全拷贝了a的父对象及子对象，b和a完全独立。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br><span class="line">b = a.copy()</span><br><span class="line">a[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line">&gt;&gt;a</span><br><span class="line">&#123;<span class="number">1</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]&#125;</span><br><span class="line">&gt;&gt;b</span><br><span class="line">&#123;<span class="number">1</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h4><p>DFS写法。clone-&gt;neighbors.push_back(helper(neighbor, m))时候，进入当前点的neigbor的dfs遍历。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; m;</span><br><span class="line">        <span class="keyword">return</span> helper(node, m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node* <span class="title">helper</span><span class="params">(Node* node, <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt;&amp; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (m.count(node)) <span class="keyword">return</span> m[node];</span><br><span class="line">        Node *clone = <span class="keyword">new</span> Node(node-&gt;val);</span><br><span class="line">        m[node] = clone;</span><br><span class="line">        <span class="keyword">for</span> (Node *neighbor : node-&gt;neighbors) &#123;</span><br><span class="line">            clone-&gt;neighbors.push_back(helper(neighbor, m));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h4><p>BFS写法，使用一个queue，遍历到当前点时，将该点未遍历过的neighbor加入queue</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; m;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; q&#123;&#123;node&#125;&#125;;</span><br><span class="line">        Node *clone = <span class="keyword">new</span> Node(node-&gt;val);</span><br><span class="line">        m[node] = clone;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            Node *t = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (Node *neighbor : t-&gt;neighbors) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!m.count(neighbor)) &#123;</span><br><span class="line">                    m[neighbor] = <span class="keyword">new</span> Node(neighbor-&gt;val);</span><br><span class="line">                    q.push(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">                m[t]-&gt;neighbors.push_back(m[neighbor]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>DFS</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-134. Gas Station</title>
    <url>/2021/04/16/LeetCode-134-Gas-Station/</url>
    <content><![CDATA[<h1 id="LeetCode-134-Gas-Station"><a href="#LeetCode-134-Gas-Station" class="headerlink" title="LeetCode-134. Gas Station"></a>LeetCode-134. Gas Station</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>There are <em>N</em> gas stations along a circular route, where the amount of gas at station <em>i</em> is <code>gas[i]</code>.</p>
<p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from station <em>i</em> to its next station (<em>i</em>+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1.</p>
<p>Note:<br>The solution is guaranteed to be unique.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = gas.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = help(gas, cost, i);</span><br><span class="line">            <span class="keyword">if</span>(index &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">help</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">cos</span>, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = gas.size();</span><br><span class="line">        <span class="keyword">int</span> initial = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> gas_have = gas[i];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> gas_cost = <span class="built_in">cos</span>[i];</span><br><span class="line">            <span class="keyword">if</span>(gas_have &gt;= gas_cost)&#123;</span><br><span class="line">                i = (i+<span class="number">1</span>)%N;</span><br><span class="line">                gas_have = gas_have - gas_cost + gas[i];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(i == initial)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Greedy</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-136. Single Number</title>
    <url>/2021/04/16/LeetCode-136-Single-Number/</url>
    <content><![CDATA[<h1 id="LeetCode-136-Single-Number"><a href="#LeetCode-136-Single-Number" class="headerlink" title="LeetCode-136. Single Number"></a>LeetCode-136. Single Number</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>方法一：哈希表法。第一次出现-&gt;加入哈希表；第二次出现-&gt;从哈希表中移除。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; iset;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(iset.count(nums[i])) iset.erase(nums[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                iset.insert(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *iset.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法二：位运算法</p>
<p>用异或位运算法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">            res ^= num;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Hash Table</category>
        <category>Bit Manipulation</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-137. Single Number||</title>
    <url>/2021/04/16/LeetCode-137-Single-Number/</url>
    <content><![CDATA[<h1 id="LeetCode-137-Single-Number"><a href="#LeetCode-137-Single-Number" class="headerlink" title="LeetCode-137. Single Number||"></a>LeetCode-137. Single Number||</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a non-empty array of integers, every element appears <em>three</em> times except for one, which appears exactly once. Find that single one.</p>
<p>Note:</p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,2,3,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [0,1,0,1,0,1,99]</span><br><span class="line">Output: 99</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">32</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num :nums)&#123;</span><br><span class="line">                <span class="comment">//注意加括号，防止计算顺序出错</span></span><br><span class="line">                sum = sum + ((num&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res = res | ( (sum%<span class="number">3</span>)&lt;&lt;i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Hash Map</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-138. Copy List with Random Pointer</title>
    <url>/2021/04/16/LeetCode-138-Copy-List-with-Random-Pointer/</url>
    <content><![CDATA[<h1 id="LeetCode-138-Copy-List-with-Random-Pointer"><a href="#LeetCode-138-Copy-List-with-Random-Pointer" class="headerlink" title="LeetCode-138. Copy List with Random Pointer"></a>LeetCode-138. Copy List with Random Pointer</h1><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy">deep copy</a> of the list.</p>
<p>Example 1:</p>
<p><img src="https://discuss.leetcode.com/uploads/files/1470150906153-2yxeznm.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">&#123;&quot;$id&quot;:&quot;1&quot;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;next&quot;:null,&quot;random&quot;:&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&quot;val&quot;:2&#125;,&quot;random&quot;:&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Node 1&#39;s value is 1, both of its next and random pointer points to Node 2.</span><br><span class="line">Node 2&#39;s value is 2, its next pointer points to null and its random pointer points to itself.</span><br></pre></td></tr></table></figure>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>哈希+一遍遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;Node*, Node*&gt; m;</span><br><span class="line">        Node* dumpy = <span class="keyword">new</span> Node(<span class="number">-1</span>);</span><br><span class="line">        Node* curr = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">            Node* new_curr = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span>(!m.count(curr))&#123;</span><br><span class="line">                new_curr = <span class="keyword">new</span> Node(curr-&gt;val, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">                m[curr] = new_curr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">               new_curr = m[curr];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!dumpy-&gt;next) dumpy-&gt;next = new_curr;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;next)&#123;</span><br><span class="line">                <span class="keyword">if</span>(m.count(curr-&gt;next))</span><br><span class="line">                    new_curr-&gt;next = m[curr-&gt;next];</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    Node* new_next = <span class="keyword">new</span> Node(curr-&gt;next-&gt;val, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">                    new_curr-&gt;next = new_next;</span><br><span class="line">                    m[curr-&gt;next] = new_next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;random)&#123;</span><br><span class="line">                <span class="keyword">if</span>(m.count(curr-&gt;random))</span><br><span class="line">                    new_curr-&gt;random = m[curr-&gt;random];</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    Node* new_random = <span class="keyword">new</span> Node(curr-&gt;random-&gt;val, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">                    new_curr-&gt;random = new_random;</span><br><span class="line">                    m[curr-&gt;random] = new_random;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dumpy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;Node*, Node*&gt; m;</span><br><span class="line">        <span class="keyword">return</span> help(head, m);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function">Node* <span class="title">help</span><span class="params">(Node* node, <span class="built_in">map</span>&lt;Node*, Node*&gt;&amp; m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(m.count(node)) <span class="keyword">return</span> m[node];</span><br><span class="line">        </span><br><span class="line">        Node* new_node = <span class="keyword">new</span> Node(node-&gt;val);</span><br><span class="line">        m[node] = new_node;</span><br><span class="line">        </span><br><span class="line">        new_node-&gt;next = help(node-&gt;next, m);</span><br><span class="line">        new_node-&gt;random = help(node-&gt;random, m);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> new_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Hash Map</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-139. Word Break</title>
    <url>/2021/04/17/LeetCode-139-Word-Break/</url>
    <content><![CDATA[<h1 id="LeetCode-139-Word-Break"><a href="#LeetCode-139-Word-Break" class="headerlink" title="LeetCode-139. Word Break"></a>LeetCode-139. Word Break</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a non-empty string <em>s</em> and a dictionary <em>wordDict</em> containing a list of non-empty words, determine if <em>s</em> can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p>Note:</p>
<ul>
<li>The same word in the dictionary may be reused multiple times in the segmentation.</li>
<li>You may assume the dictionary does not contain duplicate words.</li>
</ul>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.</span><br><span class="line">             Note that you are allowed to reuse a dictionary word.</span><br></pre></td></tr></table></figure>

<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h4><p>首先想到回溯法，但是超过时间限制。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">wordSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> help(<span class="number">0</span>, s, wordSet);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span> start, <span class="built_in">string</span>&amp; s, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&amp; wordSet)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(wordSet.count(s.substr(start, s.size()-start)))</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size()-start+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> out = s.substr(start, i);</span><br><span class="line">            <span class="keyword">if</span>(wordSet.count(out))&#123;</span><br><span class="line">                <span class="keyword">int</span> res = help(i+start, s, wordSet);</span><br><span class="line">                <span class="keyword">if</span>(res) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>回溯法中加一个memo数组，用来存储已经计算过的情况。例如，memo[i]表示i~s.size()-1是否可拆分的情况。memo[i]=0：不可拆；memo[i] = 1：可拆；memo[i] = -1：还未计算。</p>
<h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h4><p>动态规划法。dp[i]表示字符0～i-1是否能分割（dp多建立了一位，为了让遍历方便开始，有点像dumpy节点）。</p>
<p>求dp[i]的时候，dp[0]<del>dp[i-1]都已经求得了，所以求的时候用j在0～i-1之间的字符串进行切割，形成0～j-1和j～i-1。0～j对应dp[j]，j</del>i-1对应s.substr(j, i-1)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">wordSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(s.size()+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;s.size()+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &amp;&amp; wordSet.count(s.substr(j, i-j)))&#123;</span><br><span class="line">                    dp[i] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Backtracking</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-141. Linked List Cycle</title>
    <url>/2021/04/17/LeetCode-141-Linked-List-Cycle/</url>
    <content><![CDATA[<h1 id="LeetCode-141-Linked-List-Cycle"><a href="#LeetCode-141-Linked-List-Cycle" class="headerlink" title="LeetCode-141. Linked List Cycle"></a>LeetCode-141. Linked List Cycle</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a linked list, determine if it has a cycle in it.</p>
<p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>快慢指针。如果有环，最有一个节点的next指针指向空。如果无环，fast节点总会与slow节点相遇。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Two Pointers</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-142. Linked List Cycle｜｜</title>
    <url>/2021/04/19/LeetCode-142-Linked-List-Cycle%EF%BD%9C%EF%BD%9C/</url>
    <content><![CDATA[<h1 id="LeetCode-142-Linked-List-Cycle｜｜"><a href="#LeetCode-142-Linked-List-Cycle｜｜" class="headerlink" title="LeetCode-142. Linked List Cycle｜｜"></a>LeetCode-142. Linked List Cycle｜｜</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p>
<p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p>
<p>Note: Do not modify the linked list.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">Output: tail connects to node index 1</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">Output: tail connects to node index 0</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the first node.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">Output: no cycle</span><br><span class="line">Explanation: There is no cycle in the linked list.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>依然是快慢指针追赶问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!fast || !fast-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Linked List</category>
        <category>Two Pointers</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-143. Reorder List</title>
    <url>/2021/04/19/LeetCode-143-Reorder-List/</url>
    <content><![CDATA[<h1 id="LeetCode-143-Reorder-List"><a href="#LeetCode-143-Reorder-List" class="headerlink" title="LeetCode-143. Reorder List"></a>LeetCode-143. Reorder List</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a singly linked list <em>L</em>: <em>L</em>0→<em>L</em>1→…→<em>L**n</em>-1→<em>L</em>n,<br>reorder it to: <em>L</em>0→<em>L**n</em>→<em>L</em>1→<em>L**n</em>-1→<em>L</em>2→<em>L**n</em>-2→…</p>
<p>You may not modify the values in the list’s nodes, only nodes itself may be changed.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3.</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>快慢指针找中点-&gt;后半截入栈-&gt;从head和栈top开始交替连接结点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* prev = head;</span><br><span class="line">        <span class="comment">//找中间点</span></span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123;</span><br><span class="line">            prev = slow;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)</span><br><span class="line">                <span class="keyword">break</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        prev = slow;</span><br><span class="line">        <span class="keyword">if</span>(slow-&gt;next)</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; _stack;</span><br><span class="line">        <span class="comment">//断开中间点</span></span><br><span class="line">        prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从中间点后一个点开始入栈</span></span><br><span class="line">        <span class="keyword">while</span>(slow)&#123;</span><br><span class="line">            _stack.push(slow);</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交替连接点</span></span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span>(!_stack.empty())&#123;</span><br><span class="line">            ListNode* nextNode = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;next)</span><br><span class="line">                nextNode = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = _stack.top();</span><br><span class="line">            _stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(nextNode)&#123;</span><br><span class="line">                curr-&gt;next-&gt;next = nextNode;</span><br><span class="line">                curr = nextNode;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                curr-&gt;next-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>全部入栈，栈可以直接求出大小，于是找到中点。在到达终点前head和栈top开始交替插入节点。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Linked List</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-144. Binary Tree Preorder Traversal</title>
    <url>/2021/04/20/LeetCode-144-Binary-Tree-Preorder-Traversal/</url>
    <content><![CDATA[<h1 id="LeetCode-144-Binary-Tree-Preorder-Traversal"><a href="#LeetCode-144-Binary-Tree-Preorder-Traversal" class="headerlink" title="LeetCode-144. Binary Tree Preorder Traversal"></a>LeetCode-144. Binary Tree Preorder Traversal</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>前序遍历，根-&gt;左-&gt;右</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>递归法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        help(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        help(root-&gt;left,res);</span><br><span class="line">        help(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>迭代法。用栈。弹出栈顶-&gt;栈顶元素加入res-&gt;右节点入栈-&gt;左节点入栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">            st.push(root);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            TreeNode* n = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            res.push_back(n-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(n-&gt;right) st.push(n-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(n-&gt;left) st.push(n-&gt;left);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-145. Binary Tree Postorder Traversal</title>
    <url>/2021/04/20/LeetCode-145-Binary-Tree-Postorder-Traversal/</url>
    <content><![CDATA[<h1 id="LeetCode-145-Binary-Tree-Postorder-Traversal"><a href="#LeetCode-145-Binary-Tree-Postorder-Traversal" class="headerlink" title="LeetCode-145. Binary Tree Postorder Traversal"></a>LeetCode-145. Binary Tree Postorder Traversal</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, return the <em>postorder</em> traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree <code>&#123;1,#,2,3&#125;</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> &#x2F;</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>return <code>[3,2,1]</code>.</p>
<p><strong>Note:</strong> Recursive solution is trivial, could you do it iteratively?</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>递归法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        help(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        help(root-&gt;left, res);</span><br><span class="line">        help(root-&gt;right, res);</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>迭代法。</p>
<p>后序遍历顺序：左-&gt;右-&gt;根</p>
<p>我们每次都将节点加在res最前端，所以遍历顺序变为根-&gt;右-&gt;左。</p>
<p>因为先遍历根，所以和前序遍历很像。</p>
<p>去栈顶-&gt;加入res最前端-&gt;左节点入栈-&gt;右节点入栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">            st.push(root);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            TreeNode* n = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            res.insert(res.begin(), n-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(n-&gt;left) st.push(n-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(n-&gt;right) st.push(n-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
</search>
