<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Leetcode-71. Combination</title>
    <url>/2021/03/06/Leetcode-71-Combination/</url>
    <content><![CDATA[<h1 id="Leetcode-77-Combination"><a href="#Leetcode-77-Combination" class="headerlink" title="Leetcode-77. Combination"></a>Leetcode-77. Combination</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given two integers <em>n</em> and <em>k</em>, return all possible combinations of <em>k</em> numbers out of 1 … <em>n</em>.</p>
<p>For example,<br>If <em>n</em> = 4 and <em>k</em> = 2, a solution is:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><img src="/Users/alice/Blog/blog/source/img/Leetcode-71.png" style="zoom:80%;" />





<p>Make use of DFS.  First, choose number in a specific layer, then step into the next layer to choose another number. If the size of Vector Out is k, then we get one combination. Once Out is k, return to the upper layer and try to choose another number. If the layer reaches the end, but Out is still smaller than k, then it can’t meets the requirements and is dropped out. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line">        </span><br><span class="line">        dsp(n, k, <span class="number">1</span>, out, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dsp</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> level, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; out, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(out.size() == k)&#123;</span><br><span class="line">            res.push_back(out); </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = level; i&lt;=n; i++)&#123;</span><br><span class="line">            out.push_back(i);</span><br><span class="line">            <span class="comment">//深度搜索，在out中加入下一个数字</span></span><br><span class="line">            dsp(n, k ,i+<span class="number">1</span>, out, res);</span><br><span class="line">        </span><br><span class="line">            out.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Backtracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-78 Subsets</title>
    <url>/2021/03/08/Leetcode-78-Subsets/</url>
    <content><![CDATA[<h1 id="Leetcode-78-Subsets"><a href="#Leetcode-78-Subsets" class="headerlink" title="Leetcode-78. Subsets"></a>Leetcode-78. Subsets</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a set of distinct integers, <em>S</em>, return all possible subsets.</p>
<p>Note:</p>
<ul>
<li>Elements in a subset must be in non-descending order.</li>
<li>The solution set must not contain duplicate subsets.</li>
</ul>
<p>For example,<br>If <em>S</em> = <code>[1,2,3]</code>, a solution is:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>DFS, similiar to 77. Combination</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>, res, out, nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> level, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; out, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        res.push_back(out);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = level; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            out.push_back(nums[i]);</span><br><span class="line">            dfs(i+<span class="number">1</span>, res, out, nums);</span><br><span class="line">            out.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>Add current number into the back of every existing element to form new elements in the 2D vector.</p>
<p>For example, res = [[], [1], [2], [1,2]], i = 3.</p>
<p>Then, we form [3], [1,3], [2,3], [1, 2, 3]by adding 3 into [], [1], [2], [1, 2]. </p>
<p>res = [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]].</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">//注意，此处为res(1)</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> size = res.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++)&#123;</span><br><span class="line">                res.push_back(res[j]);</span><br><span class="line">                res.back().push_back(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Backtracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-79. Word Search</title>
    <url>/2021/03/08/Leetcode-79-Word-Search/</url>
    <content><![CDATA[<h1 id="Leetode-79-Word-Search"><a href="#Leetode-79-Word-Search" class="headerlink" title="Leetode-79. Word Search"></a>Leetode-79. Word Search</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p>For example,<br>Given board =</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [&quot;ABCE&quot;],</span><br><span class="line">  [&quot;SFCS&quot;],</span><br><span class="line">  [&quot;ADEE&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>word = <code>&quot;ABCCED&quot;</code>, -&gt; returns <code>true</code>,<br>word = <code>&quot;SEE&quot;</code>, -&gt; returns <code>true</code>,<br>word = <code>&quot;ABCB&quot;</code>, -&gt; returns <code>false</code>.</p>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>Resurse the board to find the word’s firt matching letter. Once the correspond letter is found, use dfs algorithm to dfs the rest letters in the neighbourhood of the current letter.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i&lt;board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt;board[<span class="number">0</span>].size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, word, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   <span class="keyword">int</span> m = board.size();</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span> (index==word.size()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||i&gt;=m||j&gt;=n||board[i][j]!=word[index]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">char</span> t = board[i][j];</span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">        res = (dfs(board, word, i<span class="number">-1</span>, j, index+<span class="number">1</span>)||</span><br><span class="line">        dfs(board, word, i, j<span class="number">-1</span>, index+<span class="number">1</span>)||dfs(board, word, i+<span class="number">1</span>,j, index+<span class="number">1</span>)||dfs(board, word, i, j+<span class="number">1</span>, index+<span class="number">1</span>)) ;</span><br><span class="line">        board[i][j] = t;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Backtracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-80. Remove Dupilicateds from Sorted Array</title>
    <url>/2021/03/08/Leetcode-80-Remove-Dupilicateds-from-Sorted-Array/</url>
    <content><![CDATA[<h1 id="Leetcode-80-Remove-Dupilicateds-from-Sorted-Array"><a href="#Leetcode-80-Remove-Dupilicateds-from-Sorted-Array" class="headerlink" title="Leetcode-80. Remove Dupilicateds from Sorted Array ||"></a>Leetcode-80. Remove Dupilicateds from Sorted Array ||</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a> such that duplicates appeared at most <em>twice</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a> with O(1) extra memory.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [1,1,1,2,2,3],</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [0,0,1,1,1,1,2,3,3],</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>Use variable gap to represent the number of nums that appeared more than twice and should be deleted. The current num should be moved left for gap position and the final Array Size equals original size minus gap.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> gap = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> prev = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums.size();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == prev) count++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">                prev = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">2</span>) gap++;</span><br><span class="line">            </span><br><span class="line">            nums[i-gap] = nums[i];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums.size() - gap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Array</category>
        <category>Two Pointers</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-81. Search in Rotated Sorted Array ||</title>
    <url>/2021/03/09/Leetcode-81-Search-in-Rotated-Sorted-Array/</url>
    <content><![CDATA[<h1 id="Leetcode-81-Search-in-Rotated-Sorted-Array"><a href="#Leetcode-81-Search-in-Rotated-Sorted-Array" class="headerlink" title="Leetcode-81. Search in Rotated Sorted Array ||"></a>Leetcode-81. Search in Rotated Sorted Array ||</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>[0,0,1,2,2,5,6]</code> might become <code>[2,5,6,0,0,1,2]</code>).</p>
<p>You are given a target value to search. If found in the array return <code>true</code>, otherwise return <code>false</code>.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>Follow up:</p>
<ul>
<li>This is a follow up problem to <a href="https://leetcode.com/problems/search-in-rotated-sorted-array/description/">Search in Rotated Sorted Array</a>, where <code>nums</code> may contain duplicates.</li>
<li>Would this affect the run-time complexity? How and why?</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>It is similar to Leetcode 33., but since there are same numbers in the array, the case that nums[mid]==nums[l] needs to be taken into consideration.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = nums.size()<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target == nums[mid]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//nums[l]&lt;nums[mid]表示mid左边数组有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[l] &lt; nums[mid])&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[l]&lt;=target&amp;&amp;target&lt;nums[mid])&#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;                </span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//nums[mid]&lt;nums[l]表示mid右边数组有序</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;nums[l])&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid]&lt;target&amp;&amp;target&lt;=nums[r])&#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    r = mid<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//nums[mid]==nums[l]时， 例如[1,1,3,1],[1,3,1，1，1]的情况下不确定哪边有序，target 3 可能在mid左边也可能在右边，对l++</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                l++;   </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Binary Search</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 82. Remove Duplicates from Sorted List ||</title>
    <url>/2021/03/09/Leetcode-82-Remove-Duplicates-from-Sorted-List/</url>
    <content><![CDATA[<h1 id="Leetcode-82-Remove-Duplicates-from-Sorted-List"><a href="#Leetcode-82-Remove-Duplicates-from-Sorted-List" class="headerlink" title="Leetcode 82. Remove Duplicates from Sorted List ||"></a>Leetcode 82. Remove Duplicates from Sorted List ||</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <em>distinct</em> numbers from the original list.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class="line">Output: 1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;1-&gt;2-&gt;3</span><br><span class="line">Output: 2-&gt;3</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在head前再加一个节点dumpy，在head就是重复值的情况下，可以简化删除head节点的过程</span></span><br><span class="line">        <span class="keyword">if</span>(!head||!head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *dumpy = <span class="keyword">new</span> ListNode();</span><br><span class="line">        dumpy-&gt;next = head;</span><br><span class="line">        ListNode *prev = dumpy;</span><br><span class="line">        ListNode *current = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(prev-&gt;next)&#123;</span><br><span class="line">            current = prev-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(current-&gt;next &amp;&amp; current-&gt;val == current-&gt;next-&gt;val)&#123;</span><br><span class="line">                current = current-&gt;next;   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(prev-&gt;next != current) prev-&gt;next = current-&gt;next;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                prev = prev-&gt;next;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dumpy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Linked List</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-83. Remove Duplicates from Sorted List</title>
    <url>/2021/03/11/Leetcode-83-Remove-Duplicates-from-Sorted-List/</url>
    <content><![CDATA[<h1 id="Leetcode-83-Remove-Duplicates-from-Sorted-List"><a href="#Leetcode-83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="Leetcode-83. Remove Duplicates from Sorted List"></a>Leetcode-83. Remove Duplicates from Sorted List</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2</span><br><span class="line">Output: 1-&gt;2</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>Easy Method</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* current = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(current&amp;&amp;current-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current-&gt;val == current-&gt;next-&gt;val)&#123;</span><br><span class="line">                current-&gt;next = current-&gt;next-&gt;next;   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                current = current-&gt;next;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>Recursion Method</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        head-&gt;next = deleteDuplicates(head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> (head-&gt;val == head-&gt;next-&gt;val) ? head-&gt;next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Linked List</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-86. Partition List</title>
    <url>/2021/03/11/Leetcode-86-Partition-List/</url>
    <content><![CDATA[<h1 id="Leetcode-86-Partition-List"><a href="#Leetcode-86-Partition-List" class="headerlink" title="Leetcode-86. Partition List"></a>Leetcode-86. Partition List</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a linked list and a value <em>x</em>, partition it such that all nodes less than <em>x</em> come before nodes greater than or equal to <em>x</em>.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p>For example,<br>Given <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2</code> and <em>x</em> = 3,<br>return <code>1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</code>.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>Create a new list with the Nodes less than x in the original list. At the same time delete the Nodes less than x in the original list. Finally, combine the two list to form the result.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;        </span><br><span class="line">        </span><br><span class="line">        ListNode* dumpy_s = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* current_s = dumpy_s;</span><br><span class="line">        ListNode* dumpy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        dumpy-&gt;next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode* current = head;</span><br><span class="line">        ListNode* prev = dumpy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(current)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current-&gt;val&lt;x)&#123;</span><br><span class="line">                current_s-&gt;next = current;</span><br><span class="line">                current_s = current_s-&gt;next;</span><br><span class="line">                </span><br><span class="line">                prev-&gt;next = current-&gt;next;</span><br><span class="line">                </span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">                </span><br><span class="line">                current_s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">                prev = prev-&gt;next;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        current_s-&gt;next = dumpy-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dumpy_s-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Linked List</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-88. Merge Sorted Array</title>
    <url>/2021/03/13/Leetcode-88-Merge-Sorted-Array/</url>
    <content><![CDATA[<h1 id="Leetcode-88-Merge-Sorted-Array"><a href="#Leetcode-88-Merge-Sorted-Array" class="headerlink" title="Leetcode-88. Merge Sorted Array"></a>Leetcode-88. Merge Sorted Array</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>
<p>Note:</p>
<ul>
<li>The number of elements initialized in <em>nums1</em>and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</li>
<li>You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>.</li>
</ul>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3</span><br><span class="line">nums2 &#x3D; [2,5,6],       n &#x3D; 3</span><br><span class="line"></span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = m<span class="number">-1</span>, j = n<span class="number">-1</span>, k = m+n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                nums1[k--] = (i&gt;=<span class="number">0</span>&amp;&amp;nums1[i]&gt;=nums2[j]) ? nums1[i--] : nums2[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Two Pointers</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-90. Subsets||</title>
    <url>/2021/03/15/Leetcode-90-Subsets/</url>
    <content><![CDATA[<h1 id="Leetcode-90-Subsets"><a href="#Leetcode-90-Subsets" class="headerlink" title="Leetcode-90. Subsets ||"></a>Leetcode-90. Subsets ||</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a collection of integers that might contain duplicates, <em>S</em>, return all possible subsets.</p>
<p>Note:</p>
<ul>
<li>Elements in a subset must be in non-descending order.</li>
<li>The solution set must not contain duplicate subsets.</li>
</ul>
<p>For example,<br>If <em>S</em> = <code>[1,2,2]</code>, a solution is:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>Similiar to 78.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line">        </span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> prev_size = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> prev_num = *nums.begin()<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> start;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != prev_num)&#123;</span><br><span class="line">                start = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                start = prev_size;  </span><br><span class="line">            &#125;</span><br><span class="line">            prev_size = res.size();</span><br><span class="line">            prev_num = nums[i];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> Size = res.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = start; j&lt;Size; j++)&#123;</span><br><span class="line">                res.push_back(res[j]);</span><br><span class="line">                res.back().push_back(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>Similiar to 78.</p>
<p>dfs method.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line">        </span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        dfs(nums, out, res, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; out, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        res.push_back(out);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = level; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            out.push_back(nums[i]);</span><br><span class="line">            dfs(nums, out, res, i+<span class="number">1</span>);</span><br><span class="line">            out.pop_back();</span><br><span class="line">            <span class="keyword">while</span>(i+<span class="number">1</span>&lt;nums.size() &amp;&amp; nums[i] == nums[i+<span class="number">1</span>]) i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Backtracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-91. Decode Ways</title>
    <url>/2021/03/20/Leetcode-91-Decode-Ways/</url>
    <content><![CDATA[<h1 id="Leetcode-91-Decode-Ways"><a href="#Leetcode-91-Decode-Ways" class="headerlink" title="Leetcode-91. Decode Ways"></a>Leetcode-91. Decode Ways</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>A message containing letters from <code>A-Z</code> is being encoded to numbers using the following mapping:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;A&#39; -&gt; 1</span><br><span class="line">&#39;B&#39; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; 26</span><br></pre></td></tr></table></figure>

<p>Given a non-empty string containing only digits, determine the total number of ways to decode it.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;12&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: It could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;226&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: It could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6)</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>It’s a dynamic programming problem. </p>
<p>if s[i] != ‘0’ and ‘10’&lt;=s[i-1]s[i]&lt;=’26’ : opt[i] = opt[i-1] + opt[i-2];</p>
<p>if s[i] != ‘0’ and (s[i-1]s[i]&lt;’10’ || s[i-1]s[i]&gt;’26’) opt[i] = opt[i-1];</p>
<p>if s[i] == ‘0’ and ‘10’&lt;=s[i-1]s[i]&lt;=’26’: opt[i] = opt[i-2]</p>
<p>else opt[i] = 0;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s.empty() || s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">opt</span><span class="params">(s.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        opt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        opt[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; opt.size(); i++)&#123;</span><br><span class="line">            <span class="comment">//注意此处，判定当前元素是否为0，若为0， 则不能加opt[i-1]，因为0不能映射</span></span><br><span class="line">            opt[i] = (s[i<span class="number">-1</span>] == <span class="string">&#x27;0&#x27;</span>) ? <span class="number">0</span> : opt[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span> &amp;&amp; (s[i<span class="number">-2</span>] == <span class="string">&#x27;1&#x27;</span> || (s[i<span class="number">-2</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s[i<span class="number">-1</span>] &lt;= <span class="string">&#x27;6&#x27;</span>)))</span><br><span class="line">                opt[i] += opt[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> opt.back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-92. Reverse Linked List</title>
    <url>/2021/03/23/Leetcode-92-Reverse-Linked-List/</url>
    <content><![CDATA[<h2 id="Leetcode-92-Reverse-Linked-List"><a href="#Leetcode-92-Reverse-Linked-List" class="headerlink" title="Leetcode-92. Reverse Linked List ||"></a>Leetcode-92. Reverse Linked List ||</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in one-pass.</p>
<p>Note: 1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m &#x3D; 2, n &#x3D; 4</span><br><span class="line">Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* prev = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= left<span class="number">-1</span>; i++) prev = prev-&gt;next;</span><br><span class="line">        ListNode* current = prev-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left<span class="number">-1</span>; i &lt;= right<span class="number">-2</span>; i++)&#123;</span><br><span class="line">            ListNode* t = current-&gt;next;</span><br><span class="line">            current-&gt;next = t-&gt;next;</span><br><span class="line">            t-&gt;next = prev-&gt;next;</span><br><span class="line">            prev-&gt;next = t;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Linked List</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-93. Restore IP Addresses</title>
    <url>/2021/03/23/Leetcode-93-Restore-IP-Addresses/</url>
    <content><![CDATA[<h2 id="Leetcode-93-Restore-IP-Addresses"><a href="#Leetcode-93-Restore-IP-Addresses" class="headerlink" title="Leetcode-93. Restore IP Addresses"></a>Leetcode-93. Restore IP Addresses</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;25525511135&quot;</span><br><span class="line">Output: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure>



<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>It is a backtracting problem.</p>
<p>When comparing a string number and 255, we can use atoi(s.c_str()). SInce atoi() is a C function, string s has to be turned into C format to use this function. </p>
<p>s.substr(pos, n) is used to find substring of s, pos is the start index of the substring and n is the length of the substring.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">restoreIpAddresses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        helper(s, <span class="number">0</span>, <span class="string">&quot;&quot;</span>, res);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n, <span class="built_in">string</span> out, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.empty()) res.push_back(out);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.size() &lt; k) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> val = atoi(s.substr(<span class="number">0</span>, k).c_str());</span><br><span class="line">                <span class="keyword">if</span> (val &gt; <span class="number">255</span> || k != <span class="built_in">std</span>::to_string(val).size()) <span class="keyword">continue</span>;</span><br><span class="line">                helper(s.substr(k), n + <span class="number">1</span>, out + s.substr(<span class="number">0</span>, k) + (n == <span class="number">3</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;.&quot;</span>), res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Backtracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-95. Unique Binary Search Trees ||</title>
    <url>/2021/03/24/LeetCode-95-Unique-Binary-Search-Trees-%7C%7C/</url>
    <content><![CDATA[<h2 id="LeetCode-95-Unique-Binary-Search-Trees"><a href="#LeetCode-95-Unique-Binary-Search-Trees" class="headerlink" title="LeetCode-95. Unique Binary Search Trees ||"></a>LeetCode-95. Unique Binary Search Trees ||</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given an integer <em>n</em>, generate all structurally unique BST’s (binary search trees) that store values 1 … <em>n</em>.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">Explanation:</span><br><span class="line">The above output corresponds to the 5 unique BST&#39;s shown below:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>



<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>在一定的range[1,n]中，若选择i作为根结点，则1～i-1构成左子树，i+1~n构成右子树。用递归获取左右子树可能的根结点序列，将左右子树与根结点i连接。每一层递归像上一层返回一个vector，饱含所有可能的根结点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> recursion(<span class="number">1</span>,n);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">//此句必须加上，否则返回的res会为[] </span></span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; left = recursion(start, i<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; right = recursion(i+<span class="number">1</span>, end);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> m:left)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> n:right)&#123;</span><br><span class="line">                   TreeNode *root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root-&gt;left = m;</span><br><span class="line">                    root-&gt;right = n;</span><br><span class="line">                    res.push_back(root);</span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Dynamic Programming</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-96. Unique Binary Search Trees</title>
    <url>/2021/03/24/Leetcode-96-Unique-Binary-Search-Trees/</url>
    <content><![CDATA[<h1 id="Leetcode-96-Unique-Binary-Search-Trees"><a href="#Leetcode-96-Unique-Binary-Search-Trees" class="headerlink" title="Leetcode-96. Unique Binary Search Trees"></a>Leetcode-96. Unique Binary Search Trees</h1><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given <em>n</em>, how many structurally unique BST’s (binary search trees) that store values 1 … <em>n</em>?</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">Given n &#x3D; 3, there are a total of 5 unique BST&#39;s:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>



<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h4><p>类似于95题的递归思路，当前递归层的组合数量 += 左子树数量 * 右子树数量。</p>
<p>并用map容器保存节点个数为i的树的种类个数，减少重复递归。因为若树的节点数确定，则其能够组合成的二叉搜索树种类数量也可确定，所以若已计算过当前节点数能组成的搜索树数量，则不必反复计算。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dic;</span><br><span class="line">        <span class="keyword">return</span> recursion(<span class="number">1</span>, n, dic);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; dic)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> length = end - start + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dic.count(length))</span><br><span class="line">            <span class="keyword">return</span> dic[length];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i&lt;=end; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = recursion(start, i<span class="number">-1</span>, dic);</span><br><span class="line">            <span class="keyword">int</span> right = recursion(i+<span class="number">1</span>, end, dic);</span><br><span class="line">            num = num + left*right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dic[length] = num;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h4><p>实际上是个动态规划法的数列计算。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=i; j++)&#123;</span><br><span class="line">                dp[i] += dp[j<span class="number">-1</span>] * dp[i-j];   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Dynamic Programming</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Essential C+ + 笔记</title>
    <url>/2021/03/24/Essential-C-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>Essential C+ + 笔记</p>
<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h4 id="1-include，-using-namespace"><a href="#1-include，-using-namespace" class="headerlink" title="1. include， using namespace"></a>1. include， using namespace</h4><p><code>#include &lt;iostream&gt;</code>——C+ +标准的输入输出库，包含了相关的整套class，用以对终端和文件的输入输出<br><code>#include &lt;string&gt; </code>——包含string类型<br><code>using namespace std;</code>——实用std命名空间。std是标准库所驻的命名空间。命名空间的作用是将库名称封装起来，避免和应用程序发生命名冲突。</p>
<h4 id="2-cout，-cin"><a href="#2-cout，-cin" class="headerlink" title="2. cout， cin"></a>2. cout， cin</h4><p>cout将信息写到用户终端中，运算符&lt;&lt;将数据定向到cout<br><code>cout  &lt;&lt;  “please enter your name”</code><br>cin读取终端上的输入内容，通过&gt;&gt;将输入内容定向到具有适合类型的对象上。<br><code>cin &gt;&gt; user_name</code></p>
<h4 id="3-const关键字"><a href="#3-const关键字" class="headerlink" title="3. const关键字"></a>3. const关键字</h4><p>用const定义的对象，在获得初值后，无法再进行修改，否则会报错。<br>以下几种写法错误：<br>（1）<br><code>const int a; //没有初始化</code><br>（2）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span>; <span class="comment">//修改了const对象</span></span><br></pre></td></tr></table></figure>



<h3 id="1-5-如何运用Array和Vector"><a href="#1-5-如何运用Array和Vector" class="headerlink" title="1.5 如何运用Array和Vector"></a>1.5 如何运用Array和Vector</h3><p>1、Array定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> seq_size = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">int</span> pell_seq[seq_size];定义<span class="built_in">array</span>的时候要指出尺度大小（不指出则根据初值的数量，自行计算<span class="built_in">array</span>的大小），并且此大小需为一个常量表达式，<span class="keyword">const</span>可以，但是变量不行。</span><br></pre></td></tr></table></figure>

<p>2、Vector定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pell_seq</span><span class="params">(seq_size)</span></span>;<span class="built_in">vector</span>可以用变量赋值。</span><br></pre></td></tr></table></figure>

<p>3、Array赋值</p>
<p>int a[] = {1,2,3,4};</p>
<p>4、Vector赋值<br>法一：冗长写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vecctor&lt;<span class="keyword">int</span>&gt; a&#123;<span class="number">10</span>&#125;;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>法二：利用一个已经初始化的array赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> value&#123;<span class="number">6</span>&#125; = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a&#123;value, value+<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>5、遍历vector<br>vector.size()会返回vector的大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;a.size(); i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;‘ ‘;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-6-指针"><a href="#1-6-指针" class="headerlink" title="1.6 指针"></a>1.6 指针</h3><p>1、指针必须要初始化。如果指针定位到某个对象，则对指针进行提领（dereference）操作没有错误；如果指针不指向对象，则进行dereference会导致未知执行结果。<br>若指针不指向任何对象，则赋地址值为0，成为null指针:<br>int *pi = 0;<br>一般为了防止对null进行提领，则提领前检测地址是否为0:</p>
<p>if (pi &amp;&amp; *pi !=1)</p>
<p>2、一些容易混淆的表达<br>指针的表达形式：<br>type_of_object_pointed_to * name_of_pointer_object<br>例如：<br>vector<int> *pv = 0;<br>pv指向的对象为vector<int>类型</p>
<p>例2:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *seq_addrs[seq_cnt] = &#123;&amp;fibonacci, &amp;lucas, &amp;pell&#125;;</span><br><span class="line"><span class="comment">//seq_addrs为一个数组，数组元素类型为vector&lt;int&gt; *；称seq_addrs为指针数组</span></span><br></pre></td></tr></table></figure>



<p>3、指针使用箭头-&gt;作为成员选择运算符<br>例如：pv-&gt;empty();</p>
<p>4、指针数组vs数组指针</p>
<p>指针数组：多个指针组成的数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * p[<span class="number">10</span>]</span><br><span class="line"><span class="comment">//[]优先级高于*，故而p先与[]结合，组成一个数组，数组的元素类型为int *</span></span><br></pre></td></tr></table></figure>

<p>数组指针：一个指向数组的指针<br>int (*p)[10]<br>实质上，这里根据语义应该写成<code>int (*)[10] p </code>，代表p为<code>int(*)[10]</code>类型的变量，但是不是这么规定的orz。<br>对数组指针赋值的时候：<br>(img)<br>&amp;a与a实际上值一致，但&amp;a为整个数组首地址，a为数组首元素的首地址；而<code>char (*p)[5]</code>定义的是指向数组的指针，所以此处用p3赋值方式更好。</p>
<p>(img)</p>
<h3 id="1-7-文件的读写"><a href="#1-7-文件的读写" class="headerlink" title="1.7 文件的读写"></a>1.7 文件的读写</h3><p>#include <fstream><br>ofstream、ifstream、fstream</p>
<h2 id="第二章-面向过程的编程风格"><a href="#第二章-面向过程的编程风格" class="headerlink" title="第二章 面向过程的编程风格"></a>第二章 面向过程的编程风格</h2><h3 id="2-2-调用函数"><a href="#2-2-调用函数" class="headerlink" title="2.2 调用函数"></a>2.2 调用函数</h3><p>（一）传入reference或者指针<br>（1）错误写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> val1, <span class="keyword">int</span> val2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = val1;</span><br><span class="line">        val1 = val2;</span><br><span class="line">        val2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2)使用reference</p>
<p>用以下例子理解reference</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *pi = &amp;ival;   <span class="comment">//指针pi指向ival这个对象，pi的值为ival的地址</span></span><br><span class="line"><span class="keyword">int</span> &amp;rval = ival;  <span class="comment">//reference，rval代表ival这个整型对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> jval = <span class="number">4096</span>;</span><br><span class="line">rval = jval;</span><br></pre></td></tr></table></figure>

<p><b>上述语句时将jval的值赋给了rval所代表的ival。无法令rval转而代表jval！！！C+  +不允许改变reference 所代表的对象！！！</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pi = &amp;rval</span><br></pre></td></tr></table></figure>

<p><b>上述语句代表将ival的值赋给pi</b></p>
<p><b>所以我们可以发现，对reference的所有操作方式，和对reference所代表对象的操作方式一模一样。即上述中对rval操作的写法，与直接对ival操作的写法一致。</b></p>
<p><b>但是，reference的不同点在于，以by reference方式将对象作为函数参数传入时，对象本身不会复制出另一份，复制的是对象的地址。函数中对对象的任何操作，相当于对传入对象本身进行简介操作。</b></p>
<p>用reference进行swap的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;val1, <span class="keyword">int</span> &amp;val2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = val1;</span><br><span class="line">        val1 = val2;</span><br><span class="line">        val2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        swap(val1,val2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用swap也可以降低复制大型对象的额外负担，因为他只复制地址。例如可以将const vector<int> &amp;vec作为形参。</p>
<p>(3)使用指针<br>使用指针效果和reference相同，传递的是对象地址。<br><b>使用指针一定要先确认指针是否为空指针！！！</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> * val1, <span class="keyword">int</span> *val2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!val1 || !val2)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; point is <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        temp = *val1;</span><br><span class="line">        *val1 = *val2;</span><br><span class="line">        *val2 = tem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        swap(&amp;val1, &amp;val2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（二）作用域<br>local scope：对象仅在local scope之内可见，在local scope之外不可见，如函数内的对象</p>
<p>file scope：对象若拥有file scope，则从声明点至文件末尾都可见。file scope内的对象也具备static extent（？？？static变量？？？？），从main()开始执行之前便分配好，一直存在至程序结束。</p>
<p>内置类型对象：定义在file scope之内，必定被初始化为0；定义在local scope之内，除非指定初值，否则不会初始化。</p>
<p>（三）动态内存管理<br>dynamic extent（动态范围）——由程序员自行管理，利用new和delete函数分配和释放，内存由空闲空间分配而来，成为heap memory（堆内存）。</p>
<p>new和delete应成对使用，否则heap分配的对象永远不会释放，导致内存泄漏（memeory leak）。<br>(1) new函数的使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Type;</span><br><span class="line"><span class="keyword">new</span> Type(initial value);</span><br></pre></td></tr></table></figure>

<p>可以声明initial value也可以不声明<br>例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1, p2;</span><br><span class="line">p1 = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">//由heap分配一个类型为int的对象，将地址赋给p1。不赋值直接输出*p1，会是随机数字（？）</span></span><br><span class="line">p2 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2014</span>); <span class="comment">//由heap分配一个类型为int的对象，初值设为2014，将地址赋给p2</span></span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">24</span>];</span><br></pre></td></tr></table></figure>


<p>分配一个有24个整数组成的数组，将第一个元素的地址赋给p。数组中的元素都没有进行初始化。</p>
<p>（2）delete函数的使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;  <span class="comment">//释放值</span></span><br><span class="line"><span class="keyword">delete</span> [] p; <span class="comment">//释放数组</span></span><br></pre></td></tr></table></figure>



<h3 id="2-3-提供默认参数值"><a href="#2-3-提供默认参数值" class="headerlink" title="2.3  提供默认参数值"></a>2.3  提供默认参数值</h3><p>​    传参的时候，可以给一些形参赋予默认值，调用函数的时候，如果不指明这些参数的值，则这些值用默认值初始化。<br>（1）默认值的解析从最右开始，若为某个参数提供了默认值，则参数右侧的所有参数都必须有默认值<br>（2）默认值只能指定一次。可以在函数声明时，也可以在函数定义处；不能够在两个地方都指定。</p>
<h3 id="2-4使用局部静态对象"><a href="#2-4使用局部静态对象" class="headerlink" title="2.4使用局部静态对象"></a>2.4使用局部静态对象</h3><p>在局部作用域内部可见，外部不可见，且持续存在。<br>例:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a; <span class="comment">// 错误，函数外部a不可见</span></span><br><span class="line">        display();  <span class="comment">// 1</span></span><br><span class="line">        display();  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>C+ + string怎么用？？？</p>
<h3 id="2-5-声明inline函数"><a href="#2-5-声明inline函数" class="headerlink" title="2.5 声明inline函数"></a>2.5 声明inline函数</h3><p>没看懂，好像没什么用？？可以节约函数调用时间？</p>
<h3 id="2-6-2-7-重载函数-vs-模版函数"><a href="#2-6-2-7-重载函数-vs-模版函数" class="headerlink" title="2.6-2.7 重载函数 vs 模版函数"></a>2.6-2.7 重载函数 vs 模版函数</h3><p>（1）重载函数<br>多个不同的函数使用同样的函数名，可以接收不同的参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_message</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displya_message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">int</span>)</span></span>;编译器会将调用者提供的参数与每个重载函数的参数对比，找出最合适的一个调用。</span><br></pre></td></tr></table></figure>

<p>（2）模版函数<br>函数主体不变，仅仅改变用到的数据类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;msg, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;elemType&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">        …</span><br><span class="line">        elemType t = vec[ix];</span><br><span class="line"><span class="comment">//使用elemType代表函数类型</span></span><br></pre></td></tr></table></figure>



<h3 id="2-8函数指针"><a href="#2-8函数指针" class="headerlink" title="2.8函数指针"></a>2.8函数指针</h3><p><b>函数指针：指向函数的指针</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; * (*seq_ptr)(<span class="keyword">int</span>); <span class="comment">//指针seq_ptr指向一个函数，此函数参数为int，返回值为const vector&lt;int&gt; *类型</span></span><br><span class="line">seq_ptr = pell_seq;  <span class="comment">//将函数pell_seq()的地址赋给pell_seq</span></span><br><span class="line">seq_ptr(<span class="number">1</span>); <span class="comment">//函数指针和一般函数调用方法相同</span></span><br></pre></td></tr></table></figure>



<h3 id="2-9-设定头文件"><a href="#2-9-设定头文件" class="headerlink" title="2.9 设定头文件"></a>2.9 设定头文件</h3><p>（1）函数声明放在头文件中，定义放在程序文件中；因为定义只能有一份，声明可以有多份。<br>（2）例外：inline函数的定义放在头文件里；const对象的定义可以放在头文件中。<br>（3）对象的定义也必须放在程序文件中，extern可以将定义转化为声明（？？）<br>（4）系统头文件用&lt;&gt;括起，自己写的头文件用””括起</p>
<h2 id="第三章-泛型编程风格"><a href="#第三章-泛型编程风格" class="headerlink" title="第三章 泛型编程风格"></a>第三章 泛型编程风格</h2><p>STL：Standard Template Library，组成：（1）容器，vector、list、set、map等类  （2）操作容器的泛型算法，如find()、replace()、merge()。</p>
<h4 id="泛型算法理解：泛型算法的函数可以接受任意类型的容器（vector、list、set、map等），利用一对iterator——first和last来遍历容器中的元素。"><a href="#泛型算法理解：泛型算法的函数可以接受任意类型的容器（vector、list、set、map等），利用一对iterator——first和last来遍历容器中的元素。" class="headerlink" title="泛型算法理解：泛型算法的函数可以接受任意类型的容器（vector、list、set、map等），利用一对iterator——first和last来遍历容器中的元素。"></a>泛型算法理解：泛型算法的函数可以接受任意类型的容器（vector、list、set、map等），利用一对iterator——first和last来遍历容器中的元素。</h4><h3 id="3-1-指针的算数运算"><a href="#3-1-指针的算数运算" class="headerlink" title="3.1 指针的算数运算"></a>3.1 指针的算数运算</h3><p>1、数组被传送给函数，或者由函数返回，都是仅传递第一个元素的地址<br>2、访问数组下标，如array[2]，实际上相当于*(array+2)。</p>
<p><b>3、对于指针运算，指针会把指针所指类型的大小考虑进去。例如，int型array的第一个元素的地址为100，则array+2代表的其实是100+2*4（假设int占4字节）。</b></p>
<p><b>4、begin()代表返回容器第一个元素的地址，若容器为空，则返回0。end()返回0或者容器最后元素的下一个地址。</b></p>
<h3 id="3-2-Iterator（泛型指针）"><a href="#3-2-Iterator（泛型指针）" class="headerlink" title="3.2 Iterator（泛型指针）"></a>3.2 Iterator（泛型指针）</h3><p>1、对于指针操作，vecotr、array等有序元素可以直接通过pointer++的方法遍历下一个元素，但对于list容器，元素不是保存在连续的内存空间里，如果要实现泛型算法，则需要对指针操作进行抽象，可以使用iterator泛型指针。<b>iterator的值其实应该是地址？？和普通指针一样？？？只是指针运算进行了抽象封装？？？</b></p>
<p>2、iterator用法：container.begin()和container.end()都会返回iterator。iterator中++、=、*都进行了重定义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义iterator</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator iter = vec.begin();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator end_it = vec.end();</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(; iter!=end_it; ++iter)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*iter&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>3、泛型算法find()实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IteratorType, <span class="keyword">typename</span> elemType&gt;</span><br><span class="line"><span class="function">IteratorType <span class="title">find</span><span class="params">(IteratorType first, IteratorType last, <span class="keyword">const</span> elemType &amp;value)</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(:first != last; ++first)</span><br><span class="line">    <span class="keyword">if</span>(value == *first) <span class="keyword">return</span> first;</span><br><span class="line">  <span class="keyword">return</span> last;</span><br><span class="line">  <span class="comment">//这个函数返回的实际是地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>find()函数调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> ia[size] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">//初始化vector和list</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(ia, ia+size)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ilist</span><span class="params">(ia, ia+size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//array调用find()</span></span><br><span class="line">find(ia, ia+size, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//vector调用find()</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">it = find(ivec.begin(), ivec.end(), <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(it != vec.end())</span><br><span class="line">      <span class="comment">//找到了</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//list调用find()</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">iter = find(ilist.begin(), ilist.end(), <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(iter != ilist.end())</span><br><span class="line">      <span class="comment">//找到了</span></span><br></pre></td></tr></table></figure>



<h3 id="3-4-使用顺序性容器"><a href="#3-4-使用顺序性容器" class="headerlink" title="3.4 使用顺序性容器"></a>3.4 使用顺序性容器</h3><p>顺序性容器：vector、deque、list</p>
<p>vector、deque在连续内存空间存储，vector和deque都可使用下标取出元素。vector容易对末尾元素进行删除插入操作，deque容易对首元素进行删除插入操作。</p>
<p>list是双向链表，包含value、back、front指针，容易进行任意位置的元素插入或删除。</p>
<p>1、定义顺序性容器对象的方式</p>
<p>（1）产生空容器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist;</span><br></pre></td></tr></table></figure>

<p>（2）产生特定大小的容器，元素默认初始化为初值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ilist</span><span class="params">(<span class="number">1024</span>)</span></span>; <span class="comment">//1024大小的list，初值为0</span></span><br></pre></td></tr></table></figure>

<p>（3）特定大小，指定初值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; <span class="title">slist</span><span class="params">(<span class="number">16</span>, <span class="string">&quot;unassinged&quot;</span>)</span></span>; <span class="comment">//16大小的list，初值为&quot;unassinged&quot;</span></span><br></pre></td></tr></table></figure>

<p>（4）通过iterator和已定义数组产生容器，iterator用来给出初值的地址范围。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ilist</span><span class="params">(ia, ia+<span class="number">3</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>（5）复制已有容器给空容器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; <span class="title">slist2</span><span class="params">(slist)</span></span>; <span class="comment">//利用已有容器slist初始化空容器slist2</span></span><br></pre></td></tr></table></figure>

<p>2、push_back()，pop_back()两个函数list、vector、deque通用。</p>
<p>list和deque能够对首元素进行插入删除，利用pop_front()，push_front()函数</p>
<p>3、iterator insert(iterator position, elemType value)，在position前面插入value，返回插入元素的iterator。</p>
<p>4、iterator类型的指针只能进行++运算，没有+2，+3…之类的运算</p>
<h3 id="3-5-使用泛型算法"><a href="#3-5-使用泛型算法" class="headerlink" title="3.5 使用泛型算法"></a>3.5 使用泛型算法</h3><p>find()、binary_search()、count()、search()、sort()、copy()等。基本上输入参数都包括container.begin()，container.end()两个iterator指针。</p>
<h3 id="3-6-如何设计一个泛型算法"><a href="#3-6-如何设计一个泛型算法" class="headerlink" title="3.6 如何设计一个泛型算法"></a>3.6 如何设计一个泛型算法</h3><p>如何设计一个泛化的filter函数，令其与容器类型、元素类型、以及filter方法均无关。</p>
<p><b>方法一 使用函数指针，泛化函数对filter方法的依赖</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义filter方法函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">less_than</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x1 &lt; x2 ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义filter，利用指针函数bool(*pred)(int, int)传入方法函数</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">filter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> filter_value, <span class="keyword">bool</span>(*pred)(<span class="keyword">int</span>, <span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pred(vec[i], filter_value))</span><br><span class="line">            result.push_back(vec[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">32</span>,<span class="number">45</span>,<span class="number">1</span>,<span class="number">67</span> &#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(a, a + <span class="number">6</span>)</span></span>;</span><br><span class="line">  <span class="comment">//调用，指针函数直接传入函数名即可</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = filter(ivec, <span class="number">10</span>, less_than);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; result[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>方法二 利用find函数，消除for循环，并且保证每个元素只遍历一次的方法</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">filter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> filter_value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.begin();</span><br><span class="line">    <span class="comment">//令find函数每次从iter指向的地址开始找，若找到，则会返回相应元素地址。若没有便利完vector，则iter++</span></span><br><span class="line">    <span class="keyword">while</span> ((iter = find(iter, vec.end(), filter_value)) !=vec.end())&#123;</span><br><span class="line">        count++;</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123; <span class="number">10</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">45</span>,<span class="number">1</span>,<span class="number">67</span> &#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(a, a + <span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="comment">//找ivec中有几个10</span></span><br><span class="line">    <span class="keyword">int</span> count = filter(ivec, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><b>方法三 用function object替代自定义函数</b></p>
<p>​    相比于在filter中传入函数指针，传递function object效率更高。可以令call运算符成为inline，从而消除”通过函数指针来调用函数“时需要付出的额外代价。</p>
<p>​    function object是某种class的实例对象，因为对function call运算符做了重载操作，因而可以当成一般函数使用。</p>
<p>（1）使用function object需要饱含#include <functional>头文件</p>
<p>（2）常见function object及使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//function object示例</span></span><br><span class="line">greater&lt;<span class="keyword">int</span>&gt;(), less&lt;<span class="keyword">int</span>&gt;()</span><br><span class="line"><span class="comment">//使用例子,降序排序</span></span><br><span class="line">sort(vec.begin(), vec.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br></pre></td></tr></table></figure>

<p>（3）因为less<int>(), greater<int>()，等function object接受二元输入，因此需要将其转化为一元运算符。</p>
<p>需要使用<b>binder adapter</b>。</p>
<p>binder1st将指定值绑定至第一操作数。</p>
<p>binder2nd将指定值绑定至第二操作数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binder1st(less&lt;int&gt;(), value);</span><br><span class="line">binder2nd(greater&lt;int&gt;(), value);</span><br></pre></td></tr></table></figure>

<p>（4）使用function object编写泛型函数filter()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> OutputIterator, <span class="keyword">typename</span> ElemType, <span class="keyword">typename</span> Comp&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">filter</span><span class="params">(InputIterator first, InputIterator last, OutputIterator at, <span class="keyword">const</span> ElemType &amp;val, Comp pred)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((first = find_if(first, last, bind2nd(pred, val))) != last) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        *at++ = *first++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> at;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123; <span class="number">10</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">45</span>,<span class="number">1</span>,<span class="number">67</span> &#125;;</span><br><span class="line">    <span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ilist</span><span class="params">(a, a + <span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">output</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">    filter(ilist.begin(), ilist.end(), output.begin(), value, greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; output.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; output[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><b>小练习</b></p>
<p>???没做出来，sort报错？？？</p>
<h3 id="3-7-使用Map"><a href="#3-7-使用Map" class="headerlink" title="3.7 使用Map"></a>3.7 使用Map</h3><p>map使用其实类似于python中的字典使用方式。</p>
<p>map被定义为一对（pair）数值，保存key和value。</p>
<p>1、map声明与定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义名为words的map</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; words;</span><br><span class="line">words[<span class="string">&quot;apple&quot;</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>2、查询某一key的value</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于map类型的变量words来说，words[&quot;apple&quot;]可以查看apple的value，若apple不在word的key中，则会创建一个value的key，其值为0</span></span><br><span class="line"></span><br><span class="line">words[<span class="string">&quot;apple&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>3、遍历map的元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it = words.begin();</span><br><span class="line"><span class="keyword">for</span>(:, it!=words.end(); ++it)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;key: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value: &quot;</span> &lt;&lt; it-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、查询map内是否存在某个key</p>
<p>(1)把key当作索引</p>
<p>但是这样若key不在map中，则会自动创建此key，令其value为0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!(count = words[<span class="string">&quot;apple&quot;</span>]))</span><br><span class="line">    <span class="comment">//&quot;apple&quot;不在key里</span></span><br></pre></td></tr></table></figure>

<p>(2)使用map的find()函数</p>
<p>find()若找到key，则会返回指向key/value pair的iterator；若不存在key，则返回end()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">it = words.find(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(it != words.end())</span><br><span class="line">  count = it-&gt;second;</span><br></pre></td></tr></table></figure>

<p>（3）使用map的count()函数</p>
<p>count()函数会返回特定项在map内的个数，任何key在map中只有一份，因此若有key，返回1，若无key，返回0。避免了直接使用words[key]，创造新key的情况。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(words.count(<span class="string">&quot;apple&quot;</span>))</span><br><span class="line">    count = words[<span class="string">&quot;apple&quot;</span>];</span><br></pre></td></tr></table></figure>



<h3 id="3-8-使用Set"><a href="#3-8-使用Set" class="headerlink" title="3.8 使用Set"></a>3.8 使用Set</h3><p>set可以看作是集合，又一群key组成，没有value。每个key在set中只能出现一次。</p>
<p>set会默认为其中的元素从小到大排序。</p>
<p>1、set初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">10</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">45</span>, <span class="number">1</span>, <span class="number">67</span>, <span class="number">45</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">iset</span><span class="params">(ia, ia+<span class="number">7</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = iset.begin();</span><br><span class="line"><span class="keyword">for</span>(; it != iset.end(); it++)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出为1 2 10 45 67</span></span><br></pre></td></tr></table></figure>

<p>2、set中加入值</p>
<p>使用insert()函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入一个值</span></span><br><span class="line">iset.insert(ival);</span><br><span class="line"><span class="comment">//插入n个值</span></span><br><span class="line">iset.insert(vec.begin(), vec.end());</span><br></pre></td></tr></table></figure>



<h3 id="3-9-如何使用Iterator-Inserter"><a href="#3-9-如何使用Iterator-Inserter" class="headerlink" title="3.9 如何使用Iterator Inserter"></a>3.9 如何使用Iterator Inserter</h3><p>back_inserter()会以push_back()函数取代assignment运算。这样利用filter将符合条件的元素复制到output容器中时，就不必再指定output容器的具体大小。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> OutputIterator, <span class="keyword">typename</span> ElemType, <span class="keyword">typename</span> Comp&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">filter</span><span class="params">(InputIterator first, InputIterator last, OutputIterator at, <span class="keyword">const</span> ElemType &amp;val, Comp pred)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((first = find_if(first, last, bind2nd(pred, val))) != last) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        *at++ = *first++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> at;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a[] = &#123;<span class="number">10</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">45</span>, <span class="number">1</span>, <span class="number">67</span>, <span class="number">45</span>&#125;;</span><br><span class="line">  <span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ilist</span><span class="params">(a, a+<span class="number">6</span>)</span></span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//使用back_inserter()</span></span><br><span class="line">  filter(ilist.begin(), ilist.end(), back_inseerter(output), <span class="number">10</span>, greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-10-使用iostream-iterator"><a href="#3-10-使用iostream-iterator" class="headerlink" title="3.10 使用iostream iterator"></a>3.10 使用iostream iterator</h3><p>istream_iterator可以从设备中读取字符串，可以构成first和last的iterator指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//first</span></span><br><span class="line"><span class="function">istream_iterator&lt;stirng&gt; <span class="title">is</span><span class="params">(<span class="built_in">cin</span>)</span></span>;</span><br><span class="line"><span class="comment">//last</span></span><br><span class="line">istream_iterator&lt;<span class="built_in">string</span>&gt; eof;</span><br><span class="line"><span class="comment">//使用,将cin中字符insert到text中</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; text;</span><br><span class="line">copy(is, eof, back_inserter(text));</span><br></pre></td></tr></table></figure>

<p>ostream_iterator可以表示字符元素的输出位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ostream_iterator&lt;<span class="built_in">string</span>&gt; <span class="title">os</span><span class="params">(<span class="built_in">cout</span>, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line">copy(text.begin(), text.end(), os);</span><br></pre></td></tr></table></figure>



<h2 id="第四章-基于对象的编程风格"><a href="#第四章-基于对象的编程风格" class="headerlink" title="第四章 基于对象的编程风格"></a>第四章 基于对象的编程风格</h2><h3 id="4-1-如何实现一个class"><a href="#4-1-如何实现一个class" class="headerlink" title="4.1 如何实现一个class"></a>4.1 如何实现一个class</h3><p>1、class的声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>;</span></span><br></pre></td></tr></table></figure>

<p>class需要有前置声明，才能进行类指针的定义，或将class作为数据类型。故而定义class前，最好先进行声明。</p>
<p>2、class的声明</p>
<p>（1）private&amp;public</p>
<p>public member：可在程序任何地方被访问</p>
<p>private member：只能被member function或者class friend内被访问。</p>
<p>（2）member function声明与定义</p>
<p>member function都必须在主体内进行声明。</p>
<p>若member function在class主体内定义，则被视为inline函数；若在煮体外定义则加上inline关键字才为inline函数。</p>
<p>class主体外定义语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Stack::empty()&#123;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>（4）注意：如果member function是inline函数，则和普通inline函数同理，函数的定义应该放在声明类的头文件中。其他non-inline函数放在.cpp文件中。</b></p>
<h3 id="4-2-构造函数和析构函数"><a href="#4-2-构造函数和析构函数" class="headerlink" title="4.2 构造函数和析构函数"></a>4.2 构造函数和析构函数</h3><p>1、构造函数</p>
<p>构造函数和类同名，可以重载。一般也会给函数参数设置默认值。</p>
<p>构造函数有以下两种初始化语法。</p>
<p>（1）普通方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Triangular(<span class="keyword">int</span> len = <span class="number">1</span>, <span class="keyword">int</span> bp = <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _length;</span><br><span class="line">    <span class="keyword">int</span> _beg_pos;</span><br><span class="line">    <span class="keyword">int</span> _next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Triangular::Triangular(<span class="keyword">int</span> len, <span class="keyword">int</span> bp)&#123;</span><br><span class="line">    _length = len &gt; <span class="number">0</span> ? len : <span class="number">1</span>;</span><br><span class="line">    _beg_pos = bp &gt; <span class="number">0</span> ? bp : <span class="number">1</span>;</span><br><span class="line">    _next = _beg_pos - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>(2)Member Initialization List（成员初始化列表）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Triangular(<span class="keyword">int</span> len = <span class="number">1</span>, <span class="keyword">int</span> bp = <span class="number">1</span>);</span><br><span class="line">    Triangular(<span class="keyword">const</span> Triangular &amp;rhs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _length;</span><br><span class="line">    <span class="keyword">int</span> _beg_pos;</span><br><span class="line">    <span class="keyword">int</span> _next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Triangular::Triangular(<span class="keyword">const</span> Triangular &amp;rhs):_length(rhs._length), _beg_pos(rhs._beg_pos), _next(rhs._beg_pos<span class="number">-1</span>)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>



<p>2、析构函数</p>
<p>析构函数不是必须的，但在某些情况下，例如类中使用了heap分配内存，需要使用析构函数释放内存。析构函数的命名为~className()。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Matrix(<span class="keyword">int</span> row, <span class="keyword">int</span> col) : _row(row), _col(col)&#123;</span><br><span class="line">        _pmat = <span class="keyword">new</span> <span class="keyword">double</span>[row*col];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Matrix()&#123;</span><br><span class="line">        <span class="keyword">delete</span> [] _pmat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _row, _col;</span><br><span class="line">    <span class="keyword">double</span>* _pmat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-3-何谓mutable和const"><a href="#4-3-何谓mutable和const" class="headerlink" title="4.3 何谓mutable和const"></a>4.3 何谓mutable和const</h3><p>有些时候class被设置为const类型，则此时class中的元素都不能被修改。所以在调用公共接口public函数时，要确保class中的元素没有被修改。此时需要在member function中加上const标注，告诉编译器此函数不会更改调用者。</p>
<p>1、例如：</p>
<p>如果length()和beg_pos()后没有添加const，则sum函数调用时会报错。</p>
<p><b>const reference class参数不能调用class中的non-const成分。</b></p>
<p><b>如果member function不在class内定义，则声明和定义时都需要加const关键字</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Triangular(<span class="keyword">int</span> len = <span class="number">1</span>, <span class="keyword">int</span> bp = <span class="number">1</span>) &#123;</span><br><span class="line">        _length = len &gt; <span class="number">0</span> ? len : <span class="number">1</span>;</span><br><span class="line">        _beg_pos = bp &gt; <span class="number">0</span> ? bp : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//注意一下member function的定义</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> _length; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">beg_pos</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> _beg_pos; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _length;</span><br><span class="line">    <span class="keyword">int</span> _beg_pos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> Triangular &amp;a)</span> </span>&#123;</span><br><span class="line">    a.beg_pos();</span><br><span class="line">    a.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>同理编译器会检查const函数是否真的没有改变class的值，若改变了则会报错。</b></p>
<p><b>2、 若member function将class中元素的地址暴露出去也是不行的，因为这样给了其他部分程序修改class中元素的机会。如以下例子，编译器会报错</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">val_class</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    val_class(<span class="keyword">const</span> BigClass&amp; v) : _val(v) &#123;&#125;;</span><br><span class="line">    <span class="comment">//以下函数将private类型的BigClass地址暴露了出去</span></span><br><span class="line">    <span class="function">BigClass&amp; <span class="title">val</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _val;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BigClass _val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3、可以利用重载函数解决2中的问题</p>
<p><b>注意以下重载不是根据参数列表不同而进行重载，而是根据调用者是否为const而进行的重载。第一个const表示返回的Big Class&amp; val是const类型，不能改变其值，第二个const表示这个member function是不会改遍class中的元素。</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">val_class</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    val_class(<span class="keyword">const</span> BigClass&amp; v) : _val(v) &#123;&#125;;</span><br><span class="line">    <span class="function">BigClass&amp; <span class="title">val</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _val;&#125;</span><br><span class="line">  <span class="comment">//const重载</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> BigClass&amp; <span class="title">val</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _val;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BigClass _val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4、mutable</p>
<p>mutable变量可以让经过mutable标识的变量发生改变时，不破坏class的常量性。即const class中的mutable变量可以改变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mutable</span> <span class="keyword">int</span> _next</span><br></pre></td></tr></table></figure>



<h3 id="4-4-什么是this指针"><a href="#4-4-什么是this指针" class="headerlink" title="4.4 什么是this指针"></a>4.4 什么是this指针</h3><p>this指针指向member function的调用者（一个对象）。</p>
<p>内部工作时，编译器自动将this指针添加到每个member function的参数列表中。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Triangular&amp; <span class="title">Triangular::copy</span><span class="params">(<span class="keyword">const</span> Triangular&amp; rhs)</span></span>&#123;</span><br><span class="line">    _length = rhs._length;</span><br><span class="line">    _beg_pos = rhs._beg_pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上写法实际上在编译器中自动转化为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Triangular&amp; <span class="title">Triangular::copy</span><span class="params">(Triangular* <span class="keyword">this</span>, <span class="keyword">const</span> Triangular&amp; rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_length = rhs._length;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_beg_pos = rhs._beg_pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-5-静态类成员"><a href="#4-5-静态类成员" class="headerlink" title="4.5 静态类成员"></a>4.5 静态类成员</h3><p>static data member可以被同一类的所有对象共同拥有，访问，他是唯一的，即在各个对象中值都一样。</p>
<p>1、声明与定义</p>
<p>在.h文件中，声明时前面加static。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//Triangular.h文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Triangular(<span class="keyword">int</span> len = <span class="number">1</span>, <span class="keyword">int</span> bp = <span class="number">1</span>) &#123;</span><br><span class="line">        _length = len &gt; <span class="number">0</span> ? len : <span class="number">1</span>;</span><br><span class="line">        _beg_pos = bp &gt; <span class="number">0</span> ? bp : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> _length; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">beg_pos</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> _beg_pos; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gen_elems</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_elems</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _length;</span><br><span class="line">    <span class="keyword">int</span> _beg_pos;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _elems;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在.cpp文件中，要对static data member进行定义，此时可以不加static标识符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Triangular.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Triangular::_elems;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Triangular::gen_elems</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ix = _elems.size();</span><br><span class="line">    <span class="keyword">if</span> (!ix)</span><br><span class="line">    &#123;</span><br><span class="line">        _elems.push_back(<span class="number">1</span>);</span><br><span class="line">        ix = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (_elems[ix - <span class="number">1</span>] &lt; value) &#123;</span><br><span class="line">        ix++;</span><br><span class="line">        _elems.push_back(ix*(ix + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Triangular::print_elems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _elems.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; _elems[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2、对于static member function来说，调用的时候可以直接ClassName::fudnctionName()调用，不用特地声明一个对象，然后用这个对象来调用。</p>
<p>注意static member function调用的参数要求都是static类型的。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//对于static成员函数gen_elems()，可以直接用Triangular::gen_elems()调用，调用时不必构造对象。</span></span><br><span class="line">    Triangular::gen_elems(<span class="number">10</span>);</span><br><span class="line">    Triangular a = Triangular();</span><br><span class="line">    Triangular b = Triangular();</span><br><span class="line"><span class="comment">//对于非static成员函数print_elems()，则必须构建对象，然后用对象调用</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    a.print_elems();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b: &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    b.print_elems();</span><br></pre></td></tr></table></figure>

<p>3、实验</p>
<p>运行1-2中的代码，输出结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">10</span><br><span class="line">b:</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>可见对象a与对象b的_elems都是相同的，静态成员被所有对象共享，甚至可以在不建立对象的情况下初始化。</p>
<h3 id="4-6-打造一个Iterator-Class（对class进行运算符重载操作）"><a href="#4-6-打造一个Iterator-Class（对class进行运算符重载操作）" class="headerlink" title="4.6 打造一个Iterator Class（对class进行运算符重载操作）"></a>4.6 打造一个Iterator Class（对class进行运算符重载操作）</h3><p>本章主要是建立一了一个Trianguar_iterator类，类中对==、=、 !=、*、++（包括前置，后置）等运算符进行了重载，并完成了class.begin(), class.end()两个函数的实现。</p>
<p>Triangular_iterator即相当于针对Triangular类的泛型指针。它维护一个索引值，通过这个索引来访问Triangular类中_elems的特定元素。</p>
<p>1、重载运算符定义</p>
<p>重载运算符的方法就像是定义member function。不过函数名称不能任意，需要按照”operator 运算符名“的格式来定义。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular_iterator</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Triangular_iterator&amp;) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line">    Triangular_iterator&amp; <span class="keyword">operator</span>++(); <span class="comment">//前置++</span></span><br><span class="line">    Triangular_iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>); <span class="comment">//后置++。后置可否也返回&amp;类型？</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _index;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">check_intergrity</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> Triangular_iterator::<span class="keyword">operator</span>==(<span class="keyword">const</span> Triangular_iterator&amp; rhs) <span class="keyword">const</span>&#123;</span><br><span class="line">  <span class="comment">//注意此处需要使用rhs的private data member。所以要进行friend关联操作，或者在Traingular_iterator中加入public函数作为访问接口。</span></span><br><span class="line">     <span class="keyword">return</span> _index == rhs._index; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重载运算符函数也可以不作为成员函数，但这样的话参数列表里应该要多加一个Traingular_iterator&amp;，作为对this指针的代替。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> Triangular_iterator::<span class="keyword">operator</span>==(<span class="keyword">const</span> Triangular_iterator&amp; a, Triangular_iterator&amp; b)&#123;</span><br><span class="line">     <span class="keyword">return</span> a._index == b._index; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、运算符重载规则</p>
<p>（1）不可以引入新的运算符。</p>
<p>（2）运算符的操作数不可以改变</p>
<p>（3）运算符的优先级不能被改变</p>
<p>（4）运算符的参数列表中，必须至少有一个参数为class类型</p>
<p>3、完整代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Triangular.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Triangular_iterator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular_iterator</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Triangular_iterator</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//意思是在Triangular的命名空间中，Triangular_iterator可以简化为iterator</span></span><br><span class="line">    <span class="keyword">typedef</span> Triangular_iterator iterator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//class.begin()</span></span><br><span class="line">    <span class="function">Triangular_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//class.end()</span></span><br><span class="line">    <span class="function">Triangular_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    Triangular(<span class="keyword">int</span> len = <span class="number">1</span>, <span class="keyword">int</span> bp = <span class="number">1</span>) &#123;</span><br><span class="line">        _length = len &gt; <span class="number">0</span> ? len : <span class="number">1</span>;</span><br><span class="line">        _beg_pos = bp &gt; <span class="number">0</span> ? bp : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> _length; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">beg_pos</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> _beg_pos; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gen_elems</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_elems</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _length;</span><br><span class="line">    <span class="keyword">int</span> _beg_pos;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _max_elems;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _elems;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Triangular.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Triangular.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Triangular::_elems;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Triangular::_max_elems = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Triangular::gen_elems</span><span class="params">(<span class="keyword">int</span> to_size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ix = _elems.size();</span><br><span class="line">    <span class="keyword">if</span> (!ix)</span><br><span class="line">    &#123;</span><br><span class="line">        _elems.push_back(<span class="number">1</span>);</span><br><span class="line">        ix = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ix &lt; to_size &amp;&amp; ix &lt; _max_elems) &#123;</span><br><span class="line">        ix++;</span><br><span class="line">        _elems.push_back(ix*(ix + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ix == _max_elems) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Exceed the max size of &quot;</span> &lt;&lt; _max_elems &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Triangular::print_elems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _elems.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; _elems[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Triangular_iterator <span class="title">Triangular::begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Triangular_iterator(_beg_pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Triangular_iterator <span class="title">Triangular::end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Triangular_iterator(_beg_pos + _length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Triangular_iterator.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Triangular.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Triangular_iterator(<span class="keyword">int</span> index) : _index(index - <span class="number">1</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Triangular_iterator&amp; rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> _index == rhs._index; &#125;;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Triangular_iterator&amp; rhs)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _index != rhs._index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    Triangular_iterator&amp; <span class="keyword">operator</span>++(); <span class="comment">//前置</span></span><br><span class="line">    Triangular_iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>); <span class="comment">//后置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">check_intergrity</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">int</span> _index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Triangular_iterator.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Triangular_iterator.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Triangular_iterator::check_intergrity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_index &gt;= Triangular::_max_elems)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;OverFlow&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_index &gt;= Triangular::_elems.size()) &#123;</span><br><span class="line">        Triangular::gen_elems(_index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Triangular_iterator&amp; Triangular_iterator:: <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    check_intergrity();</span><br><span class="line">    ++_index;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照重载的要求，后置++必须和前置++参数不同。于是后置++默认加一个int参数。可不用理会，编译器会自动处理。</span></span><br><span class="line">Triangular_iterator Triangular_iterator::<span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    check_intergrity();</span><br><span class="line">    ++_index;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Triangular_iterator::<span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">    check_intergrity();</span><br><span class="line">    <span class="comment">//如果_elems并非static类型，如何修改代码，使此函数能够确认对象的_elems是多少？</span></span><br><span class="line">    <span class="keyword">return</span> Triangular::_elems[_index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意，这里如果将成员函数设置为inline，定义在.h文件中，则Triangular类和Triangular_iterator类之间不能互相调用。会报错：使用了未定义类型“Triangular” or 使用了未定义类型”Triangular_iterator”</p>
<p>![image-20210408194045289](/Users/alice/Library/Application Support/typora-user-images/image-20210408194045289.png)</p>
<h3 id="4-7-合作关系必须建立在友谊的基础上"><a href="#4-7-合作关系必须建立在友谊的基础上" class="headerlink" title="4.7 合作关系必须建立在友谊的基础上"></a>4.7 合作关系必须建立在友谊的基础上</h3><p>class可以有friend函数和friend class。在class的声明中声明friend函数或者friend类，则其friend可以访问其private member。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular</span>&#123;</span></span><br><span class="line"><span class="comment">//friend声明可以放在任意地方，不受public和private影响</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">a</span>;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">int</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="4-9-实现一个function-object"><a href="#4-9-实现一个function-object" class="headerlink" title="4.9 实现一个function object"></a>4.9 实现一个function object</h3><p>function object：一种对象，提供有“函数调用”运算符。其实就是重载运算符”()”。</p>
<p>在3.6章中，有function object和泛型算法一起使用的例子。</p>
<p>例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LessThan</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LessThan(<span class="keyword">int</span> val) : _val(val)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">comp_val</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _val;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">comp_val</span><span class="params">(<span class="keyword">int</span> nval)</span></span>&#123;_val = nval;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//（）重载</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">LessThan::operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> value &lt; _val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_less_than</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> comp)</span></span>&#123;</span><br><span class="line">     <span class="comment">//初始化LessThan对象</span></span><br><span class="line">  <span class="function">LessThan <span class="title">it</span><span class="params">(comp)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;vec.size(); i++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(it(vec[i]))</span><br><span class="line">      count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>当编译器遇到函数调用语句，例如it(val);，则it可能是函数名称，函数指针，也可能是一个对象，此对象重载了()运算符。如果it是个对象，则编译器会在内部将此语句转化成it.operator(val);</b></p>
<h3 id="4-10-重载iostream运算符"><a href="#4-10-重载iostream运算符" class="headerlink" title="4.10 重载iostream运算符"></a>4.10 重载iostream运算符</h3><p>实质上是重载运算符&lt;&lt;和&gt;&gt;，本质没有变化。</p>
<h2 id="第五章-面向对象编程风格"><a href="#第五章-面向对象编程风格" class="headerlink" title="第五章 面向对象编程风格"></a>第五章 面向对象编程风格</h2><h3 id="5-1-面向对象编程概念"><a href="#5-1-面向对象编程概念" class="headerlink" title="5.1 面向对象编程概念"></a>5.1 面向对象编程概念</h3><p>1、继承：可以从基类中衍生出许多派生类。派生类可以增加、覆盖父类（基类）中继承而来的成员变量和函数，以实现独特行为。</p>
<p>2、多态：让基类类型的pointer或者reference可以十分透明地指向任何一个派生类</p>
<p>​        例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loan_check_in</span><span class="params">(LibMat &amp;mat)</span> <span class="comment">//LibMat &amp;mat参数可以传入非LibMat类型，而是传入任意LibMat的派生类</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mat.check_in();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、动态绑定</p>
<p>一般来说，在编译器编译的时候，就应该解析出程序应该调用哪个函数，但因为多态的存在，无法确定是哪个派生类调用函数。例如2中的mat.check_in()，只能在执行时根据mat所指的实际对象来决定调用的check_in()函数。这个过程会被延迟到运行时，成为动态绑定</p>
<p>4、虚函数</p>
<p>（1）默认情况下，成员函数的解析在编译时静态进行，若要进行动态绑定，需要增加virtual关键词。</p>
<p>（2）一般来说，若某个成员函数在不同的派生类中，有不同的实现方式，则定义其为虚函数。</p>
<p>（3）每个虚函数，要么有定义，要么可设为纯虚函数，赋值为0。含有虚函数的类无法产生对象，只能作为派生类的子对象使用。</p>
<p>（4）static member function无法被设定为虚函数。</p>
<p>（5）一般来说，若基类有一个或多个虚函数，应该将destructor声明为virtual。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> num_sequence::~num_sequence()&#123;&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-2-漫游：面向对象编程思维"><a href="#5-2-漫游：面向对象编程思维" class="headerlink" title="5.2 漫游：面向对象编程思维"></a>5.2 漫游：面向对象编程思维</h3><p>1、基类和派生类constructor和destructor调用顺序：</p>
<p>基类constructor-&gt;派生类constructor-&gt;派生类的派生类的constructor-&gt;…-&gt;派生类的派生类的destructor-&gt;派生类的destructor-&gt;基类的destructor</p>
<p>类似于盖房子，从底部开始建，从顶部开始拆</p>
<p>2、派生类定义格式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AudioBook</span> :</span> <span class="keyword">public</span> Book&#123; <span class="comment">//加public和基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AudioBook(<span class="keyword">const</span> <span class="built_in">string</span> &amp; title, <span class="keyword">const</span> <span class="built_in">string</span>&amp; author, <span class="keyword">const</span> <span class="built_in">string</span> &amp;narrator) : Book(title, author), _narrator(narrator)&#123;&#125;<span class="comment">//这里调用了基类Book的构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、protected</p>
<p>private：可以被子类继承，但不能被子类直接访问，需要调用父类的非public函数访问</p>
<p>protected：可以被继承类直接访问，其他对象不可访问</p>
<p>public：都可以直接访问</p>
<h3 id="5-4-定义一个抽象基类"><a href="#5-4-定义一个抽象基类" class="headerlink" title="5.4 定义一个抽象基类"></a>5.4 定义一个抽象基类</h3><p>定义抽象基类设计思路：</p>
<p>1、找出所有子类的共同操作行为，从而确定基类需要包含的函数</p>
<p>2、找出哪些操作行为与类型相关，从而确定虚函数</p>
<p>3、确定private、protected、public层级</p>
<h3 id="5-5-定义一个派生类"><a href="#5-5-定义一个派生类" class="headerlink" title="5.5 定义一个派生类"></a>5.5 定义一个派生类</h3><p>1、对于派生类中的non-virtual函数，因为基类中没有相应的接口，所以无法通过基类的pointer或者reference调用。</p>
<p>2、继承来的public和protected成员，无论在继承体系中深度如何，都可被视为派生类自身拥有的成员。即，基类中的public和protected在派生类的派生类中也是public和protected属性。</p>
<p>3、派生类中有member和基类同名，则派生类中对该名称的调用，自动解析为派生类中的定义。如果要使用基类的定义，需要加上class scope， 如class_name::function()。</p>
<p>但是若是用基类类型的reference或者pointer调用这个member，且此memeber没有被声明为virtual，则只能调用到基类的定义。</p>
<h3 id="5-6-运用继承体系"><a href="#5-6-运用继承体系" class="headerlink" title="5.6 运用继承体系"></a>5.6 运用继承体系</h3><h3 id="5-7-基类该多么抽象"><a href="#5-7-基类该多么抽象" class="headerlink" title="5.7 基类该多么抽象"></a>5.7 基类该多么抽象</h3><p>Data member使用reference VS pointer：</p>
<p>（1）如果使用reference，因为reference无法代表空对象，所以必须在constructor的member initialization list中初始化，并且初始化后不能指代另一个对象。</p>
<p>（2）如果使用pointer，则可以在constructor中先初始化为NULL，之后再赋予有效内存地址。但是每次使用前，都要判断pointer是否为空。</p>
<h3 id="5-8-初始化、析构、复制"><a href="#5-8-初始化、析构、复制" class="headerlink" title="5.8 初始化、析构、复制"></a>5.8 初始化、析构、复制</h3><p>1、基类如果有实际的data member，则需要初始化。较好的方法是为基类提供constructor，利用constructor初始化data member。<b>因为抽象基类不能建立对象，所以constructor可以设置为protected，是开放给派生类使用。</b></p>
<p>（1）一般利用派生类的构造函数，调用基类的构造函数，例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Fibonacci::Fibonacci</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> beg_pos)</span> : <span class="title">num_sequence</span><span class="params">(len, beg_pos, elems)</span> <span class="comment">//这里_elems是Fibonacci类的static data member</span></span></span><br></pre></td></tr></table></figure>

<p>（2）也可以为num_sequence提供default constructor。当派生类的constructor没有明确指明调用哪个基类constructor时，使用基类的默认constructor。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">num_sequence::num_sequence(<span class="keyword">int</span> len=<span class="number">1</span>, <span class="keyword">int</span> bp = <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;* pe=<span class="number">0</span>) : _length(len), _beg_pos(bp), _pelems(pe)&#123;&#125; <span class="comment">//这里reference要改成pointer，将pointer默认初始化为0</span></span><br></pre></td></tr></table></figure>

<p>2、复制</p>
<p>无论是用类初始化类，还是用=在类间赋值，都有默认的copy constructor和copy assignment operator，会将需要初始化的data member意义赋值过去，一般可以不用另外定义。但是如果出现例如4.2那种，data member中存在指针，destructor中有释放指针指向的内存的操作时，为了防止二次释放已释放内存，需要自行重载定义一下。</p>
<h3 id="5-9-在派生类中定义一个虚函数"><a href="#5-9-在派生类中定义一个虚函数" class="headerlink" title="5.9 在派生类中定义一个虚函数"></a>5.9 在派生类中定义一个虚函数</h3><p>1、如果要覆盖基类所提供的虚函数定义，那么派生类中的新定义的函数原型必须和基类中的一模一样，包括：函数列表、返回类型、常量性（const）</p>
<p>如果不完全一致，可能导致虚函数定义没有被覆盖，用基类pointer或reference调用虚函数时，调用的仍然是基类的定义（即没有完成多态）。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基类虚函数定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">num_sequence</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what_am_i</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;num_sequence\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//派生类虚函数定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> :</span> <span class="keyword">public</span> num_sequence&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what_am_i</span><span class="params">()</span></span>&#123;<span class="comment">//少了一个const</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Fibonacci\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Fibonacci b;</span><br><span class="line">  </span><br><span class="line">  num_sequence* pp = &amp;b;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; pp-&gt;what_am_i(); <span class="comment">//输出num_sequence</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;b.what_what_am_i(); <span class="comment">//输出Fibonacci</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><b>注意：如果虚函数返回的类型为某个基类形式（比如基类的pointer或者reference时），派生类定义的虚函数返回类型可以为派生类的相应类型，不必完全一样。</b></p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> num_sequence * <span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Fibonacci * <span class="title">clone</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Fibonacci(*<span class="keyword">this</span>);&#125;</span><br></pre></td></tr></table></figure>

<p>2、虚函数的静态解析</p>
<p>如下两种情况下，虚函数不是动态解析，而是静态解析</p>
<p>（1）基类的constructor和destructor调用虚函数。因为此时派生类还没有construct，或者已经被destruct了，所以默认调用的事基类的虚函数</p>
<p>（2）使用的是基类对象，而非基类的pointer或者reference。<b>即想要使用多态的性质，必须使用pointer或者reference</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(LibMat object, <span class="keyword">const</span> LibMat&amp; pointer, <span class="keyword">const</span> LibMat &amp;reference)</span></span>&#123;</span><br><span class="line">    <span class="comment">//调用LibMat::print()</span></span><br><span class="line">    object.print();</span><br><span class="line">    <span class="comment">//动态绑定，根据派生类类型调用派生类中的virtual函数</span></span><br><span class="line">    pointer-&gt;print();</span><br><span class="line">    reference-&gt;print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>上述例子中第一个参数object，传入的必须是基类LibMat的对象，因为分配的空间只有基类大小，如果传入的是派生类的对象，那么会只保留基类成分，其他的派生类成分被砍掉。而pointer和reference被初始化为指向对象的内存地址，所以可以接纳派生类。</b></p>
<h3 id="5-10-运行时的类型鉴定机制"><a href="#5-10-运行时的类型鉴定机制" class="headerlink" title="5.10 运行时的类型鉴定机制"></a>5.10 运行时的类型鉴定机制</h3><p>RTT（Run-Time Type Identification，RTTI）运行时类型鉴定机制</p>
<p>1、例1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">char</span>* num_sequence::</span><br><span class="line">what_am_i() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeid</span>(*<span class="keyword">this</span>).name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>头文件<typeinfo>下的typeid运算符，会返回一个type_info对象，里面存储着与类型相关的信息。</p>
<p>2、例2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">num_sequence * ps = &amp;fib;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeid</span>(*ps) == <span class="keyword">typeid</span>(Fibonacci)) <span class="comment">//可用来判断ps指向对象的类型</span></span><br></pre></td></tr></table></figure>

<p>3、例3</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">num_sequence * ps = &amp;fib;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeid</span>(*ps) == <span class="keyword">typeid</span>(Fibonacci))&#123;</span><br><span class="line">    Fibonacci *pf = <span class="keyword">static_cast</span>&lt;Fibonacci*&gt;(ps); <span class="comment">//无条件转换，不管是否正确</span></span><br><span class="line">    pf-&gt;gen_elems(<span class="number">64</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用dynamic_cast，这也是个RTTI运算法，会在运行时检验操作。可以转换，则进行转换，否则，则返回0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">num_sequence *ps = &amp;fib;</span><br><span class="line"><span class="keyword">if</span>(Fibonacci * pf = <span class="keyword">dynamic_cast</span>&lt;Fibonacci*&gt;(ps))&#123;</span><br><span class="line">    pf-&gt;gen_elems(<span class="number">64</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第六章-以template进行编程"><a href="#第六章-以template进行编程" class="headerlink" title="第六章 以template进行编程"></a>第六章 以template进行编程</h2><h3 id="6-1-被参数化的类型-amp-6-2-Class-Template的定义"><a href="#6-1-被参数化的类型-amp-6-2-Class-Template的定义" class="headerlink" title="6.1 被参数化的类型 &amp; 6.2 Class Template的定义"></a>6.1 被参数化的类型 &amp; 6.2 Class Template的定义</h3><p>定义套路如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h文件</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BinaryTree();</span><br><span class="line">    ~BinaryTree();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BTnode&lt;elemType&gt;* _root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//.cpp文件</span></span><br><span class="line"><span class="comment">//注意函数定义时要加template &lt;typename elemType&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line">BinaryTree&lt;elemType&gt;::</span><br><span class="line">BinaryTree() : _root(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line">BinaryTree&lt;elemType&gt;::~BinaryTree()&#123;</span><br><span class="line">  clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6-3-Template类型参数的处理"><a href="#6-3-Template类型参数的处理" class="headerlink" title="6.3 Template类型参数的处理"></a>6.3 Template类型参数的处理</h3><p>因为不知道elemType究竟会是什么类型。在函数传参时，为了避免Matrix等比较大的数据复制，（1）使用reference传参（2）在类的constructor中，使用member initialization初始化成员，而不是在构造函数内部赋值。</p>
<p>优秀写法示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> valType&gt;</span><br><span class="line"><span class="keyword">inline</span> BTnode&lt;valType&gt;::</span><br><span class="line">BTnode(<span class="keyword">const</span> valType &amp;val)</span><br><span class="line">    :_val(val)</span><br><span class="line">&#123;</span><br><span class="line">        _lchile = _rchild = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-4-实现一个Class-Template"><a href="#6-4-实现一个Class-Template" class="headerlink" title="6.4 实现一个Class Template"></a>6.4 实现一个Class Template</h3><h2 id="第7章-异常处理"><a href="#第7章-异常处理" class="headerlink" title="第7章 异常处理"></a>第7章 异常处理</h2><h3 id="7-1-抛出异常"><a href="#7-1-抛出异常" class="headerlink" title="7.1 抛出异常"></a>7.1 抛出异常</h3><p>1、异常处理机制：</p>
<p>（1）异常的鉴定与发出：throw</p>
<p>（2）异常的处理方式：catch</p>
<p>异常处理过程：</p>
<p>异常出现，正常程序执行被暂停-&gt;异常处理机制搜索程序中有能力处理异常的地点-&gt;异常处理完成，程序从异常处理点接着执行下去。</p>
<p>2、throw</p>
<p>可以throw整数、字符串、异常类等</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="number">42</span>;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;panic: no buffer!&quot;</span>;</span><br><span class="line"><span class="keyword">throw</span> iterator_overflow;</span><br></pre></td></tr></table></figure>

<p>异常类可以自行定义，也可以继承于exception基类（详情见7.5）</p>
<h3 id="7-2-捕获异常"><a href="#7-2-捕获异常" class="headerlink" title="7.2 捕获异常"></a>7.2 捕获异常</h3><ol>
<li>利用catch子句来捕获被抛出的异常对象。</li>
</ol>
<p>示例:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">log_message</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>();</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">extern</span> <span class="built_in">string</span> err_messages[];</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">extern</span> ostream log_file;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">bool</span> some_function()&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">bool</span> status = <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//...</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//对应抓取throw的整型异常</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">catch</span>(<span class="keyword">int</span> errno)&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        log_message(err_messages[errno]);</span></span></span><br><span class="line"><span class="function"><span class="params">        status = <span class="literal">false</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//对应抓取throw的字符串异常</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">catch</span>(<span class="keyword">const</span> <span class="keyword">char</span>* str)&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">       log_message(str);</span></span></span><br><span class="line"><span class="function"><span class="params">    status = <span class="literal">false</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">  </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">//对应抓取throw抛出的类</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">catch</span>(iterator_overflow &amp;iof)&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">       iof.what_happened(log_file);</span></span></span><br><span class="line"><span class="function"><span class="params">    status = <span class="literal">false</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">  </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">return</span> status;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//捕获任何类型异常</span></span><br><span class="line"><span class="keyword">catch</span>(...)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li><p>重新抛出异常</p>
<p>有时候catch中无法完成异常处理，需要在catch中重新rethrow异常，寻求其他catch子句的帮助，例如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span>(iterator_overflow &amp;iof)&#123;</span><br><span class="line">    log_message(iof.what_happened());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="7-3-提炼异常"><a href="#7-3-提炼异常" class="headerlink" title="7.3 提炼异常"></a>7.3 提炼异常</h3><p>catch子句和try子句一一对应，表示如果try内有任何异常发生，则接下来由catch子句加以处理。</p>
<p>每一个被抛出的异常，都有一个throw表达式，可能隐藏的很深，在标准库中。</p>
<p>1、由throw的位置，根据函数调用链寻找catch</p>
<p>由throw语句位置，判断当前是否在try块内 ?（1）</p>
<p>是-&gt;检验相应的catch子句，判断其是否有处理异常的能力。若有，则根据catch语句处理异常，程序从被执行的catch的下一句继续。若没有，则中断函数，沿着函数调用链回溯，寻找符合条件的catch。</p>
<p>否-&gt;停止当前函数，寻找当前函数的调用端，判断调用端是否在try语句中，回到步骤（1）</p>
<p>如果回溯到main()内还是找不到合适的catch子句，则调用标准库中的terminate()，中断整个程序运行。</p>
<p>见P195示例</p>
<h3 id="7-4-局部资源管理"><a href="#7-4-局部资源管理" class="headerlink" title="7.4 局部资源管理"></a>7.4 局部资源管理</h3><p>异常处理机制在终结某个函数之前，c++保证，函数中所有局部对象的destructor都会被调用，这样可以保证资源在有异常抛出的情况下，也可以被释放。</p>
<p>例如下面三种写法：</p>
<p>写法一： 错误写法</p>
<p>如果process()中出现throw，则process()后的释放资源语句不会被执行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> Mutex m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//请求资源</span></span><br><span class="line">     <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">  m.acquire();</span><br><span class="line">  process(p);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//释放资源</span></span><br><span class="line">  m.release();</span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>写法二: 利用try catch保证资源释放</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">       <span class="comment">//同写法一 </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>(...)&#123;</span><br><span class="line">    m.release();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>写法三：利用类的destructor保证资源释放</p>
<p>即使没有异常抛出，对象消亡时，destructor也会被调用。</p>
<p>本例中，函数终结前，局部变量的destructor都会被调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//auto_ptr是一个template class，可以自动删除new分配的对象。将*和-&gt;运算符重载，使用方式同一般指针。</span></span><br><span class="line">    <span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line">  <span class="comment">//MutexLock类的destructor中完成资源释放</span></span><br><span class="line">  <span class="function">MuteLock <span class="title">ml</span><span class="params">(m)</span></span>;</span><br><span class="line">  process(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-5-标准异常"><a href="#7-5-标准异常" class="headerlink" title="7.5 标准异常"></a>7.5 标准异常</h3><p>​    标准库定义了一套异常类体系，根部时exception抽象基类。exception有虚函数const char* what()，用以表示被抛出异常的文字描述。</p>
<p>​    如果将自己编写的异常类继承于exception基类下，则可以被catch(const exception &amp;ex)捕获，一网打尽所有异常。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span>(<span class="keyword">const</span> exception&amp; ex)&#123;</span><br><span class="line">     <span class="built_in">cerr</span> &lt;&lt; ex.what() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exception的派生类写法示例:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iterator_overflow</span> :</span> <span class="keyword">public</span> exception&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    iterator_overflow(<span class="keyword">int</span> index, <span class="keyword">int</span> max) : _index(index), _max(max) &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">index</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _index;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _max;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _index;</span><br><span class="line">    <span class="keyword">int</span> _max;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* iterator_overflow::</span><br><span class="line">what() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="built_in">ostringstream</span> ex_msg;</span><br><span class="line">    <span class="comment">//为什么要用static类型??</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">string</span> msg;</span><br><span class="line"></span><br><span class="line">    ex_msg &lt;&lt; <span class="string">&quot;Internal error: current index&quot;</span></span><br><span class="line">            &lt;&lt; _index &lt;&lt; <span class="string">&quot;exceeds maximum bound: &quot;</span></span><br><span class="line">            &lt;&lt;_max;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ostringstream的str()可以提供转化操作，将不同类型的数据格式转化为字符串</span></span><br><span class="line">    msg = ex_msg.str();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//string的成员函数c_str()返回const char*类型字符串</span></span><br><span class="line">    <span class="keyword">return</span> msg.c_str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><b>注：cout 输出到标准输出的ostream对象，cerr输出到标准错误的ostream对象</b></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-100. Same Tree</title>
    <url>/2021/03/25/LeetCode-100-Same-Tree/</url>
    <content><![CDATA[<h1 id="LeetCode-100-Same-Tree"><a href="#LeetCode-100-Same-Tree" class="headerlink" title="LeetCode-100. Same Tree"></a>LeetCode-100. Same Tree</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given two binary trees, write a function to check if they are the same or not.</p>
<p>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          &#x2F;           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>递归的中序遍历方法比较两棵树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p &amp;&amp; !q)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p&amp;&amp;q || p&amp;&amp;!q || p-&gt;val!=q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>非递归的先序遍历方法比较两棵树。使用栈，栈中先放右子树根结点，再放左子树根结点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s1;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s2;</span><br><span class="line">        s1.push(p);</span><br><span class="line">        s2.push(q);</span><br><span class="line">        <span class="keyword">while</span>(!s1.empty() &amp;&amp; !s2.empty())&#123;</span><br><span class="line">            p = s1.top(); s1.pop();</span><br><span class="line">            q = s2.top(); s2.pop();</span><br><span class="line">            <span class="keyword">if</span>(!p&amp;&amp;!q) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!p&amp;&amp;q || p&amp;&amp;!q || p-&gt;val!=q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            s1.push(p-&gt;right);</span><br><span class="line">            s2.push(q-&gt;right);</span><br><span class="line">            s1.push(p-&gt;left);</span><br><span class="line">            s2.push(q-&gt;left);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-97. Interleaving String</title>
    <url>/2021/03/25/Leetcode-97-Interleaving-String/</url>
    <content><![CDATA[<h1 id="Leetcode-97-Interleaving-String"><a href="#Leetcode-97-Interleaving-String" class="headerlink" title="Leetcode-97. Interleaving String"></a>Leetcode-97. Interleaving String</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given <em>s1</em>, <em>s2</em>, <em>s3</em>, find whether <em>s3</em> is formed by the interleaving of <em>s1</em> and <em>s2</em>.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbcbcac&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbbaccc&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>使用动态规划方法。<!--dp[i][j]-->表示s3中的前i+j个元素，可以由s1中的前i个元素和s2中的前j个元素构成。</p>
<p>从而可以初始化<!--dp[i][0]和dp[0][j]--></p>
<p>状态转移方程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] &#x3D; dp[i-1][j]&amp;&amp;s1[i-1]&#x3D;&#x3D;s3[i+j-1] || dp[i][j-1]&amp;&amp;s2[j-1]&#x3D;&#x3D;s3[i+j-1]</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.size()+s2.size() != s3.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = s1.size();</span><br><span class="line">        <span class="keyword">int</span> m = s2.size();</span><br><span class="line">        <span class="comment">//注意这种声明方式</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m+<span class="number">1</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] &amp;&amp; s3[i<span class="number">-1</span>] == s1[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;m+<span class="number">1</span>; j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>] &amp;&amp; s3[j<span class="number">-1</span>] == s2[j<span class="number">-1</span>];</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n+<span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;m+<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j<span class="number">-1</span>]&amp;&amp;s2[j<span class="number">-1</span>]==s3[i+j<span class="number">-1</span>] || dp[i<span class="number">-1</span>][j]&amp;&amp;s1[i<span class="number">-1</span>]==s3[i+j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">              </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-101. Symmetric Tree</title>
    <url>/2021/03/26/LeetCode-101-Symmetric-Tree/</url>
    <content><![CDATA[<h1 id="LeetCode-101-Symmetric-Tree"><a href="#LeetCode-101-Symmetric-Tree" class="headerlink" title="LeetCode-101. Symmetric Tree"></a>LeetCode-101. Symmetric Tree</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree is symmetric:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>

<p>But the following is not:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>

<p>Note:<br>Bonus points if you could solve it both recursively and iteratively.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> recursion(root-&gt;left, root-&gt;right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">recursion</span><span class="params">(TreeNode* leftNode, TreeNode* rightNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!leftNode &amp;&amp; !rightNode) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!leftNode&amp;&amp;rightNode || leftNode&amp;&amp;!rightNode || leftNode-&gt;val!=rightNode-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recursion(leftNode-&gt;left, rightNode-&gt;right) &amp;&amp; recursion(leftNode-&gt;right, rightNode-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-102. Binary Tree Level Order Traversal</title>
    <url>/2021/03/26/LeetCode-102-Binary-Tree-Level-Order-Traversal/</url>
    <content><![CDATA[<h1 id="LeetCode-102-Binary-Tree-Level-Order-Traversal"><a href="#LeetCode-102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="LeetCode-102. Binary Tree Level Order Traversal"></a>LeetCode-102. Binary Tree Level Order Traversal</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, return the <em>level order</em> traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>Given binary tree <code>&#123;3,9,20,#,#,15,7&#125;</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>return its level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>迭代方法。</p>
<p>使用队列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push_back(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">            <span class="keyword">int</span> _size = q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++)&#123;</span><br><span class="line">                TreeNode* root = q.front();</span><br><span class="line">                q.pop_front();</span><br><span class="line">                </span><br><span class="line">                level.push_back(root-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">                    q.push_back(root-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">                    q.push_back(root-&gt;right);</span><br><span class="line">                  </span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>递归方法。不需要队列存储，只要给一个层数的标识符level，用中序遍历方法遍历存储即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        recursion(root, res, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recursion</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="keyword">int</span> level)</span></span>&#123;   </span><br><span class="line">        <span class="comment">//if(!root) return;</span></span><br><span class="line">        <span class="keyword">if</span>(res.size()&lt;level) res.push_back(&#123;&#125;);</span><br><span class="line">        res[level<span class="number">-1</span>].push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) recursion(root-&gt;left, res, level+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) recursion(root-&gt;right, res, level+<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-104. Maximum Depth of Binary Tree</title>
    <url>/2021/03/27/LeetCode-104-Maximum-Depth-of-Binary-Tree/</url>
    <content><![CDATA[<h2 id="LeetCode-104-Maximum-Depth-of-Binary-Tree"><a href="#LeetCode-104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="LeetCode-104. Maximum Depth of Binary Tree"></a>LeetCode-104. Maximum Depth of Binary Tree</h2><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a binary tree, find its maximum depth.</span><br><span class="line"></span><br><span class="line">The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</span><br><span class="line"></span><br><span class="line">Note: A leaf is a node with no children.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">return its depth &#x3D; 3.</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = Depth(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(TreeNode* root, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> level;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(Depth(root-&gt;left, level+<span class="number">1</span>), Depth(root-&gt;right,level+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-103. Binary Tree Zigzag Level Order Traversal</title>
    <url>/2021/03/27/LeetCode-103-Binary-Tree-Zigzag-Level-Order-Traversal/</url>
    <content><![CDATA[<h1 id="LeetCode-103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#LeetCode-103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="LeetCode-103. Binary Tree Zigzag Level Order Traversal"></a>LeetCode-103. Binary Tree Zigzag Level Order Traversal</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, return the <em>zigzag level order</em> traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>return its zigzag level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>使用递归，以下做法是错误的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        recursion(root, <span class="number">1</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recursion</span><span class="params">(TreeNode* root, <span class="keyword">int</span> level, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(res.size() &lt; level)&#123;</span><br><span class="line">            res.push_back(&#123;&#125;);   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res[level<span class="number">-1</span>].push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(level%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">                recursion(root-&gt;right, level+<span class="number">1</span>, res);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">                recursion(root-&gt;left, level+<span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">                recursion(root-&gt;left, level+<span class="number">1</span>, res);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">                recursion(root-&gt;right, level+<span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>正确做法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        recursion(root, <span class="number">1</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recursion</span><span class="params">(TreeNode* root, <span class="keyword">int</span> level, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(res.size() &lt; level)&#123;</span><br><span class="line">            res.push_back(&#123;&#125;);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(level%<span class="number">2</span>==<span class="number">0</span>) res[level<span class="number">-1</span>].insert(res[level<span class="number">-1</span>].begin(),root-&gt;val);</span><br><span class="line">        <span class="keyword">else</span> res[level<span class="number">-1</span>].push_back(root-&gt;val);</span><br><span class="line">        </span><br><span class="line">        recursion(root-&gt;left, level+<span class="number">1</span>, res);</span><br><span class="line">        recursion(root-&gt;right, level+<span class="number">1</span>, res);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-107. Binary Tree Level Order Traversal ||</title>
    <url>/2021/03/30/LeetCode-107-Binary-Tree-Level-Order-Traversal/</url>
    <content><![CDATA[<h1 id="LeetCode-107-Binary-Tree-Level-Order-Traversal"><a href="#LeetCode-107-Binary-Tree-Level-Order-Traversal" class="headerlink" title="LeetCode-107. Binary Tree Level Order Traversal ||"></a>LeetCode-107. Binary Tree Level Order Traversal ||</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br>Given binary tree <code>&#123;3,9,20,#,#,15,7&#125;</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>return its bottom-up level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>正常按层次遍历，然后再反过来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        recursion(root, <span class="number">1</span>, res);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; (res.rbegin(), res.rend());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recursion</span><span class="params">(TreeNode* root, <span class="keyword">int</span> level, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(res.size()&lt;level)&#123;</span><br><span class="line">            res.push_back(&#123;&#125;);  </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res[level<span class="number">-1</span>].push_back(root-&gt;val);</span><br><span class="line">        recursion(root-&gt;left, level+<span class="number">1</span>, res);</span><br><span class="line">        recursion(root-&gt;right, level+<span class="number">1</span>, res);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-108. Convert Sorted Array to Binary Search Tree</title>
    <url>/2021/03/30/LeetCode-108-Convert-Sorted-Array-to-Binary-Search-Tree/</url>
    <content><![CDATA[<h1 id="LeetCode-108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#LeetCode-108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="LeetCode-108. Convert Sorted Array to Binary Search Tree"></a>LeetCode-108. Convert Sorted Array to Binary Search Tree</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em>node never differ by more than 1.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given the sorted array: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        TreeNode* root = recursion(<span class="number">0</span>, nums.size()<span class="number">-1</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root-&gt;left = recursion(left, mid<span class="number">-1</span>, nums);</span><br><span class="line">        root-&gt;right = recursion(mid+<span class="number">1</span>, right, nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-109. Convert Sorted List to Binary Search Tree</title>
    <url>/2021/03/30/LeetCode-109-Convert-Sorted-List-to-Binary-Search-Tree/</url>
    <content><![CDATA[<h1 id="LeetCode-109-Convert-Sorted-List-to-Binary-Search-Tree"><a href="#LeetCode-109-Convert-Sorted-List-to-Binary-Search-Tree" class="headerlink" title="LeetCode-109. Convert Sorted List to Binary Search Tree"></a>LeetCode-109. Convert Sorted List to Binary Search Tree</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given the sorted linked list: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>不同于108，将数组转化为平衡搜索树，list没有用下标取值操作。所以要使用快慢指针。快慢指针可以用来找中点，即fast指针一次向前移动两次，slow指针一次向前移动一次。</p>
<p>本题中，需要每次把当前list划分为中点、中点左侧的list和中点右侧的list。因此当前list需要传入首指针和末尾指针。末尾指针指的是list末尾元素的下一个地址，类似于iterator指针中的end()。但这里不能直接使用iterator，因为输入的是一个listNode类，而不是list<int>类。</p>
<p>此处刚开始遍历时，注意令末尾指针为NULL，也可以代表末尾元素的下一个地址。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* root = recursion(head, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">recursion</span><span class="params">(ListNode* start, ListNode* end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* fast = start;</span><br><span class="line">        ListNode* slow = start;</span><br><span class="line">        <span class="keyword">while</span>(fast!=end &amp;&amp; fast-&gt;next!=end)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = slow-&gt;next;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(slow-&gt;val);</span><br><span class="line">        root-&gt;left = recursion(start, slow);</span><br><span class="line">        root-&gt;right = recursion(slow-&gt;next, end);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-110. Balanced Binary Tree</title>
    <url>/2021/03/30/Leetcode-110-Balanced-Binary-Tree/</url>
    <content><![CDATA[<h1 id="LeetCode-110-Balanced-Binary-Tree"><a href="#LeetCode-110-Balanced-Binary-Tree" class="headerlink" title="LeetCode-110. Balanced Binary Tree"></a>LeetCode-110. Balanced Binary Tree</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as:</p>
<blockquote>
<p>a binary tree in which the depth of the two subtrees of <em>every</em>node never differ by more than 1.</p>
</blockquote>
<p>Example 1:</p>
<p>Given the following tree <code>[3,9,20,null,null,15,7]</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>Return true.</p>
<p>Example 2:</p>
<p>Given the following tree <code>[1,2,2,3,3,null,null,4,4]</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      1</span><br><span class="line">     &#x2F; \</span><br><span class="line">    2   2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   3</span><br><span class="line"> &#x2F; \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure>

<p>Return false.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>还是要求树的深度。本质上是判断树的左右子树深度相差是否小于等于1。这里要注意的是，递归是从底至上return值，如果子树已经不平衡了，则已不满足条件，返回标识符-1，没有必要继续递归下去了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(level(root) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">level</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = level(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = level(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="built_in">abs</span>(left-right);</span><br><span class="line">        <span class="keyword">if</span>(diff&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+max(left, right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二刷补充"><a href="#二刷补充" class="headerlink" title="二刷补充"></a>二刷补充</h2><p>个人这样写更顺。还是无法避免地要求出各子树的深度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">        if(helper(root) &#x3D;&#x3D; -1) return false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int helper(TreeNode* root)&#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        </span><br><span class="line">        int left &#x3D; helper(root-&gt;left);</span><br><span class="line">        int right &#x3D; helper(root-&gt;right);</span><br><span class="line">        if(left &#x3D;&#x3D; -1 || right &#x3D;&#x3D; -1) return -1;</span><br><span class="line">        </span><br><span class="line">        if(abs(left-right) &gt; 1) return -1;</span><br><span class="line">        else return 1+max(left, right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-111. Minimum Depth of Binary Tree</title>
    <url>/2021/03/31/LeetCode-111-Minimum-Depth-of-Binary-Tree/</url>
    <content><![CDATA[<h1 id="LeetCode-111-Minimum-Depth-of-Binary-Tree"><a href="#LeetCode-111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="LeetCode-111. Minimum Depth of Binary Tree"></a>LeetCode-111. Minimum Depth of Binary Tree</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p>Note: A leaf is a node with no children.</p>
<p>Example:</p>
<p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>return its minimum depth = 2</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>注意，这道题不能直接返回min(minDepth(root-&gt;left), minDepth(root-&gt;right))+1。这道题和求树的最大深度不一样。</p>
<p>求树的最大深度代码如下：</p>
<p>求最大深度因为是取max，所以能保证一定会递归到叶子结点。但是取min的话，如果当前节点缺失一边的子节点，则会停止计数，然而实际上没有计算到叶子结点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>本题需要分情况讨论，讨论当前节点有没有左右节点。</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>我的做法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!root-&gt;left &amp;&amp; root-&gt;right)</span><br><span class="line">            <span class="keyword">return</span> minDepth(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!root-&gt;right &amp;&amp; root-&gt;left)</span><br><span class="line">            <span class="keyword">return</span> minDepth(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> min(minDepth(root-&gt;left), minDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更简单的分类讨论：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left) <span class="keyword">return</span> <span class="number">1</span> + minDepth(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;right) <span class="keyword">return</span> <span class="number">1</span> + minDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + min(minDepth(root-&gt;left), minDepth(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>迭代法。<br>使用BFS，寻找最小扩散次数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    int minDepth(TreeNode* root)&#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; q(&#123;root&#125;);</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            res++;</span><br><span class="line">            int size &#x3D; q.size();</span><br><span class="line">            for(int i &#x3D; 0; i &lt; size; i++)&#123;</span><br><span class="line">                TreeNode* curr &#x3D; q.front(); q.pop();</span><br><span class="line">                if(!curr-&gt;left &amp;&amp; !curr-&gt;right) return res;</span><br><span class="line">                if(curr-&gt;left) q.push(curr-&gt;left);</span><br><span class="line">                if(curr-&gt;right) q.push(curr-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return -1;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-114. Flatten Binary Tree to Linked List</title>
    <url>/2021/03/31/LeetCode-114-Flatten-Binary-Tree-to-Linked-List/</url>
    <content><![CDATA[<h1 id="LeetCode-114-Flatten-Binary-Tree-to-Linked-List"><a href="#LeetCode-114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="LeetCode-114. Flatten Binary Tree to Linked List"></a>LeetCode-114. Flatten Binary Tree to Linked List</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   5</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3   4   6</span><br></pre></td></tr></table></figure>

<p>The flattened tree should look like:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure>

<p><a href="https://oj.leetcode.com/problems/flatten-binary-tree-to-linked-list/">click to show hints.</a></p>
<p>Hints:</p>
<p>If you notice carefully in the flattened tree, each node’s right child points to the next node of a pre-order trave</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>先序遍历树，一边遍历，一边更新链表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        TreeNode* dumpy = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        TreeNode* prev = dumpy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            TreeNode* curr = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;right) q.push(curr-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;left) q.push(curr-&gt;left);            </span><br><span class="line">            </span><br><span class="line">            prev-&gt;right = curr;</span><br><span class="line">            prev-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            prev = curr;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        root =  dumpy-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-116. Populating Next Right Pointers in Each Node</title>
    <url>/2021/04/07/LeetCode-116-Populating-Next-Right-Pointers-in-Each-Node/</url>
    <content><![CDATA[<h1 id="LeetCode-116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#LeetCode-116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="LeetCode-116. Populating Next Right Pointers in Each Node"></a>LeetCode-116. Populating Next Right Pointers in Each Node</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>
<p>Initially, all next pointers are set to <code>NULL</code>.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) root-&gt;right-&gt;next = root-&gt;next ? root-&gt;next-&gt;left : <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        connect(root-&gt;left);</span><br><span class="line">        connect(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-117. Populating Next Right Pointers in Each Node ||</title>
    <url>/2021/04/07/LeetCode-117-Populating-Next-Right-Pointers-in-Each-Node/</url>
    <content><![CDATA[<h1 id="LeetCode-117-Populating-Next-Right-Pointers-in-Each-Node"><a href="#LeetCode-117-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="LeetCode-117. Populating Next Right Pointers in Each Node ||"></a>LeetCode-117. Populating Next Right Pointers in Each Node ||</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>
<p>Initially, all next pointers are set to <code>NULL</code>.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        Node* p = root-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left)&#123;</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right)&#123;</span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) root-&gt;left-&gt;next = root-&gt;right ? root-&gt;right : p;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) root-&gt;right-&gt;next = p;</span><br><span class="line">        <span class="comment">//这里必须先遍历右子节点，再遍历左子节点。因为希望在连接当前层节点时，上一层root和root右侧的next指针都已经连接好。这样p才可以定位到正确的位置。如果上层root右侧节点的next指针还没有连好，则p = p-&gt;next会中断，引起错误。</span></span><br><span class="line">        connect(root-&gt;left);        </span><br><span class="line">        connect(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-118. Pascal&#39;s Triangle</title>
    <url>/2021/04/08/LeetCode-118-Pascal-s-Triangle/</url>
    <content><![CDATA[<h1 id="LeetCode-118-Pascal’s-Triangle"><a href="#LeetCode-118-Pascal’s-Triangle" class="headerlink" title="LeetCode-118. Pascal’s Triangle"></a>LeetCode-118. Pascal’s Triangle</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a non-negative integer <em>numRows</em>, generate the first <em>numRows</em> of Pascal’s triangle.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="img"><br>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Given a non-negative integer numRows, generate the first numRows of Pascal<span class="number">&#x27;</span>s triangle.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In Pascal<span class="number">&#x27;</span>s triangle, each number is the sum of the two numbers directly above it.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: <span class="number">5</span></span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">     [<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">   [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-119. Pascal&#39;s Triangle ||</title>
    <url>/2021/04/08/LeetCode-119-Pascal-s-Triangle/</url>
    <content><![CDATA[<h1 id="LeetCode-119-Pascal’s-Triangle"><a href="#LeetCode-119-Pascal’s-Triangle" class="headerlink" title="LeetCode-119. Pascal’s Triangle ||"></a>LeetCode-119. Pascal’s Triangle ||</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a non-negative index <em>k</em> where <em>k</em> ≤ 33, return the <em>k</em>th index row of the Pascal’s triangle.</p>
<p>Note that the row index starts from 0.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="img"><br>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: [1,3,3,1]</span><br></pre></td></tr></table></figure>

<p>Follow up:</p>
<p>Could you optimize your algorithm to use only <em>O</em>(<em>k</em>) extra space?</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>主要是要求O(k)的占用空间不太好想。把握住，每一层的第i个数，和第i-1个数相加，就能形成下一行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">row</span><span class="params">(rowIndex+<span class="number">1</span>)</span></span>;</span><br><span class="line">        row[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=rowIndex; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">                row[j] += row[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> row;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-120. Triangle</title>
    <url>/2021/04/09/LeetCode-120-Triangle/</url>
    <content><![CDATA[<h1 id="LeetCode-120-Triangle"><a href="#LeetCode-120-Triangle" class="headerlink" title="LeetCode-120. Triangle"></a>LeetCode-120. Triangle</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>
<p>For example, given the following triangle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>The minimum path sum from top to bottom is <code>11</code> (i.e., 2 + 3 + 5 + 1 = 11).</p>
<p>Note:<br>Bonus point if you are able to do this using only <em>O</em>(<em>n</em>) extra space, where <em>n</em> is the total number of rows in the triangle.</p>
<h2 id="Soution"><a href="#Soution" class="headerlink" title="Soution"></a>Soution</h2><p>典型的动态规划题，要记住学会建立二维数组，对每一点都动态规划到。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;prices.size(); i++)&#123;</span><br><span class="line">            start = min(start, prices[i]);</span><br><span class="line">            res = max(res, prices[i]-start);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-121. Best Time to Buy and Sell Stock</title>
    <url>/2021/04/09/LeetCode-121-Best-Time-to-Buy-and-Sell-Stock/</url>
    <content><![CDATA[<h1 id="LeetCode-121-Best-Time-to-Buy-and-Sell-Stock"><a href="#LeetCode-121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="LeetCode-121. Best Time to Buy and Sell Stock"></a>LeetCode-121. Best Time to Buy and Sell Stock</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>只遍历一遍数组，不断更新最小的买入点start，res保留最大的收益值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;prices.size(); i++)&#123;</span><br><span class="line">            start = min(start, prices[i]);</span><br><span class="line">            res = max(res, prices[i]-start);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-122. Best Time to Buy and Sell Stock ||</title>
    <url>/2021/04/10/LeetCode-122-Best-Time-to-Buy-and-Sell-Stock/</url>
    <content><![CDATA[<h1 id="LeetCode-122-Best-Time-to-Buy-and-Sell-Stock"><a href="#LeetCode-122-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="LeetCode-122. Best Time to Buy and Sell Stock ||"></a>LeetCode-122. Best Time to Buy and Sell Stock ||</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>涨的话就一直持有，所以今天只要比昨天价高，就将今天-昨天的利润加入res。跌的话，当卖掉了，不做res的修改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i<span class="number">-1</span>])&#123;</span><br><span class="line">                res += prices[i]-prices[i<span class="number">-1</span>];   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-125. Valid Palindrome</title>
    <url>/2021/04/10/LeetCode-125-Valid-Palindrome/</url>
    <content><![CDATA[<h1 id="LeetCode-125-Valid-Palindrome"><a href="#LeetCode-125-Valid-Palindrome" class="headerlink" title="LeetCode-125. Valid Palindrome"></a>LeetCode-125. Valid Palindrome</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Given a <span class="built_in">string</span>, determine <span class="keyword">if</span> it is a palindrome, considering only alphanumeric characters <span class="keyword">and</span> ignoring cases.</span><br><span class="line"></span><br><span class="line">For example,</span><br><span class="line"><span class="string">&quot;A man, a plan, a canal: Panama&quot;</span> is a palindrome.</span><br><span class="line"><span class="string">&quot;race a car&quot;</span> is <span class="keyword">not</span> a palindrome.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line">Have you consider that the <span class="built_in">string</span> might be empty? This is a good question to ask during an interview.</span><br><span class="line"></span><br><span class="line">For the purpose of <span class="keyword">this</span> problem, we define empty <span class="built_in">string</span> as valid palindrome.</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>主要注意一下ASC||码中，大写字母+32 = 小写字母。且大写字母和小写字母的码之间差了一些其他符号，不是紧密相连。</p>
<p>判断一个char是不是字母或数字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAlphaNum</span><span class="params">(<span class="keyword">char</span> &amp;ch)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&#x27;a&#x27;</span>&lt;=ch &amp;&amp; ch&lt;=<span class="string">&#x27;z&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&#x27;A&#x27;</span>&lt;=ch &amp;&amp; ch&lt;=<span class="string">&#x27;Z&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&#x27;0&#x27;</span>&lt;=ch &amp;&amp; ch&lt;=<span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意一下当小写字母和大写字母当作相等时的写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = s.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(s[i])) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(s[j])) &#123;</span><br><span class="line">                j--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这样写是错误的，因为有可能出现数字+32=字母。比如0的ASC||为48，P的ASC||为80</span></span><br><span class="line">            <span class="comment">/*if (s[i] == s[j] || s[i] + 32 == s[j] || s[j] + 32 == s[i]) &#123;</span></span><br><span class="line"><span class="comment">                    i++;</span></span><br><span class="line"><span class="comment">                    j--;</span></span><br><span class="line"><span class="comment">                    continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            else &#123;</span></span><br><span class="line"><span class="comment">                return false;</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            <span class="keyword">if</span>((s[i]+<span class="number">32</span>-<span class="string">&#x27;a&#x27;</span>)%<span class="number">32</span> != (s[j]+<span class="number">32</span>-<span class="string">&#x27;a&#x27;</span>)%<span class="number">32</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Two Pointers</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-129. Sum Root to Leaf Numbers</title>
    <url>/2021/04/12/LeetCode-129-Sum-Root-to-Leaf-Numbers/</url>
    <content><![CDATA[<h1 id="LeetCode-129-Sum-Root-to-Leaf-Numbers"><a href="#LeetCode-129-Sum-Root-to-Leaf-Numbers" class="headerlink" title="LeetCode-129. Sum Root to Leaf Numbers"></a>LeetCode-129. Sum Root to Leaf Numbers</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree containing digits from <code>0-9</code> only, each root-to-leaf path could represent a number.</p>
<p>An example is the root-to-leaf path <code>1-&gt;2-&gt;3</code> which represents the number <code>123</code>.</p>
<p>Find the total sum of all root-to-leaf numbers.</p>
<p>Note: A leaf is a node with no children.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">Output: 25</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 1-&gt;2 represents the number 12.</span><br><span class="line">The root-to-leaf path 1-&gt;3 represents the number 13.</span><br><span class="line">Therefore, sum &#x3D; 12 + 13 &#x3D; 25.</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [4,9,0,5,1]</span><br><span class="line">    4</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9   0</span><br><span class="line"> &#x2F; \</span><br><span class="line">5   1</span><br><span class="line">Output: 1026</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.</span><br><span class="line">The root-to-leaf path 4-&gt;0 represents the number 40.</span><br><span class="line">Therefore, sum &#x3D; 495 + 491 + 40 &#x3D; 1026.</span><br></pre></td></tr></table></figure>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        recursion(root, <span class="built_in">std</span>::to_string(root-&gt;val), res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recursion</span><span class="params">(TreeNode* root, <span class="built_in">string</span> num, <span class="keyword">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> num_ = atoi(num.c_str());</span><br><span class="line">            res = res + num_;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            <span class="built_in">string</span> str_ = <span class="built_in">std</span>::to_string(root-&gt;left-&gt;val);</span><br><span class="line">            <span class="built_in">string</span> num_l = num + str_;</span><br><span class="line">            recursion(root-&gt;left, num_l, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            <span class="built_in">string</span> str_ = <span class="built_in">std</span>::to_string(root-&gt;right-&gt;val);</span><br><span class="line">            <span class="built_in">string</span> num_r = num + str_;</span><br><span class="line">            recursion(root-&gt;right, num_r, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-130 Surrounded Regions</title>
    <url>/2021/04/12/LeetCode-130-Surrounded-Regions/</url>
    <content><![CDATA[<h1 id="LeetCode-130-Surrounded-Regions"><a href="#LeetCode-130-Surrounded-Regions" class="headerlink" title="LeetCode-130 Surrounded Regions"></a>LeetCode-130 Surrounded Regions</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a 2D board containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code>(the letter O), capture all regions surrounded by <code>&#39;X&#39;</code>.</p>
<p>A region is captured by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>

<p>After running your function, the board should be:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>

<p>Explanation:</p>
<p>Surrounded regions shouldn’t be on the border, which means that any <code>&#39;O&#39;</code> on the border of the board are not flipped to <code>&#39;X&#39;</code>. Any <code>&#39;O&#39;</code> that is not on the border and it is not connected to an <code>&#39;O&#39;</code> on the border will be flipped to <code>&#39;X&#39;</code>. Two cells are connected if they are adjacent cells connected horizontally or vertically.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>大体思路比较简单，主要要想到用什么方式做四领域遍历比较好。</p>
<p>若边缘含有’O’，则从此点开始遍历。遇到‘O’，将其设为’#’，表示此点的’O’不应变为’X’。遍历完后，将’O’变为’X’，’#’’变为’O’。</p>
<p>注意board为vector&lt;vector<char>&gt;类型，因此应用’O’，而不是’#’。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;board[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((j == <span class="number">0</span> || j == board[<span class="number">0</span>].size()<span class="number">-1</span> || i ==<span class="number">0</span> || i == board.size()<span class="number">-1</span>) &amp;&amp; board[i][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                  dfs(i,j,board);  </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;board.size(); i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;board[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="comment">//注意，这两句话不能交换顺序！若是先#-&gt;O,则会进而执行O-&gt;X</span></span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>) board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;#&#x27;</span>) board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">            board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;board.size()<span class="number">-1</span> &amp;&amp; board[i+<span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                dfs(i+<span class="number">1</span>, j, board);</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; board[i<span class="number">-1</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                dfs(i<span class="number">-1</span>, j, board);</span><br><span class="line">            <span class="keyword">if</span>(j&lt;board[<span class="number">0</span>].size()<span class="number">-1</span> &amp;&amp; board[i][j+<span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">               dfs(i, j+<span class="number">1</span>, board);</span><br><span class="line">            <span class="keyword">if</span>(j&gt;<span class="number">0</span> &amp;&amp; board[i][j<span class="number">-1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">               dfs(i, j<span class="number">-1</span>, board);</span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-131. Palindrome Partitioning</title>
    <url>/2021/04/13/LeetCode-131-Palindrome-Partitioning/</url>
    <content><![CDATA[<h1 id="LeetCode-131-Palindrome-Partitioning"><a href="#LeetCode-131-Palindrome-Partitioning" class="headerlink" title="LeetCode-131. Palindrome Partitioning"></a>LeetCode-131. Palindrome Partitioning</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p>
<p>Return all possible palindrome partitioning of <em>s</em>.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;aab&quot;</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="Soution"><a href="#Soution" class="headerlink" title="Soution"></a>Soution</h2><p>经典的回溯写法。记住这种out.push_back-&gt;dfs-&gt;out.pop_back()的写法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; out;</span><br><span class="line">        dfs(res, s, out, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp;res, <span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; out, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == s.size())&#123;</span><br><span class="line">            res.push_back(out);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isPalindrome(s, start, i)) <span class="keyword">continue</span>;</span><br><span class="line">            out.push_back(s.substr(start, i-start+<span class="number">1</span>));</span><br><span class="line">            dfs(res, s, out, i+<span class="number">1</span>);</span><br><span class="line">            out.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[start]!=s[end]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Backtracking</category>
      </categories>
      <tags>
        <tag>Leecode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-133. Clone Graph</title>
    <url>/2021/04/13/LeetCode-133-Clone-Graph/</url>
    <content><![CDATA[<h1 id="LeetCode-133-Clone-Graph"><a href="#LeetCode-133-Clone-Graph" class="headerlink" title="LeetCode-133. Clone Graph"></a>LeetCode-133. Clone Graph</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a reference of a node in a <a href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph">connected</a> undirected graph, return a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy">deep copy</a> (clone) of the graph. Each node in the graph contains a val (<code>int</code>) and a list (<code>List[Node]</code>) of its neighbors.</p>
<p>Example:</p>
<p><img src="https://assets.leetcode.com/uploads/2019/02/19/113_sample.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">&#123;&quot;$id&quot;:&quot;1&quot;,&quot;neighbors&quot;:[&#123;&quot;$id&quot;:&quot;2&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;1&quot;&#125;,&#123;&quot;$id&quot;:&quot;3&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&#123;&quot;$id&quot;:&quot;4&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;3&quot;&#125;,&#123;&quot;$ref&quot;:&quot;1&quot;&#125;],&quot;val&quot;:4&#125;],&quot;val&quot;:3&#125;],&quot;val&quot;:2&#125;,&#123;&quot;$ref&quot;:&quot;4&quot;&#125;],&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Node 1&#39;s value is 1, and it has two neighbors: Node 2 and 4.</span><br><span class="line">Node 2&#39;s value is 2, and it has two neighbors: Node 1 and 3.</span><br><span class="line">Node 3&#39;s value is 3, and it has two neighbors: Node 2 and 4.</span><br><span class="line">Node 4&#39;s value is 4, and it has two neighbors: Node 1 and 3.</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>The number of nodes will be between 1 and 100.</li>
<li>The undirected graph is a <a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)#Simple_graph">simple graph</a>, which means no repeated edges and no self-loops in the graph.</li>
<li>Since the graph is undirected, if node <em>p</em> has node <em>q</em> as neighbor, then node <em>q</em> must have node <em>p</em> as neighbor too.</li>
<li>You must return the copy of the given node as a reference to the cloned graph.</li>
</ol>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>deep copy &amp; shallow copy</p>
<p>以python语法为例</p>
<p>（1）a=b，则a，b都指向同一个对象</p>
<p>（2）浅拷贝，b=a.copy()，则b新建了一个对象，但这个对象的子对象还是和a同一个对象。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br><span class="line">b = a.copy()</span><br><span class="line">a[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line">&gt;&gt;a</span><br><span class="line">&#123;<span class="number">1</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]&#125;</span><br><span class="line">&gt;&gt;b</span><br><span class="line">&#123;<span class="number">1</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（3）深拷贝，b = copy.deepcopy(a)，b完全拷贝了a的父对象及子对象，b和a完全独立。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br><span class="line">b = a.copy()</span><br><span class="line">a[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line">&gt;&gt;a</span><br><span class="line">&#123;<span class="number">1</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]&#125;</span><br><span class="line">&gt;&gt;b</span><br><span class="line">&#123;<span class="number">1</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h4><p>DFS写法。clone-&gt;neighbors.push_back(helper(neighbor, m))时候，进入当前点的neigbor的dfs遍历。</p>
<p>(1)Node只有在遍历到的时候会被加入hash_map。故而若hash_map中存在Node，则说明其已经被遍历过，neighbors已经连好，可以直接将其加入clone的neighbors中。但如果Node没有在hash_map中，我们希望它的拷贝先连接好neighbors，再加入clone的neighbors中，于是对Node进行dfs。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; m;</span><br><span class="line">        <span class="keyword">return</span> dfs(node, m);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Node* <span class="title">dfs</span><span class="params">(Node* curr, <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt;&amp; m)</span></span>&#123;</span><br><span class="line">        Node* clone = <span class="keyword">new</span> Node(curr-&gt;val);</span><br><span class="line">        m[curr] = clone;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n : curr-&gt;neighbors)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.count(n)) clone-&gt;neighbors.push_back(m[n]);</span><br><span class="line">            <span class="keyword">else</span> clone-&gt;neighbors.push_back(dfs(n, m));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h4><p>BFS写法。</p>
<p>（1）q.front()的点curr拿出来，并将其neighbors Node一个个进行克隆，加入queue。</p>
<p>（2）<b>注意</b>:</p>
<p>​    此处queue中维护的都是已经进行复制的节点，当且仅当节点被复制时才会加入queue。只不过queue中节点还未与neighbors连接。所以若curr的某neighbor Node已经在hash_map中出现，则说明其已经被复制过，即已经被加入了queue中，无需重复加入，否在会导致无限循环！！！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; m;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">        q.push(node);</span><br><span class="line">        Node* clone = <span class="keyword">new</span> Node(node-&gt;val);</span><br><span class="line">        m[node] = clone;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            Node* curr = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> n : curr-&gt;neighbors)&#123;</span><br><span class="line">                <span class="comment">//如果存在m.count(n),则说明n已经被加进过队列，不用重复加入了。所以只要将不在hash表中的node加入队列即可</span></span><br><span class="line">                <span class="keyword">if</span>(!m.count(n))&#123;</span><br><span class="line">                    Node* new_node = <span class="keyword">new</span> Node(n-&gt;val);</span><br><span class="line">                    m[n] = new_node;</span><br><span class="line">                    q.push(n);</span><br><span class="line">                &#125;</span><br><span class="line">                m[curr]-&gt;neighbors.push_back(m[n]);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m[node];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>DFS</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-134. Gas Station</title>
    <url>/2021/04/16/LeetCode-134-Gas-Station/</url>
    <content><![CDATA[<h1 id="LeetCode-134-Gas-Station"><a href="#LeetCode-134-Gas-Station" class="headerlink" title="LeetCode-134. Gas Station"></a>LeetCode-134. Gas Station</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>There are <em>N</em> gas stations along a circular route, where the amount of gas at station <em>i</em> is <code>gas[i]</code>.</p>
<p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from station <em>i</em> to its next station (<em>i</em>+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1.</p>
<p>Note:<br>The solution is guaranteed to be unique.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = gas.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = help(gas, cost, i);</span><br><span class="line">            <span class="keyword">if</span>(index &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">help</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">cos</span>, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = gas.size();</span><br><span class="line">        <span class="keyword">int</span> initial = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> gas_have = gas[i];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> gas_cost = <span class="built_in">cos</span>[i];</span><br><span class="line">            <span class="keyword">if</span>(gas_have &gt;= gas_cost)&#123;</span><br><span class="line">                i = (i+<span class="number">1</span>)%N;</span><br><span class="line">                gas_have = gas_have - gas_cost + gas[i];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(i == initial)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Greedy</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-136. Single Number</title>
    <url>/2021/04/16/LeetCode-136-Single-Number/</url>
    <content><![CDATA[<h1 id="LeetCode-136-Single-Number"><a href="#LeetCode-136-Single-Number" class="headerlink" title="LeetCode-136. Single Number"></a>LeetCode-136. Single Number</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>方法一：哈希表法。第一次出现-&gt;加入哈希表；第二次出现-&gt;从哈希表中移除。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; iset;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(iset.count(nums[i])) iset.erase(nums[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                iset.insert(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *iset.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法二：位运算法</p>
<p>用异或位运算法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">            res ^= num;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Hash Table</category>
        <category>Bit Manipulation</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-137. Single Number||</title>
    <url>/2021/04/16/LeetCode-137-Single-Number/</url>
    <content><![CDATA[<h1 id="LeetCode-137-Single-Number"><a href="#LeetCode-137-Single-Number" class="headerlink" title="LeetCode-137. Single Number||"></a>LeetCode-137. Single Number||</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a non-empty array of integers, every element appears <em>three</em> times except for one, which appears exactly once. Find that single one.</p>
<p>Note:</p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,2,3,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [0,1,0,1,0,1,99]</span><br><span class="line">Output: 99</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">32</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num :nums)&#123;</span><br><span class="line">                <span class="comment">//注意加括号，防止计算顺序出错</span></span><br><span class="line">                sum = sum + ((num&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res = res | ( (sum%<span class="number">3</span>)&lt;&lt;i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Hash Table</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-138. Copy List with Random Pointer</title>
    <url>/2021/04/16/LeetCode-138-Copy-List-with-Random-Pointer/</url>
    <content><![CDATA[<h1 id="LeetCode-138-Copy-List-with-Random-Pointer"><a href="#LeetCode-138-Copy-List-with-Random-Pointer" class="headerlink" title="LeetCode-138. Copy List with Random Pointer"></a>LeetCode-138. Copy List with Random Pointer</h1><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy">deep copy</a> of the list.</p>
<p>Example 1:</p>
<p><img src="https://discuss.leetcode.com/uploads/files/1470150906153-2yxeznm.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">&#123;&quot;$id&quot;:&quot;1&quot;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;next&quot;:null,&quot;random&quot;:&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&quot;val&quot;:2&#125;,&quot;random&quot;:&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Node 1&#39;s value is 1, both of its next and random pointer points to Node 2.</span><br><span class="line">Node 2&#39;s value is 2, its next pointer points to null and its random pointer points to itself.</span><br></pre></td></tr></table></figure>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>哈希+一遍遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;Node*, Node*&gt; m;</span><br><span class="line">        Node* dumpy = <span class="keyword">new</span> Node(<span class="number">-1</span>);</span><br><span class="line">        Node* curr = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">            Node* new_curr = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span>(!m.count(curr))&#123;</span><br><span class="line">                new_curr = <span class="keyword">new</span> Node(curr-&gt;val, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">                m[curr] = new_curr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">               new_curr = m[curr];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!dumpy-&gt;next) dumpy-&gt;next = new_curr;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;next)&#123;</span><br><span class="line">                <span class="keyword">if</span>(m.count(curr-&gt;next))</span><br><span class="line">                    new_curr-&gt;next = m[curr-&gt;next];</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    Node* new_next = <span class="keyword">new</span> Node(curr-&gt;next-&gt;val, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">                    new_curr-&gt;next = new_next;</span><br><span class="line">                    m[curr-&gt;next] = new_next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;random)&#123;</span><br><span class="line">                <span class="keyword">if</span>(m.count(curr-&gt;random))</span><br><span class="line">                    new_curr-&gt;random = m[curr-&gt;random];</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    Node* new_random = <span class="keyword">new</span> Node(curr-&gt;random-&gt;val, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">                    new_curr-&gt;random = new_random;</span><br><span class="line">                    m[curr-&gt;random] = new_random;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dumpy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;Node*, Node*&gt; m;</span><br><span class="line">        <span class="keyword">return</span> help(head, m);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function">Node* <span class="title">help</span><span class="params">(Node* node, <span class="built_in">map</span>&lt;Node*, Node*&gt;&amp; m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(m.count(node)) <span class="keyword">return</span> m[node];</span><br><span class="line">        </span><br><span class="line">        Node* new_node = <span class="keyword">new</span> Node(node-&gt;val);</span><br><span class="line">        m[node] = new_node;</span><br><span class="line">        </span><br><span class="line">        new_node-&gt;next = help(node-&gt;next, m);</span><br><span class="line">        new_node-&gt;random = help(node-&gt;random, m);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> new_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Hash Table</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-139. Word Break</title>
    <url>/2021/04/17/LeetCode-139-Word-Break/</url>
    <content><![CDATA[<h1 id="LeetCode-139-Word-Break"><a href="#LeetCode-139-Word-Break" class="headerlink" title="LeetCode-139. Word Break"></a>LeetCode-139. Word Break</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a non-empty string <em>s</em> and a dictionary <em>wordDict</em> containing a list of non-empty words, determine if <em>s</em> can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p>Note:</p>
<ul>
<li>The same word in the dictionary may be reused multiple times in the segmentation.</li>
<li>You may assume the dictionary does not contain duplicate words.</li>
</ul>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.</span><br><span class="line">             Note that you are allowed to reuse a dictionary word.</span><br></pre></td></tr></table></figure>

<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h4><p>首先想到回溯法，但是超过时间限制。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">wordSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> help(<span class="number">0</span>, s, wordSet);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span> start, <span class="built_in">string</span>&amp; s, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&amp; wordSet)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(wordSet.count(s.substr(start, s.size()-start)))</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size()-start+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> out = s.substr(start, i);</span><br><span class="line">            <span class="keyword">if</span>(wordSet.count(out))&#123;</span><br><span class="line">                <span class="keyword">int</span> res = help(i+start, s, wordSet);</span><br><span class="line">                <span class="keyword">if</span>(res) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>回溯法中加一个memo数组，用来存储已经计算过的情况。例如，memo[i]表示i~s.size()-1是否可拆分的情况。memo[i]=0：不可拆；memo[i] = 1：可拆；memo[i] = -1：还未计算。</p>
<h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h4><p>动态规划法。dp[i]表示字符0～i-1是否能分割（dp多建立了一位，为了让遍历方便开始，有点像dumpy节点）。</p>
<p>求dp[i]的时候，dp[0]<del>dp[i-1]都已经求得了，所以求的时候用j在0～i-1之间的字符串进行切割，形成0～j-1和j～i-1。0～j对应dp[j]，j</del>i-1对应s.substr(j, i-1)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">wordSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(s.size()+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;s.size()+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &amp;&amp; wordSet.count(s.substr(j, i-j)))&#123;</span><br><span class="line">                    dp[i] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Backtracking</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-141. Linked List Cycle</title>
    <url>/2021/04/17/LeetCode-141-Linked-List-Cycle/</url>
    <content><![CDATA[<h1 id="LeetCode-141-Linked-List-Cycle"><a href="#LeetCode-141-Linked-List-Cycle" class="headerlink" title="LeetCode-141. Linked List Cycle"></a>LeetCode-141. Linked List Cycle</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a linked list, determine if it has a cycle in it.</p>
<p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>快慢指针。如果有环，最有一个节点的next指针指向空。如果无环，fast节点总会与slow节点相遇。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Two Pointers</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-142. Linked List Cycle｜｜</title>
    <url>/2021/04/19/LeetCode-142-Linked-List-Cycle%EF%BD%9C%EF%BD%9C/</url>
    <content><![CDATA[<h1 id="LeetCode-142-Linked-List-Cycle｜｜"><a href="#LeetCode-142-Linked-List-Cycle｜｜" class="headerlink" title="LeetCode-142. Linked List Cycle｜｜"></a>LeetCode-142. Linked List Cycle｜｜</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p>
<p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p>
<p>Note: Do not modify the linked list.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">Output: tail connects to node index 1</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">Output: tail connects to node index 0</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the first node.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">Output: no cycle</span><br><span class="line">Explanation: There is no cycle in the linked list.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>依然是快慢指针追赶问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!fast || !fast-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Linked List</category>
        <category>Two Pointers</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-143. Reorder List</title>
    <url>/2021/04/19/LeetCode-143-Reorder-List/</url>
    <content><![CDATA[<h1 id="LeetCode-143-Reorder-List"><a href="#LeetCode-143-Reorder-List" class="headerlink" title="LeetCode-143. Reorder List"></a>LeetCode-143. Reorder List</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a singly linked list <em>L</em>: <em>L</em>0→<em>L</em>1→…→<em>L**n</em>-1→<em>L</em>n,<br>reorder it to: <em>L</em>0→<em>L**n</em>→<em>L</em>1→<em>L**n</em>-1→<em>L</em>2→<em>L**n</em>-2→…</p>
<p>You may not modify the values in the list’s nodes, only nodes itself may be changed.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3.</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>快慢指针找中点-&gt;后半截入栈-&gt;从head和栈top开始交替连接结点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* prev = head;</span><br><span class="line">        <span class="comment">//找中间点</span></span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123;</span><br><span class="line">            prev = slow;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)</span><br><span class="line">                <span class="keyword">break</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        prev = slow;</span><br><span class="line">        <span class="keyword">if</span>(slow-&gt;next)</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; _stack;</span><br><span class="line">        <span class="comment">//断开中间点</span></span><br><span class="line">        prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从中间点后一个点开始入栈</span></span><br><span class="line">        <span class="keyword">while</span>(slow)&#123;</span><br><span class="line">            _stack.push(slow);</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交替连接点</span></span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span>(!_stack.empty())&#123;</span><br><span class="line">            ListNode* nextNode = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;next)</span><br><span class="line">                nextNode = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = _stack.top();</span><br><span class="line">            _stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(nextNode)&#123;</span><br><span class="line">                curr-&gt;next-&gt;next = nextNode;</span><br><span class="line">                curr = nextNode;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                curr-&gt;next-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>全部入栈，栈可以直接求出大小，于是找到中点。在到达终点前head和栈top开始交替插入节点。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Linked List</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-144. Binary Tree Preorder Traversal</title>
    <url>/2021/04/20/LeetCode-144-Binary-Tree-Preorder-Traversal/</url>
    <content><![CDATA[<h1 id="LeetCode-144-Binary-Tree-Preorder-Traversal"><a href="#LeetCode-144-Binary-Tree-Preorder-Traversal" class="headerlink" title="LeetCode-144. Binary Tree Preorder Traversal"></a>LeetCode-144. Binary Tree Preorder Traversal</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>前序遍历，根-&gt;左-&gt;右</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>递归法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        help(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        help(root-&gt;left,res);</span><br><span class="line">        help(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>迭代法。用栈。弹出栈顶-&gt;栈顶元素加入res-&gt;右节点入栈-&gt;左节点入栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">            st.push(root);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            TreeNode* n = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            res.push_back(n-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(n-&gt;right) st.push(n-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(n-&gt;left) st.push(n-&gt;left);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-145. Binary Tree Postorder Traversal</title>
    <url>/2021/04/20/LeetCode-145-Binary-Tree-Postorder-Traversal/</url>
    <content><![CDATA[<h1 id="LeetCode-145-Binary-Tree-Postorder-Traversal"><a href="#LeetCode-145-Binary-Tree-Postorder-Traversal" class="headerlink" title="LeetCode-145. Binary Tree Postorder Traversal"></a>LeetCode-145. Binary Tree Postorder Traversal</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, return the <em>postorder</em> traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree <code>&#123;1,#,2,3&#125;</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> &#x2F;</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>return <code>[3,2,1]</code>.</p>
<p><strong>Note:</strong> Recursive solution is trivial, could you do it iteratively?</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>递归法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        help(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        help(root-&gt;left, res);</span><br><span class="line">        help(root-&gt;right, res);</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>迭代法。</p>
<p>后序遍历顺序：左-&gt;右-&gt;根</p>
<p>我们每次都将节点加在res最前端，所以遍历顺序变为根-&gt;右-&gt;左。</p>
<p>因为先遍历根，所以和前序遍历很像。</p>
<p>去栈顶-&gt;加入res最前端-&gt;左节点入栈-&gt;右节点入栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">            st.push(root);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            TreeNode* n = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            res.insert(res.begin(), n-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(n-&gt;left) st.push(n-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(n-&gt;right) st.push(n-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-148. Sort List</title>
    <url>/2021/04/21/LeetCode-148-Sort-List/</url>
    <content><![CDATA[<h1 id="LeetCode-148-Sort-List"><a href="#LeetCode-148-Sort-List" class="headerlink" title="LeetCode-148. Sort List"></a>LeetCode-148. Sort List</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Sort a linked list in <em>O</em>(<em>n</em> log <em>n</em>) time using constant space complexity.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">Output: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* prev = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            prev = slow;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merge(sortList(head), sortList(slow));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        ListNode *dumpy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode *curr = dumpy;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Linked List</category>
        <category>Divide &amp; Conquer</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-151. Reverse Words in a String</title>
    <url>/2021/04/21/LeetCode-151-Reverse-Words-in-a-String/</url>
    <content><![CDATA[<h1 id="LeetCode-151-Reverse-Words-in-a-String"><a href="#LeetCode-151-Reverse-Words-in-a-String" class="headerlink" title="LeetCode-151. Reverse Words in a String"></a>LeetCode-151. Reverse Words in a String</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an input string, reverse the string word by word.</p>
<p>For example,<br>Given s = “<code>the sky is blue</code>“,<br>return “<code>blue is sky the</code>“.</p>
<p><strong>Update (2015-02-12):</strong><br>For C programmers: Try to solve it <em>in-place</em> in <em>O</em>(1) space.</p>
<p><a href="https://leetcode.com/problems/reverse-words-in-a-string/">click to show clarification.</a></p>
<p><strong>Clarification:</strong></p>
<ul>
<li>What constitutes a word?<br>A sequence of non-space characters constitutes a word.</li>
<li>Could the input string contain leading or trailing spaces?<br>Yes. However, your reversed string should not contain leading or trailing spaces.</li>
<li>How about multiple spaces between two words?<br>Reduce them to a single space in the reversed string.</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>利用字符流</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> tmp;</span><br><span class="line">        is&gt;&gt;s;</span><br><span class="line">        <span class="keyword">while</span>(is&gt;&gt;tmp) s = tmp + <span class="string">&quot; &quot;</span> + s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!s.empty() &amp;&amp; s[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>) s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>先翻转整个字符串，再翻转单个单词</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-152. Maximum Product Subarray</title>
    <url>/2021/04/26/LeetCode-152-Maximum-Product-Subarray/</url>
    <content><![CDATA[<h1 id="LeetCode-152-Maximum-Product-Subarray"><a href="#LeetCode-152-Maximum-Product-Subarray" class="headerlink" title="LeetCode-152. Maximum Product Subarray"></a>LeetCode-152. Maximum Product Subarray</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an integer array <code>nums</code>, find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,3,-2,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [2,3] has the largest product 6.</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [-2,0,-1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The result cannot be 2, because [-2,-1] is not a subarray.</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>此动态规划用到两个dp数组。f[i]：表示子数组[0,i]范围内且一定包含nums[i]的最大子数组乘积；g[i]：表示子数组[0,i]范围内且一定包含nums[i]的最小子数组乘积。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从而f[i]或者g[i]的值一定是f[i-1]*nums[i], g[i-1]*nums[i], nums[i]中的一个</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">g</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        f[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        g[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max_ = f[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            f[i] = max(max(f[i<span class="number">-1</span>]*nums[i], g[i<span class="number">-1</span>]*nums[i]), nums[i]);</span><br><span class="line">            g[i] = min(min(f[i<span class="number">-1</span>]*nums[i], g[i<span class="number">-1</span>]*nums[i]), nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(max_ &lt; f[i])</span><br><span class="line">                max_ = f[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里也可以不用数组，而用单一变量f和g代替f[i]和g[i]，节约内存空间。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-153. Find Minimum in Rotated Sorted Array</title>
    <url>/2021/04/26/LeetCode-153-Find-Minimum-in-Rotated-Sorted-Array/</url>
    <content><![CDATA[<h1 id="LeetCode-153-Find-Minimum-in-Rotated-Sorted-Array"><a href="#LeetCode-153-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="LeetCode-153. Find Minimum in Rotated Sorted Array"></a>LeetCode-153. Find Minimum in Rotated Sorted Array</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e.,  <code>[0,1,2,4,5,6,7]</code> might become  <code>[4,5,6,7,0,1,2]</code>).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,4,5,1,2] </span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [4,5,6,7,0,1,2]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>经典的二分查找变形题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[right])</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid+<span class="number">1</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Binary Search</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-160. Intersection of Two Linked Lists</title>
    <url>/2021/04/27/LeetCode-160-Intersection-of-Two-Linked-Lists/</url>
    <content><![CDATA[<h1 id="LeetCode-160-Intersection-of-Two-Linked-Lists"><a href="#LeetCode-160-Intersection-of-Two-Linked-Lists" class="headerlink" title="LeetCode-160. Intersection of Two Linked Lists"></a>LeetCode-160. Intersection of Two Linked Lists</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>For example, the following two linked lists:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                      ↘</span><br><span class="line">                        c1 → c2 → c3</span><br><span class="line">                      ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure>

<p>begin to intersect at node c1.</p>
<p>Notes:</p>
<ul>
<li>If the two linked lists have no intersection at all, return <code>null</code>.</li>
<li>The linked lists must retain their original structure after the function returns.</li>
<li>You may assume there are no cycles anywhere in the entire linked structure.</li>
<li>Your code should preferably run in O(n) time and use only O(1) memory.</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>两个链表同时遍历，遍历到结尾处，则从另一个链表头重新开始遍历。则最后两个指针将在链表交点相交。若没有交点，同时遍历到链表尾部。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* l1 = headA;</span><br><span class="line">        ListNode* l2 = headB;</span><br><span class="line">        <span class="keyword">if</span>(!l1 || !l2) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l1!=l2)&#123;</span><br><span class="line">            l1 = l1 ? l1-&gt;next : headB;</span><br><span class="line">            l2 = l2 ? l2-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Linked List</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-162. Find Peak Element</title>
    <url>/2021/04/27/LeetCode-162-Find-Peak-Element/</url>
    <content><![CDATA[<h1 id="LeetCode-162-Find-Peak-Element"><a href="#LeetCode-162-Find-Peak-Element" class="headerlink" title="LeetCode-162. Find Peak Element"></a>LeetCode-162. Find Peak Element</h1><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>A peak element is an element that is greater than its neighbors.</p>
<p>Given an input array <code>nums</code>, where <code>nums[i] ≠ nums[i+1]</code>, find a peak element and return its index.</p>
<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>
<p>You may imagine that <code>nums[-1] = nums[n] = -∞</code>.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 3 is a peak element and your function should return the index number 2.</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,1,3,5,6,4]</span><br><span class="line">Output: 1 or 5 </span><br><span class="line">Explanation: Your function can return either index number 1 where the peak element is 2, </span><br><span class="line">             or index number 5 where the peak element is 6.</span><br></pre></td></tr></table></figure>



<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h4><p>因为-1位当作负无限大，所以从curr=0开始。如果next&lt;curr，则curr为峰值，直接return。若curr与next相等，则next一定也不是峰值，next与curr指针都向后移两位。若curr&lt;next，则next可能为峰值，next与curr指针都向后移一位。</p>
<p>即遍历的时候，保证当前curr&gt;prev，则curr只需要与next比较即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(next &lt; nums.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[curr] &gt; nums[next])</span><br><span class="line">                <span class="keyword">return</span> curr;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[curr] == nums[next])&#123;</span><br><span class="line">                curr += <span class="number">2</span>;</span><br><span class="line">                next += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                curr += <span class="number">1</span>;</span><br><span class="line">                next += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(next == nums.size())</span><br><span class="line">            <span class="keyword">return</span> next<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">             <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h4><p>（1）使用二分法查找。因为最后一个元素为负无穷，并且找到一个峰值就可。所以如果当前元素&lt;后一个元素，即代表峰值在当前元素后面。</p>
<p>（2）一些笔记见代码注释</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//注意，如果这里写成</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//这样不加if(nums[mid] == target)语句，实际上break时，left指向的实际是最小的不满足于下面if语句的元素。如果下面语句是if(nums[mid]&lt;target),找到的是第一个大于等于target的元素；如果下面语句是if(nums[mid]&lt;=target)，找到的是第一个大于target的元素。</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid+<span class="number">1</span>])&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Binary Search</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-165. Compare Version Numbers</title>
    <url>/2021/04/29/LeetCode-165-Compare-Version-Numbers/</url>
    <content><![CDATA[<h1 id="LeetCode-165-Compare-Version-Numbers"><a href="#LeetCode-165-Compare-Version-Numbers" class="headerlink" title="LeetCode-165. Compare Version Numbers"></a>LeetCode-165. Compare Version Numbers</h1><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>Compare two version numbers <em>version1</em> and <em>version2</em>.<br>If <code>*version1* &gt; *version2*</code> return <code>1;</code> if <code>*version1* &lt;*version2*</code> return <code>-1;</code>otherwise return <code>0</code>.</p>
<p>You may assume that the version strings are non-empty and contain only digits and the <code>.</code> character.<br>The <code>.</code> character does not represent a decimal point and is used to separate number sequences.<br>For instance, <code>2.5</code> is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: version1 &#x3D; &quot;0.1&quot;, version2 &#x3D; &quot;1.1&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: version1 &#x3D; &quot;1.0.1&quot;, version2 &#x3D; &quot;1&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: version1 &#x3D; &quot;7.5.2.4&quot;, version2 &#x3D; &quot;7.5.3&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>

<p>Credits:<br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>一起遍历两个version，遇到’.’前把数字加入string，遇到了’.’就比较一次aoti(string)的大小。</p>
<p>如果v1或者v2为空，那么atoi(v1.c_str()), atoi(v2.c_str())得到的是什么？？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(<span class="built_in">string</span> version1, <span class="built_in">string</span> version2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = version1.size();</span><br><span class="line">        <span class="keyword">int</span> n = version2.size();</span><br><span class="line">        <span class="built_in">string</span> v1, v2;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m || j&lt;n)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; m &amp;&amp; version1[i] != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                v1.push_back(version1[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; n &amp;&amp; version2[j] != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                v2.push_back(version2[j]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> num1 = atoi(v1.c_str());</span><br><span class="line">            <span class="keyword">int</span> num2 = atoi(v2.c_str());</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(num1 &gt; num2)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num1 &lt; num2)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            </span><br><span class="line">            v1.clear();</span><br><span class="line">            v2.clear();</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-166. Fraction to Recurring Decimal</title>
    <url>/2021/04/29/LeetCode-166-Fraction-to-Recurring-Decimal/</url>
    <content><![CDATA[<h1 id="LeetCode-166-Fraction-to-Recurring-Decimal"><a href="#LeetCode-166-Fraction-to-Recurring-Decimal" class="headerlink" title="LeetCode-166. Fraction to Recurring Decimal"></a>LeetCode-166. Fraction to Recurring Decimal</h1><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.</p>
<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>
<p>For example,</p>
<ul>
<li>Given numerator = 1, denominator = 2, return “0.5”.</li>
<li>Given numerator = 2, denominator = 1, return “2”.</li>
<li>Given numerator = 2, denominator = 3, return “0.(6)”.</li>
</ul>
<p><strong>Credits:</strong><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/Shangrila">@Shangrila</a> for adding this problem and creating all test cases.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>这道题比较麻烦。</p>
<p>（1）按照一般的思路，需要先把正负号提出来，单独判断。但是整数INT类型为-2^31~2^31-1，所以-2^31取abs，会超出INT_MAX = 2^31-1，所以要用long类型存储。</p>
<p>（2）求商：numerator/denominator；求余：numerator%demoniator</p>
<p>（3）map&lt;int, int&gt; reminder_hash中的key为reminder，value为s中出现此reminder的位置，方便加”(“和”)”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; reminder_hash;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> s1 = numerator &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> s2 = denominator &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> num = <span class="built_in">abs</span>(numerator);</span><br><span class="line">        <span class="keyword">long</span> de = <span class="built_in">abs</span>(denominator);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> out = num / de;</span><br><span class="line">        <span class="keyword">long</span> reminder = num % de;</span><br><span class="line">        </span><br><span class="line">        res += to_string(out);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//除了结果为0，都要判断是否要加正负号</span></span><br><span class="line">        <span class="keyword">if</span>(out != <span class="number">0</span> || reminder != <span class="number">0</span>)</span><br><span class="line">            res = s1*s2 == <span class="number">1</span> ? res : <span class="string">&quot;-&quot;</span>+res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(reminder != <span class="number">0</span>)</span><br><span class="line">            res += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//s存储小数部分</span></span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(reminder != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(reminder_hash.count(reminder))&#123;</span><br><span class="line">                s.insert(reminder_hash[reminder],<span class="string">&quot;(&quot;</span>);</span><br><span class="line">                s += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> res + s;</span><br><span class="line">            &#125;</span><br><span class="line">            reminder_hash[reminder] = pos;</span><br><span class="line">            s += to_string(reminder * <span class="number">10</span> / de);</span><br><span class="line">            reminder = (reminder * <span class="number">10</span>) % de;</span><br><span class="line">            </span><br><span class="line">            pos++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res + s;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Hash Table</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-167. Two Sum||-Input array is sorted</title>
    <url>/2021/05/06/LeetCode-167-Two-Sum-Input-array-is-sorted/</url>
    <content><![CDATA[<h1 id="LeetCode-167-Two-Sum-Input-array-is-sorted"><a href="#LeetCode-167-Two-Sum-Input-array-is-sorted" class="headerlink" title="LeetCode-167. Two Sum||-Input array is sorted"></a>LeetCode-167. Two Sum||-Input array is sorted</h1><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.<br>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.<br>You may assume that each input would have exactly one solution.<br>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h4><p>二分查找，时间复杂度o(nlogn)，空间复杂度o(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;numbers.size()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = numbers[i];</span><br><span class="line">            <span class="keyword">int</span> search = target - curr;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> left = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = numbers.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = numbers[(left+right)/<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span>(mid == search)&#123;</span><br><span class="line">                    res[<span class="number">0</span>] = i+<span class="number">1</span>;</span><br><span class="line">                    res[<span class="number">1</span>] = (left+right)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(mid&lt;search)</span><br><span class="line">                    left = (left+right)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right = (left+right)/<span class="number">2</span><span class="number">-1</span>;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Solution-2-双指针"><a href="#Solution-2-双指针" class="headerlink" title="Solution 2 双指针"></a>Solution 2 双指针</h4><p>时间复杂度O(n)，空间复杂度O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = numbers.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[left] + numbers[right];</span><br><span class="line">            <span class="keyword">if</span>(sum == target)</span><br><span class="line">                <span class="keyword">return</span> &#123;left+<span class="number">1</span>, right+<span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                left ++;   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Binary Search</category>
        <category>Two Pointers</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-168. Excel Sheet Column Title</title>
    <url>/2021/05/06/LeetCode-168-Excel-Sheet-Column-Title/</url>
    <content><![CDATA[<h1 id="LeetCode-168-Excel-Sheet-Column-Title"><a href="#LeetCode-168-Excel-Sheet-Column-Title" class="headerlink" title="LeetCode-168. Excel Sheet Column Title"></a>LeetCode-168. Excel Sheet Column Title</h1><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 -&gt; A</span><br><span class="line">2 -&gt; B</span><br><span class="line">3 -&gt; C</span><br><span class="line">...</span><br><span class="line">26 -&gt; Z</span><br><span class="line">27 -&gt; AA</span><br><span class="line">28 -&gt; AB </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: &quot;A&quot;</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 28</span><br><span class="line">Output: &quot;AB&quot;</span><br></pre></td></tr></table></figure>

<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 701</span><br><span class="line">Output: &quot;ZY&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Credits:</strong><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ifanchu">@ifanchu</a> for adding this problem and creating all test cases.</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>从低到高求，最后再反转string</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> columnNumber)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> n = columnNumber;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            res += (--n%<span class="number">26</span>) + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            n = (n++)/<span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-171. Excel Sheet Column Number</title>
    <url>/2021/05/06/LeetCode-171-Excel-Sheet-Column-Number/</url>
    <content><![CDATA[<h1 id="LeetCode-171-Excel-Sheet-Column-Number"><a href="#LeetCode-171-Excel-Sheet-Column-Number" class="headerlink" title="LeetCode-171. Excel Sheet Column Number"></a>LeetCode-171. Excel Sheet Column Number</h1><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Related to question <a href="https://oj.leetcode.com/problems/excel-sheet-column-title/">Excel Sheet Column Title</a></p>
<p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br></pre></td></tr></table></figure>

<p><strong>Credits:</strong><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>可以联系168一起看，比168简单。实质上是把26进制的数转换为十进制的数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(<span class="built_in">string</span> columnTitle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;columnTitle.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = (columnTitle[i]-<span class="string">&#x27;A&#x27;</span>+<span class="number">1</span>);</span><br><span class="line">            res = res*<span class="number">26</span> + curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-169. Majority Element</title>
    <url>/2021/05/06/LeetCode-169-Majority-Element/</url>
    <content><![CDATA[<h1 id="LeetCode-169-Majority-Element"><a href="#LeetCode-169-Majority-Element" class="headerlink" title="LeetCode-169. Majority Element"></a>LeetCode-169. Majority Element</h1><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given an array <code>nums</code> of size <code>n</code>, return <em>the majority element</em>.</p>
<p>The majority element is the element that appears more than <code>⌊n / 2⌋</code> times. You may assume that the majority element always exists in the array.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,2,1,1,1,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p>Constraints:</p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 5 * 104</code></li>
<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
</ul>
<p>Follow-up: Could you solve the problem in linear time and in <code>O(1)</code> space?</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>哈希+存储最多元素</p>
<p>还有分治等其他方法，可以看一下别的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用for (int num : nums)更好</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; dict_;</span><br><span class="line">        <span class="keyword">int</span> max_key = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> max_value = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dict_.count(nums[i]))&#123;</span><br><span class="line">                dict_[nums[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dict_[nums[i]] = <span class="number">1</span>;   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dict_[nums[i]] &gt; max_value)&#123;</span><br><span class="line">                max_key = nums[i];</span><br><span class="line">                max_value = dict_[nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_key;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Hash Table</category>
        <category>Divide &amp; Conquer</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-33. Search in Rotated Sorted Array</title>
    <url>/2021/05/11/LeetCode-33-Search-in-Rotated-Sorted-Array/</url>
    <content><![CDATA[<h1 id="LeetCode-33-Search-in-Rotated-Sorted-Array"><a href="#LeetCode-33-Search-in-Rotated-Sorted-Array" class="headerlink" title="LeetCode-33. Search in Rotated Sorted Array"></a>LeetCode-33. Search in Rotated Sorted Array</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">https://leetcode.com/problems/search-in-rotated-sorted-array/</a></p>
<p>There is an integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong> values).</p>
<p>Prior to being passed to your function, <code>nums</code> is <strong>rotated</strong> at an unknown pivot index <code>k</code> (<code>0 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,5,6,7]</code>might be rotated at pivot index <code>3</code> and become <code>[4,5,6,7,0,1,2]</code>.</p>
<p>Given the array <code>nums</code> <strong>after</strong> the rotation and an integer <code>target</code>, return <em>the index of</em> <code>target</code><em>if it is in</em> <code>nums</code><em>, or</em> <code>-1</code> <em>if it is not in</em> <code>nums</code>.</p>
<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1], target &#x3D; 0</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>（1）比较target和nums[right]，找到递增的是left～mid，还是mid～right</p>
<p>（2）可以想象这样一幅图</p>
<p>![image-20210511202359261](/Users/alice/Library/Application Support/typora-user-images/image-20210511202359261.png)</p>
<p>nums[mid]和right比较，如果nums[mid]在点1位置，则left～mid有序；若在点2的位置，则mid～right有序</p>
<p>（3）if target应该在有序的区间内（target和区间左右端点值比较），缩小范围到有序区间</p>
<p>else 缩小范围到有序区间之外</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size() <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//注意这里是&lt;=</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">//mid～right ascends</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[right])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//nums[mid] == nums[right]?</span></span><br><span class="line">            <span class="comment">//left～mid ascends</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &lt; nums[mid] &amp;&amp; target &gt;= nums[left])</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Binary Search</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-34. Find First and Last Position of Element in Sorted Array</title>
    <url>/2021/05/11/LeetCode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array/</url>
    <content><![CDATA[<h1 id="LeetCode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#LeetCode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="LeetCode-34. Find First and Last Position of Element in Sorted Array"></a>LeetCode-34. Find First and Last Position of Element in Sorted Array</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p>
<p>Given an array of integers <code>nums</code> sorted in ascending order, find the starting and ending position of a given <code>target</code> value.</p>
<p>If <code>target</code> is not found in the array, return <code>[-1, -1]</code>.</p>
<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">Output: [3,4]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [], target &#x3D; 0</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>1、用二分法找到一个target</p>
<p>2、从target开始左右遍历，直到找到starting and ending position</p>
<p>此种方法的问题是，时间复杂度不能保证是O(logn)，比如当数组中所有元素相同时，会变成O(n).</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">int</span> l = mid;</span><br><span class="line">                <span class="keyword">int</span> r = mid;</span><br><span class="line">                <span class="keyword">while</span>(l&gt;=<span class="number">0</span> &amp;&amp; nums[l] == nums[mid])</span><br><span class="line">                    l--;</span><br><span class="line">                <span class="keyword">while</span>(r&lt; nums.size() &amp;&amp; nums[r] == nums[mid])</span><br><span class="line">                    r++;</span><br><span class="line">                <span class="keyword">return</span> &#123;++l, --r&#125;;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>（1）用二分法找两次，一次找左边界，一次找右边界</p>
<p>（2）整体思路较为费劲，需要找两次。</p>
<p>（3）左边界和右边界的写法不同，一个为nums[mid]&lt;target，一个为nums[mid]&lt;=target</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!nums.size()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//找左边界</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//例如[2,2]的案例，left可以会超出数组下界，所以要先判断是否溢出</span></span><br><span class="line">        <span class="keyword">if</span>(left &lt; nums.size() &amp;&amp; nums[left] == target) res[<span class="number">0</span>] = left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> res;</span><br><span class="line">       <span class="comment">//重新初始化right</span></span><br><span class="line">        right = nums.size()<span class="number">-1</span>;</span><br><span class="line">      <span class="comment">//找右边界</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">1</span>] = right;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h3><p>（1）查找第一个大于等于target的位置，即左边界</p>
<p>（2）查找第一个大于等于target+1的位置，即右边界</p>
<p>（3）此种思路其实和Solution2相似，不过统一了写法，更加简单</p>
<p>（4）二分搜索法小结：<a href="https://www.cnblogs.com/grandyang/p/6854825.html%E3%80%82%E6%AD%A4%E9%A2%98%E7%94%A8%E5%88%B0%E4%BA%86%EF%BC%8C%E6%9F%A5%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%B0%8F%E4%BA%8Etarget%E7%9A%84%E6%95%B0%E7%9A%84%E5%86%99%E6%B3%95%E3%80%82">https://www.cnblogs.com/grandyang/p/6854825.html。此题用到了，查找第一个不小于target的数的写法。</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = find(nums, target);</span><br><span class="line">        <span class="keyword">if</span>(start == nums.size() || nums[start] != target) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;start, find(nums, target+<span class="number">1</span>)<span class="number">-1</span>&#125;;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Binary Search</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-4. Median of Two Sorted Arrays</title>
    <url>/2021/05/11/LeetCode-4-Median-of-Two-Sorted-Arrays/</url>
    <content><![CDATA[<h1 id="LeetCode-4-Median-of-Two-Sorted-Arrays"><a href="#LeetCode-4-Median-of-Two-Sorted-Arrays" class="headerlink" title="LeetCode-4. Median of Two Sorted Arrays"></a>LeetCode-4. Median of Two Sorted Arrays</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/submissions/">https://leetcode.com/problems/median-of-two-sorted-arrays/submissions/</a></p>
<p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume nums1 and nums2 cannot be both empty.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1 &#x3D; [1, 3]</span><br><span class="line">nums2 &#x3D; [2]</span><br><span class="line"></span><br><span class="line">The median is 2.0</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1 &#x3D; [1, 2]</span><br><span class="line">nums2 &#x3D; [3, 4]</span><br><span class="line"></span><br><span class="line">The median is (2 + 3)&#x2F;2 &#x3D; 2.5</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>（1） 找出第(m+n+1)/2大的数和第(m+n+2)/2的数，两者的平均即为中位数，无论nums为奇数长还是偶数长</p>
<p>（2）i，j分别为nums1和nums2的指针。0～i-1和0～j-1表示已经验证过的小于中位数的数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.size();</span><br><span class="line">        <span class="keyword">int</span> left = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> right = (m + n + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, left) + findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, right)) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> i, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nums1.size()) <span class="keyword">return</span> nums2[j + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= nums2.size()) <span class="keyword">return</span> nums1[i + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> min(nums1[i], nums2[j]);</span><br><span class="line">        <span class="comment">//-1是因为i，j现在还没有纳入已排除的小于中位数的数中去</span></span><br><span class="line">        <span class="keyword">int</span> midVal1 = (i + k / <span class="number">2</span> - <span class="number">1</span> &lt; nums1.size()) ? nums1[i + k / <span class="number">2</span> - <span class="number">1</span>] : INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> midVal2 = (j + k / <span class="number">2</span> - <span class="number">1</span> &lt; nums2.size()) ? nums2[j + k / <span class="number">2</span> - <span class="number">1</span>] : INT_MAX;</span><br><span class="line">        <span class="keyword">if</span> (midVal1 &lt; midVal2) &#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, i + k / <span class="number">2</span>, nums2, j, k - k / <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, i, nums2, j + k / <span class="number">2</span>, k - k / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Binary Search</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-704. Binary Search</title>
    <url>/2021/05/11/LeetCode-704-Binary-Search/</url>
    <content><![CDATA[<h1 id="LeetCode-704-Binary-Search"><a href="#LeetCode-704-Binary-Search" class="headerlink" title="LeetCode-704. Binary Search"></a>LeetCode-704. Binary Search</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/binary-search/">https://leetcode.com/problems/binary-search/</a></p>
<p>Given a sorted (in ascending order) integer array <code>nums</code> of <code>n</code> elements and a <code>target</code> value, write a function to search <code>target</code> in <code>nums</code>. If <code>target</code> exists, then return its index, otherwise return <code>-1</code>.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: 9 exists in nums and its index is 4</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: 2 does not exist in nums so return -1</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>You may assume that all elements in <code>nums</code> are unique.</li>
<li><code>n</code> will be in the range <code>[1, 10000]</code>.</li>
<li>The value of each element in <code>nums</code> will be in the range <code>[-9999, 9999]</code>.</li>
</ol>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>(1）right = num.size()-1</p>
<p>(2) left = mid + 1; right = mid - 1;</p>
<p>(3) while(left &lt;= right)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right )/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Binary Search</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-74. Search a 2D Matrix</title>
    <url>/2021/05/11/LeetCode-74-Search-a-2D-Matrix/</url>
    <content><![CDATA[<h1 id="LeetCode-74-Search-a-2D-Matrix"><a href="#LeetCode-74-Search-a-2D-Matrix" class="headerlink" title="LeetCode-74. Search a 2D Matrix"></a>LeetCode-74. Search a 2D Matrix</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/search-a-2d-matrix/">https://leetcode.com/problems/search-a-2d-matrix/</a></p>
<p>Write an efficient algorithm that searches for a value in an <code>m x n</code> matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted from left to right.</li>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target &#x3D; 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target &#x3D; 13</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>把二维数组看作一维，直接转换坐标</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> right = m*n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> i = mid / n;</span><br><span class="line">            <span class="keyword">int</span> j = mid % n;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>做两次二分查找，一次找到相应的行，一次找到相应的列</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Binary Search</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-81 Search in Rotated Sorted Array ||</title>
    <url>/2021/05/11/LeetCode-81-Search-in-Rotated-Sorted-Array-0/</url>
    <content><![CDATA[<h1 id="LeetCode-81-Search-in-Rotated-Sorted-Array"><a href="#LeetCode-81-Search-in-Rotated-Sorted-Array" class="headerlink" title="LeetCode-81 Search in Rotated Sorted Array ||"></a>LeetCode-81 Search in Rotated Sorted Array ||</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/">https://leetcode.com/problems/search-in-rotated-sorted-array-ii/</a></p>
<p>相关题目：33</p>
<p>There is an integer array <code>nums</code> sorted in non-decreasing order (not necessarily with <strong>distinct</strong>values).</p>
<p>Before being passed to your function, <code>nums</code> is <strong>rotated</strong> at an unknown pivot index <code>k</code> (<code>0 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,4,4,5,6,6,7]</code> might be rotated at pivot index <code>5</code> and become <code>[4,5,6,6,7,0,1,2,4,4]</code>.</p>
<p>Given the array <code>nums</code> <strong>after</strong> the rotation and an integer <code>target</code>, return <code>true</code> <em>if</em> <code>target</code> <em>is in</em> <code>nums</code><em>, or</em> <code>false</code> <em>if it is not in</em> <code>nums</code><em>.</em></p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>（1）此题不同于33题的地方在于nums中有元素相等，故而nums[mid]与nums[right]相比较，无法得出有序的区间在哪里。</p>
<p>如下图，nums[mid]=nums[right]时，</p>
<p>若mid为点1，有序区间为left～mid。</p>
<p>若mid为点2， 有序区间为mid～right</p>
<p>（2）为了判断有序区间，需要进行right–，直到nums[mid]!=nums[right]。</p>
<p>![image-20210511203748232](/Users/alice/Library/Application Support/typora-user-images/image-20210511203748232.png)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//nums[mid]==nums[right]的时候，无法确定哪边有序，如target=3时，[1,1,3,1]，[3,1,1]。则将right--，直到nums[mid]!=nums[right]</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == nums[right])&#123;</span><br><span class="line">                <span class="keyword">while</span>(right &gt;= left &amp;&amp; nums[mid] == nums[right])</span><br><span class="line">                      right--;</span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[right])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &lt; nums[mid] &amp;&amp; target &gt;= nums[left])</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Binary Search</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - Binary Search总汇</title>
    <url>/2021/05/11/LeetCode-Binary-Search%E6%80%BB%E6%B1%87/</url>
    <content><![CDATA[<h1 id="LeetCode-Binary-Search总汇"><a href="#LeetCode-Binary-Search总汇" class="headerlink" title="LeetCode - Binary Search总汇"></a>LeetCode - Binary Search总汇</h1><h2 id="Solved-List"><a href="#Solved-List" class="headerlink" title="Solved List"></a>Solved List</h2><p>参考索引</p>
<p>胖头龙：<a href="https://www.1point3acres.com/bbs/forum.php?mod=viewthread&amp;tid=678970&amp;extra=&amp;authorid=682747&amp;page=1">https://www.1point3acres.com/bbs/forum.php?mod=viewthread&amp;tid=678970&amp;extra=&amp;authorid=682747&amp;page=1</a></p>
<h3 id="1、-朴素二分法"><a href="#1、-朴素二分法" class="headerlink" title="1、 朴素二分法"></a>1、 朴素二分法</h3><p><font color=#9932CC>704. Binary Search</font></p>
<p><a href="https://leetcode.com/problems/binary-search/">https://leetcode.com/problems/binary-search/</a></p>
<p><font color=#0000FF>34. Find First and Last Postition of Element in Sorted Array</font></p>
<p><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p>
<h3 id="2、条件二分法"><a href="#2、条件二分法" class="headerlink" title="2、条件二分法"></a>2、条件二分法</h3><p><font color=#9932CC>33. Search in Rotated Sorted Array</font></p>
<p><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">https://leetcode.com/problems/search-in-rotated-sorted-array/</a></p>
<p><font color=#9932CC>81. Search in Rotated Sorted Array ||</font></p>
<p><a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/">https://leetcode.com/problems/search-in-rotated-sorted-array-ii/</a></p>
<p><font color=#0000FF>74. Search a 2D Matrix</font></p>
<p><a href="https://leetcode.com/problems/search-a-2d-matrix/">https://leetcode.com/problems/search-a-2d-matrix/</a></p>
<p><font color=#0000FF>4. Median of Two Sorted Arrays</font></p>
<p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/">https://leetcode.com/problems/median-of-two-sorted-arrays/</a></p>
<p><font color=#0000FF>162. Find Peak Element</font></p>
<p><a href="https://leetcode.com/problems/find-peak-element/">https://leetcode.com/problems/find-peak-element/</a></p>
<h3 id="3、答案二分法"><a href="#3、答案二分法" class="headerlink" title="3、答案二分法"></a>3、答案二分法</h3><p><font color=#9932CC>875. Koko Eating Bananas</font></p>
<p><a href="https://leetcode.com/problems/koko-eating-bananas/">https://leetcode.com/problems/koko-eating-bananas/</a></p>
<p><font color=#9932CC>1283. Find the Smallest Divisor Given a Threshold</font></p>
<p><a href="https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/">https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/</a></p>
<h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2>]]></content>
      <categories>
        <category>Leetcode</category>
        <category>总汇</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1283. Find the Smallest Divisor Given a Threshold</title>
    <url>/2021/05/13/LeetCode-1283-Find-the-Smallest-Divisor-Given-a-Threshold/</url>
    <content><![CDATA[<h1 id="LeetCode-1283-Find-the-Smallest-Divisor-Given-a-Threshold"><a href="#LeetCode-1283-Find-the-Smallest-Divisor-Given-a-Threshold" class="headerlink" title="LeetCode-1283. Find the Smallest Divisor Given a Threshold"></a>LeetCode-1283. Find the Smallest Divisor Given a Threshold</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/">https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/</a></p>
<p>Given an array of integers <code>nums</code> and an integer <code>threshold</code>, we will choose a positive integer <code>divisor</code>, divide all the array by it, and sum the division’s result. Find the <strong>smallest</strong> <code>divisor</code> such that the result mentioned above is less than or equal to <code>threshold</code>.</p>
<p>Each result of the division is rounded to the nearest integer greater than or equal to that element. (For example: <code>7/3 = 3</code> and <code>10/2 = 5</code>).</p>
<p>It is guaranteed that there will be an answer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,5,9], threshold &#x3D; 6</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. </span><br><span class="line">If the divisor is 4 we can get a sum of 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). </span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [44,22,33,11,1], threshold &#x3D; 5</span><br><span class="line">Output: 44</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [21212,10101,12121], threshold &#x3D; 1000000</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,5,7,11], threshold &#x3D; 11</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5 * 104</code></li>
<li><code>1 &lt;= nums[i] &lt;= 106</code></li>
<li><code>nums.length &lt;= threshold &lt;= 106</code></li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">smallestDivisor</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1e6</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums) r += (num % mid==<span class="number">0</span>) ? num/mid : num/mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(r &gt;threshold)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Binary Search</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-875. Koko Eating Bananas</title>
    <url>/2021/05/13/LeetCode-875-Koko-Eating-Bananas/</url>
    <content><![CDATA[<h1 id="LeetCode-875-Koko-Eating-Bananas"><a href="#LeetCode-875-Koko-Eating-Bananas" class="headerlink" title="LeetCode-875. Koko Eating Bananas"></a>LeetCode-875. Koko Eating Bananas</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/koko-eating-bananas/">https://leetcode.com/problems/koko-eating-bananas/</a></p>
<p>相似题目：1283. <a href="https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/">https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/</a></p>
<p>Koko loves to eat bananas. There are <code>n</code> piles of bananas, the <code>ith</code> pile has <code>piles[i]</code> bananas. The guards have gone and will come back in <code>h</code> hours.</p>
<p>Koko can decide her bananas-per-hour eating speed of <code>k</code>. Each hour, she chooses some pile of bananas and eats <code>k</code> bananas from that pile. If the pile has less than <code>k</code> bananas, she eats all of them instead and will not eat any more bananas during this hour.</p>
<p>Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return.</p>
<p>Return <em>the minimum integer</em> <code>k</code> <em>such that she can eat all the bananas within</em> <code>h</code><em>hours</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: piles &#x3D; [3,6,7,11], h &#x3D; 8</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: piles &#x3D; [30,11,23,4,20], h &#x3D; 5</span><br><span class="line">Output: 30</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: piles &#x3D; [30,11,23,4,20], h &#x3D; 6</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= piles.length &lt;= 104</code></li>
<li><code>piles.length &lt;= h &lt;= 109</code></li>
<li><code>1 &lt;= piles[i] &lt;= 109</code></li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>（1）其实是一个遍历的思路，答案的范围为[1, 10^9]，故而从这个范围内搜索满足条件的k</p>
<p>cn（2）注意for(auto pile : piles)的写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1e9</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> pile : piles) time += (mid + pile - <span class="number">1</span>) / mid;</span><br><span class="line">            <span class="keyword">if</span>(time &gt; h)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Binary Search</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-26. Remove Duplicates from Sorted Array</title>
    <url>/2021/05/14/LeetCode-26-Remove-Duplicates-from-Sorted-Array/</url>
    <content><![CDATA[<h1 id="LeetCode-26-Remove-Duplicates-from-Sorted-Array"><a href="#LeetCode-26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="LeetCode-26. Remove Duplicates from Sorted Array"></a>LeetCode-26. Remove Duplicates from Sorted Array</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">https://leetcode.com/problems/remove-duplicates-from-sorted-array/</a></p>
<p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> such that each element appears only <em>once</em> and returns the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> with O(1) extra memory.</p>
<p><strong>Clarification:</strong></p>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means a modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len &#x3D; removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; any modification to nums in your function would be known by the caller.</span><br><span class="line">&#x2F;&#x2F; using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,2]</span><br><span class="line">Output: 2, nums &#x3D; [1,2]</span><br><span class="line">Explanation: Your function should return length &#x3D; 2, with the first two elements of nums being 1 and 2 respectively. It doesn&#39;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">Output: 5, nums &#x3D; [0,1,2,3,4]</span><br><span class="line">Explanation: Your function should return length &#x3D; 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively. It doesn&#39;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>(1)显然使用双指针</p>
<p>(2)重点在于corner case的写法</p>
<p>(3) nums[++prev] = nums[curr++]这一句巧妙地将prev先+1，再赋值。也可以写成swap(nums[++prev], nums[curr++])，但没必要</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curr &lt; nums.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[curr] == nums[prev]) curr++;</span><br><span class="line">            <span class="keyword">else</span> nums[++prev] = nums[curr++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums.empty() ? <span class="number">0</span> : prev+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Array</category>
        <category>Two Pointers</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-283. Move Zeros</title>
    <url>/2021/05/14/LeetCode-283-Move-Zeros/</url>
    <content><![CDATA[<h1 id="LeetCode-283-Move-Zeros"><a href="#LeetCode-283-Move-Zeros" class="headerlink" title="LeetCode-283. Move Zeros"></a>LeetCode-283. Move Zeros</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an integer array <code>nums</code>, move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p><strong>Note</strong> that you must do this in-place without making a copy of the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1,0,3,12]</span><br><span class="line">Output: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>（1）curr指针用来搜索非零的位置，将其与prev指针指的位置互换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(curr &lt; nums.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[curr]) swap(nums[curr], nums[prev++]);</span><br><span class="line">            curr++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Array</category>
        <category>Two Pointers</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-75. Sort Colors</title>
    <url>/2021/05/13/LeetCode-75-Sort-Colors/</url>
    <content><![CDATA[<h1 id="LeetCode-75-Sort-Colors"><a href="#LeetCode-75-Sort-Colors" class="headerlink" title="LeetCode-75. Sort Colors"></a>LeetCode-75. Sort Colors</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/sort-colors/">https://leetcode.com/problems/sort-colors/</a></p>
<p>Given an array <code>nums</code> with <code>n</code> objects colored red, white, or blue, sort them <strong><a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> so that objects of the same color are adjacent, with the colors in the order red, white, and blue.</p>
<p>We will use the integers <code>0</code>, <code>1</code>, and <code>2</code> to represent the color red, white, and blue, respectively.</p>
<p>You must solve this problem without using the library’s sort function.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,0,2,1,1,0]</span><br><span class="line">Output: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,0,1]</span><br><span class="line">Output: [0,1,2]</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 300</code></li>
<li><code>nums[i]</code> is <code>0</code>, <code>1</code>, or <code>2</code>.</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>利用counting sort</p>
<p>（1）时间复杂度：O(n+k)；（k是否为3？？）；空间复杂度：O(3)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">3</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums) count[num]++;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count.size(); i++)</span><br><span class="line">            <span class="keyword">while</span>(count[i]--&gt;<span class="number">0</span>)</span><br><span class="line">                nums[k++] = i;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（2）双指针</p>
<p>（不是很懂）<br>（1） i表示当前位置，left指针的左边均为0，right指针的右边均为2。<br>（2）当i遇到0的时候，将其和left交换。因为left&lt;=i，所以交换时，换的只能为1（如果为0，则已经并入left左侧；如果为2，则已经与right交换了）。故而之后i正常++。<br>（3）当i遇到2的时候，将其和right交换，因为right&gt;=i，都还没有遍历过，所以交换过来的可能为0，1，2，需要再次确认这个值要不要继续交换，因而i不能增。所以是swap(nums[right–], nums[i–]);</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size()<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= right; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>) swap(nums[left++],nums[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">2</span>) swap(nums[right--], nums[i--]);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Two Pointers</category>
        <category>Sort</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-80. Remove Duplicates from Sorted Array ||</title>
    <url>/2021/05/14/LeetCode-80-Remove-Duplicates-from-Sorted-Array/</url>
    <content><![CDATA[<h1 id="LeetCode-80-Remove-Duplicates-from-Sorted-Array"><a href="#LeetCode-80-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="LeetCode-80. Remove Duplicates from Sorted Array ||"></a>LeetCode-80. Remove Duplicates from Sorted Array ||</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/">https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/</a></p>
<p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> such that duplicates appeared at most <em>twice</em> and return the new length.</p>
<p>Do not allocate extra space for another array; you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> with O(1) extra memory.</p>
<p><strong>Clarification:</strong></p>
<p>Confused why the returned value is an integer, but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means a modification to the input array will be known to the caller.</p>
<p>Internally you can think of this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len &#x3D; removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; any modification to nums in your function would be known by the caller.</span><br><span class="line">&#x2F;&#x2F; using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,1,2,2,3]</span><br><span class="line">Output: 5, nums &#x3D; [1,1,2,2,3]</span><br><span class="line">Explanation: Your function should return length &#x3D; 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively. It doesn&#39;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [0,0,1,1,1,1,2,3,3]</span><br><span class="line">Output: 7, nums &#x3D; [0,0,1,1,2,3,3]</span><br><span class="line">Explanation: Your function should return length &#x3D; 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively. It doesn&#39;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>（1）和26题相比，增加一个count变量，记录当前元素出现的次数</p>
<p>（2）重难点在于如何分类讨论</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//count为prev所指元素已出现个数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(curr &lt; nums.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[prev] == nums[curr] &amp;&amp; count==<span class="number">2</span>) curr++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[prev] == nums[curr])</span><br><span class="line">                    count++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                nums[++prev] = nums[curr++];</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.empty() ? <span class="number">0</span> : prev + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Array</category>
        <category>Two Pointers</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-912. Sort an Array</title>
    <url>/2021/05/13/LeetCode-912-Sort-an-Array/</url>
    <content><![CDATA[<h1 id="LeetCode-912-Sort-an-Array"><a href="#LeetCode-912-Sort-an-Array" class="headerlink" title="LeetCode-912. Sort an Array"></a>LeetCode-912. Sort an Array</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/sort-an-array/">https://leetcode.com/problems/sort-an-array/</a></p>
<p>Given an array of integers <code>nums</code>, sort the array in ascending order.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [5,2,3,1]</span><br><span class="line">Output: [1,2,3,5]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [5,1,1,2,0,0]</span><br><span class="line">Output: [0,0,1,1,2,5]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5 * 104</code></li>
<li><code>-5 * 104 &lt;= nums[i] &lt;= 5 * 104</code></li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>（1）counting sort</p>
<p>（2）count的大小为nums的范围大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">5e4</span>+<span class="number">5e4</span>+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums) count[num+<span class="number">5e4</span>]++;  </span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(count[i]--&gt;<span class="number">0</span>) nums[k++] = i<span class="number">-5e4</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Sort</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-21. Merge Two Sorted Lists</title>
    <url>/2021/05/17/LeetCode-21-Merge-Two-Sorted-Lists/</url>
    <content><![CDATA[<h1 id="LeetCode-21-Merge-Two-Sorted-Lists"><a href="#LeetCode-21-Merge-Two-Sorted-Lists" class="headerlink" title="LeetCode-21. Merge Two Sorted Lists"></a>LeetCode-21. Merge Two Sorted Lists</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/merge-two-sorted-lists/">https://leetcode.com/problems/merge-two-sorted-lists/</a></p>
<p>Merge two sorted linked lists and return it as a <strong>sorted</strong> list. The list should be made by splicing together the nodes of the first two lists.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</span><br><span class="line">Output: [1,1,2,3,4,4]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: l1 &#x3D; [], l2 &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: l1 &#x3D; [], l2 &#x3D; [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>双指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* dumpy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* curr = dumpy;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)&#123;</span><br><span class="line">                curr-&gt;next = l1;</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                curr-&gt;next = l2;</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1) curr-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span>(l2) curr-&gt;next = l2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dumpy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Linked List</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-215. Kth Largest Element in an Array</title>
    <url>/2021/05/17/LeetCode-215-Kth-Largest-Element-in-an-Array/</url>
    <content><![CDATA[<h1 id="LeetCode-215-Kth-Largest-Element-in-an-Array"><a href="#LeetCode-215-Kth-Largest-Element-in-an-Array" class="headerlink" title="LeetCode-215. Kth Largest Element in an Array"></a>LeetCode-215. Kth Largest Element in an Array</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>kth</code> <em>largest element in the array</em>.</p>
<p>Note that it is the <code>kth</code> largest element in the sorted order, not the <code>kth</code> distinct element.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,1,5,6,4], k &#x3D; 2</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,3,1,2,4,5,5,6], k &#x3D; 4</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= nums.length &lt;= 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>直接从大到小排序，取第k个</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos = quickSort(nums, start, end);   </span><br><span class="line">            <span class="keyword">if</span>(pos == k<span class="number">-1</span>) <span class="keyword">return</span> nums[pos];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pos &gt; k<span class="number">-1</span>) end = pos<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> start = pos+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[start];</span><br><span class="line">        <span class="keyword">int</span> left = start+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = end;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] &lt; pivot &amp;&amp; nums[right] &gt; pivot)</span><br><span class="line">                swap(nums[left++], nums[right--]);</span><br><span class="line">            <span class="keyword">if</span>(nums[left] &gt;= pivot) left++;</span><br><span class="line">            <span class="keyword">if</span>(nums[right] &lt;= pivot) right--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[right], nums[start]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Divide &amp; Conquer</category>
        <category>Sort</category>
        <category>Heap</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-347. Top K Frequent Elements</title>
    <url>/2021/05/17/LeetCode-347-Top-K-Frequent-Elements/</url>
    <content><![CDATA[<h1 id="LeetCode-347-Top-K-Frequent-Elements"><a href="#LeetCode-347-Top-K-Frequent-Elements" class="headerlink" title="LeetCode-347. Top K Frequent Elements"></a>LeetCode-347. Top K Frequent Elements</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k</code> <em>most frequent elements</em>. You may return the answer in <strong>any order</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1], k &#x3D; 1</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>k</code> is in the range <code>[1, the number of unique elements in the array]</code>.</li>
<li>It is <strong>guaranteed</strong> that the answer is <strong>unique</strong>.</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>（1）使用priority_queue（会priority_queue的写法）</p>
<p>（2）先用unordered_map统计个数字数目，再将其放入priority_queue中按照出现次数排序</p>
<p>（3）从priority_queue中pop出前k个数</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; p;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums) m[num]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n : m) p.push(&#123;n.second, n.first&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">            res.push_back(p.top().second);</span><br><span class="line">            p.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>（1）桶排序（但似乎不是完整的桶排序？）</p>
<p>（2）同样使用unordered_map统计，但是将结果存放在bucket二维vector中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k )</span></span>&#123;</span><br><span class="line">      <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; bucket(nums.size()+<span class="number">1</span>);</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums) m[num]++;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> it : m) bucket[it.second].push_back(it.first);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.size(); i &gt;=<span class="number">0</span> ;i--)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket[i].size(); j++)&#123;</span><br><span class="line">              res.push_back(bucket[i][j]);</span><br><span class="line">              <span class="keyword">if</span>(res.size() == k) <span class="keyword">return</span> res;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Hash Table</category>
        <category>Heap</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-349. Intersection of Two Arrays</title>
    <url>/2021/05/17/LeetCode-349-Intersection-of-Two-Arrays/</url>
    <content><![CDATA[<h1 id="LeetCode-349-Intersection-of-Two-Arrays"><a href="#LeetCode-349-Intersection-of-Two-Arrays" class="headerlink" title="LeetCode-349. Intersection of Two Arrays"></a>LeetCode-349. Intersection of Two Arrays</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their intersection</em>. Each element in the result must be <strong>unique</strong> and you may return the result in <strong>any order</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">Output: [2]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">Output: [9,4]</span><br><span class="line">Explanation: [4,9] is also accepted.</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>使用两个set</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        set&lt;int&gt; iset(nums1.begin(), nums1.end());</span><br><span class="line">        set&lt;int&gt; iset2(nums2.begin(), nums2.end());</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        </span><br><span class="line">        for(auto s : iset2)&#123;</span><br><span class="line">            if(iset.count(s))</span><br><span class="line">                res.push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Binary Search</category>
        <category>Two Pointers</category>
        <category>Hash Table</category>
        <category>Sort</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-350. Intersection of Two Arrays｜｜</title>
    <url>/2021/05/17/LeetCode-350-Intersection-of-Two-Arrays%EF%BD%9C%EF%BD%9C/</url>
    <content><![CDATA[<h1 id="LeetCode-350-Intersection-of-Two-Arrays｜｜"><a href="#LeetCode-350-Intersection-of-Two-Arrays｜｜" class="headerlink" title="LeetCode-350. Intersection of Two Arrays｜｜"></a>LeetCode-350. Intersection of Two Arrays｜｜</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their intersection</em>. Each element in the result must appear as many times as it shows in both arrays and you may return the result in <strong>any order</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">Output: [2,2]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">Output: [4,9]</span><br><span class="line">Explanation: [9,4] is also accepted.</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>（1）使用两个unordered_map</p>
<p>（2）找出两个map中共有的key，并在res中加入n个key值，n位两个map中更小的value</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m1, m2;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums1) m1[num]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums2) m2[num]++;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m2.begin();</span><br><span class="line">        <span class="keyword">for</span>(; it!=m2.end(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m1.count(it-&gt;first))&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min(m1[it-&gt;first], it-&gt;second); i++)</span><br><span class="line">                    res.push_back(it-&gt;first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>（1）把两个数组都排序</p>
<p>（2）使用双指针，一个指针指向一个数组，每次将指向的值更小的指针向后移。若找到相等的值，则在res中加入，并向后移两个指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        sort(nums1.begin(), nums1.end());</span><br><span class="line">        sort(nums2.begin(), nums2.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(p1 &lt; nums1.size() &amp;&amp; p2 &lt; nums2.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[p1] &lt; nums2[p2]) p1++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums1[p1] &gt; nums2[p2]) p2++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res.push_back(nums1[p1]);</span><br><span class="line">                p1++;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Binary Search</category>
        <category>Two Pointers</category>
        <category>Hash Table</category>
        <category>Sort</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-42. Trapping Rain Water</title>
    <url>/2021/05/17/LeetCode-42-Trapping-Rain-Water/</url>
    <content><![CDATA[<h1 id="LeetCode-42-Trapping-Rain-Water"><a href="#LeetCode-42-Trapping-Rain-Water" class="headerlink" title="LeetCode-42. Trapping Rain Water"></a>LeetCode-42. Trapping Rain Water</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/trapping-rain-water/">https://leetcode.com/problems/trapping-rain-water/</a></p>
<p>Given <em>n</em> non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" alt="img"><br>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>（1）使用stack，遇到比st.top大的入栈</p>
<p>（2）遇到比st.top小的，出栈top。若此时st不为空，则可形成水洼。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trap(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        stack&lt;int&gt; st;</span><br><span class="line">        int i &#x3D; 0, res &#x3D; 0;</span><br><span class="line">        while(i&lt;height.size())&#123;</span><br><span class="line">            if(st.empty() || height[i] &lt;&#x3D; height[st.top()])&#123;</span><br><span class="line">                st.push(i++);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                int t &#x3D; st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                if(st.empty()) continue;</span><br><span class="line">                res +&#x3D; (min(height[i], height[st.top()])-height[t]) * (i - st.top() -  1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Dynamic Programming</category>
        <category>Stack</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-43. Multiply Strings</title>
    <url>/2021/05/17/LeetCode-43-Multiply-Strings/</url>
    <content><![CDATA[<h1 id="LeetCode-43-Multiply-Strings"><a href="#LeetCode-43-Multiply-Strings" class="headerlink" title="LeetCode-43. Multiply Strings"></a>LeetCode-43. Multiply Strings</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/multiply-strings/">https://leetcode.com/problems/multiply-strings/</a></p>
<p>Given two non-negative integers <code>num1</code> and <code>num2</code>represented as strings, return the product of <code>num1</code> and <code>num2</code>, also represented as a string.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: num1 &#x3D; &quot;2&quot;, num2 &#x3D; &quot;3&quot;</span><br><span class="line">Output: &quot;6&quot;</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: num1 &#x3D; &quot;123&quot;, num2 &#x3D; &quot;456&quot;</span><br><span class="line">Output: &quot;56088&quot;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>The length of both <code>num1</code> and <code>num2</code> is &lt; 110.</li>
<li>Both <code>num1</code> and <code>num2</code> contain only digits <code>0-9</code>.</li>
<li>Both <code>num1</code> and <code>num2</code> do not contain any leading zero, except the number 0 itself.</li>
<li>You must not use any built-in BigInteger libraryor convert the inputs to integer directly.</li>
</ol>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>（1）长m和长n的数组相乘，其积&lt;=m+n。</p>
<p>（2）建立一个m+n长度的vector，用来保存乘积的各位</p>
<p>（3）num1[i]*nums[j]，得到的乘积应该存储在vector中的p1=i+j，p2=i+j+1位。</p>
<p>（4）注意，v[p2] = sum%10，而不是v[p2] += sum%10</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = num1.size();</span><br><span class="line">        <span class="keyword">int</span> n = num2.size();</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(m+n, <span class="number">0</span>)</span></span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> mul = (num1[i]-<span class="string">&#x27;0&#x27;</span>) * (num2[j]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="keyword">int</span> p1 = i+j, p2 = i+j+<span class="number">1</span>, sum = mul + v[p2];</span><br><span class="line">                v[p1] += sum/<span class="number">10</span>;</span><br><span class="line">                v[p2] = sum%<span class="number">10</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val : v)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.empty() &amp;&amp; val==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            res.push_back(val+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.empty() ? <span class="string">&quot;0&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>String</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-845. Longest Mountain in Array</title>
    <url>/2021/05/17/LeetCode-845-Longest-Mountain-in-Array/</url>
    <content><![CDATA[<h1 id="LeetCode-845-Longest-Mountain-in-Array"><a href="#LeetCode-845-Longest-Mountain-in-Array" class="headerlink" title="LeetCode-845. Longest Mountain in Array"></a>LeetCode-845. Longest Mountain in Array</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/longest-mountain-in-array/">https://leetcode.com/problems/longest-mountain-in-array/</a></p>
<p>You may recall that an array <code>arr</code> is a <strong>mountain array</strong> if and only if:</p>
<ul>
<li><p><code>arr.length &gt;= 3</code></p>
</li>
<li><p>There exists some index</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i</span><br></pre></td></tr></table></figure>

<p>(0-indexed) with</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt; i &lt; arr.length - 1</span><br></pre></td></tr></table></figure>

<p>such that:</p>
<ul>
<li><code>arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]</code></li>
<li><code>arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code></li>
</ul>
</li>
</ul>
<p>Given an integer array <code>arr</code>, return <em>the length of the longest subarray, which is a mountain</em>. Return <code>0</code> if there is no mountain subarray.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: arr &#x3D; [2,1,4,7,3,2,5]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The largest mountain is [1,4,7,3,2] which has length 5.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: arr &#x3D; [2,2,2]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no mountain.</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>（1）按照mountain的形状，找到起始点i，最高点peak，末端end</p>
<p>（2）若i&lt;peak&lt;j，则找到一个mountain</p>
<p>（3）与现有最大length的mountain比较</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestMountain(vector&lt;int&gt;&amp; arr) &#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        int n &#x3D; arr.size();</span><br><span class="line">        while(i &lt; n-1)&#123;</span><br><span class="line">            while(i &lt; n-1 &amp;&amp; arr[i] &gt;&#x3D; arr[i+1])</span><br><span class="line">                i++;</span><br><span class="line">            int peak &#x3D; i;</span><br><span class="line">            while(peak &lt; n-1 &amp;&amp; arr[peak] &lt; arr[peak+1])</span><br><span class="line">                peak++;</span><br><span class="line">            int j &#x3D; peak;</span><br><span class="line">            while(j &lt; n-1 &amp;&amp; arr[j] &gt; arr[j+1])</span><br><span class="line">                j++;</span><br><span class="line">            if(i &lt; peak &amp;&amp; peak &lt; j) res &#x3D; max(res, j-i+1);</span><br><span class="line">            i &#x3D; j;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Two Pointers</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-234. Palindrome Linked List</title>
    <url>/2021/05/18/LeetCode-234-Palindrome-Linked-List/</url>
    <content><![CDATA[<h1 id="LeetCode-234-Palindrome-Linked-List"><a href="#LeetCode-234-Palindrome-Linked-List" class="headerlink" title="LeetCode-234. Palindrome Linked List"></a>LeetCode-234. Palindrome Linked List</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given the <code>head</code> of a singly linked list, return <code>true</code> if it is a palindrome.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,2,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>（1）使用stack。将List中的元素全部放入stack</p>
<p>（2）重头再遍历一遍List，一边遍历，一遍与出栈元素比较，看是否相等</p>
<p>（3）空间复杂度O(n)</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>（1）空间复杂度O(1)</p>
<p>（2）fast，slow指针找中点。</p>
<p>（3）将中点后的链表反转</p>
<p>（4）一首一尾开始一一比较</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* prev = slow;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            prev = slow;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* head2 = slow;</span><br><span class="line">        prev = slow;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(slow)&#123;</span><br><span class="line">            ListNode* t = slow-&gt;next; </span><br><span class="line">            slow-&gt;next = prev;</span><br><span class="line">            prev = slow;</span><br><span class="line">            slow = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里从中间点head后面的节点开始反转。head为两边反向链表的中间点，要记得将其next设为NULL</span></span><br><span class="line">        head2-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curr!=head2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;val != prev-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Linked List</category>
        <category>Two Pointers</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-328. Odd Even Linked List</title>
    <url>/2021/05/18/LeetCode-328-Odd-Even-Linked-List/</url>
    <content><![CDATA[<h1 id="LeetCode-328-Odd-Even-Linked-List"><a href="#LeetCode-328-Odd-Even-Linked-List" class="headerlink" title="LeetCode-328. Odd Even Linked List"></a>LeetCode-328. Odd Even Linked List</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p> Given the <code>head</code> of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return <em>the reordered list</em>.</p>
<p>The <strong>first</strong> node is considered <strong>odd</strong>, and the <strong>second</strong> node is <strong>even</strong>, and so on.</p>
<p>Note that the relative order inside both the even and odd groups should remain as it was in the input.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4,5]</span><br><span class="line">Output: [1,3,5,2,4]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven2-linked-list.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [2,1,3,5,6,4,7]</span><br><span class="line">Output: [2,3,6,7,1,5,4]</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>（1）用count记录index</p>
<p>（2）两个链表，一个链接even index node，一个链接odd index node</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummpy1 = <span class="keyword">new</span> ListNode(<span class="number">-1</span>), *h1 = dummpy1;</span><br><span class="line">        ListNode* dummpy2 = <span class="keyword">new</span> ListNode(<span class="number">-1</span>), *h2 = dummpy2;</span><br><span class="line">        </span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count%<span class="number">2</span>) &#123;</span><br><span class="line">                h1-&gt;next = curr;</span><br><span class="line">                h1 = h1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                h2-&gt;next = curr;</span><br><span class="line">                h2 = h2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">            count++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        h2-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        h1-&gt;next = dummpy2-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummpy1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Linked List</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-345. Reverse Vowels of a String</title>
    <url>/2021/05/20/LeetCode-345-Reverse-Vowels-of-a-String/</url>
    <content><![CDATA[<h1 id="LeetCode-345-Reverse-Vowels-of-a-String"><a href="#LeetCode-345-Reverse-Vowels-of-a-String" class="headerlink" title="LeetCode-345. Reverse Vowels of a String"></a>LeetCode-345. Reverse Vowels of a String</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/">https://leetcode.com/problems/reverse-vowels-of-a-string/</a></p>
<p>Given a string <code>s</code>, reverse only all the vowels in the string and return it.</p>
<p>The vowels are <code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, and <code>&#39;u&#39;</code>, and they can appear in both cases.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;hello&quot;</span><br><span class="line">Output: &quot;holle&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;leetcode&quot;</span><br><span class="line">Output: &quot;leotcede&quot;</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>Two Pointers+hash map</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseVowels</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ia[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;U&#x27;</span>&#125;;</span><br><span class="line">        <span class="function"><span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; <span class="title">iset</span><span class="params">(ia, ia+<span class="number">10</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = s.size()<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; !iset.count(s[i])) i++;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; !iset.count(s[j])) j--;</span><br><span class="line">            swap(s[i++], s[j--]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Palindrome</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-5. Longest Palindromic Substring</title>
    <url>/2021/05/20/LeetCode-5-Longest-Palindromic-Substring/</url>
    <content><![CDATA[<h1 id="LeetCode-5-Longest-Palindromic-Substring"><a href="#LeetCode-5-Longest-Palindromic-Substring" class="headerlink" title="LeetCode-5. Longest Palindromic Substring"></a>LeetCode-5. Longest Palindromic Substring</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a string <code>s</code>, return <em>the longest palindromic substring</em> in <code>s</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;a&quot;</span><br><span class="line">Output: &quot;a&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;ac&quot;</span><br><span class="line">Output: &quot;a&quot;</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>（1）对每一个元素，向左右遍历，查看是不是回文</p>
<p>（2）用start和maxLen记录最大回文的位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;s.size()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            searchPalidrome(s, i, i, start, maxLen);</span><br><span class="line">            searchPalidrome(s, i, i+<span class="number">1</span>, start, maxLen);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.substr(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">searchPalidrome</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>&amp; start, <span class="keyword">int</span>&amp; maxLen)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span> &amp;&amp; right&lt;s.size() &amp;&amp; s[left] == s[right] )&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxLen &lt; right - left <span class="number">-1</span>)&#123;</span><br><span class="line">            maxLen = right - left - <span class="number">1</span>;</span><br><span class="line">            start = left + <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>（1）动态规划</p>
<p>（2）dp[i][j记录i～j是不是回文</p>
<p>（3）i=j时，dp=1；</p>
<p>​    j=i+1时，若s[i]==s[j]，dp=1；</p>
<p>​    j&gt;i+1时，若s[i]==s[j]，dp[i+1][j=1，则dp=1；</p>
<p>（4）因为j&gt;=i，因此dp只有对角线为界的半边被遍历赋值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[s.size()][s.size()];</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>, start = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.size(); j++)&#123;</span><br><span class="line">            dp[j][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++)&#123;</span><br><span class="line">                dp[i][j] = (s[i]==s[j] &amp;&amp; (dp[i+<span class="number">1</span>][j<span class="number">-1</span>] || j-i &lt; <span class="number">2</span>));</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; maxLen &lt; j-i+<span class="number">1</span>)&#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    start = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h3><p>Manacher’s Algorithm，时间复杂度O(n)（没看）</p>
<p><a href="https://www.cnblogs.com/grandyang/p/4464476.html">https://www.cnblogs.com/grandyang/p/4464476.html</a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Dynamic Programming</category>
        <category>Palindrome</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-57. Insert Interval</title>
    <url>/2021/05/20/LeetCode-57-Insert-Interval/</url>
    <content><![CDATA[<h1 id="LeetCode-57-Insert-Interval"><a href="#LeetCode-57-Insert-Interval" class="headerlink" title="LeetCode-57. Insert Interval"></a>LeetCode-57. Insert Interval</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/insert-interval/">https://leetcode.com/problems/insert-interval/</a></p>
<p>Given a set of <em>non-overlapping</em> intervals, insert a new interval into the intervals (merge if necessary).</p>
<p>You may assume that the intervals were initially sorted according to their start times.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,3],[6,9]], newInterval &#x3D; [2,5]</span><br><span class="line">Output: [[1,5],[6,9]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &#x3D; [4,8]</span><br><span class="line">Output: [[1,2],[3,10],[12,16]]</span><br><span class="line">Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: intervals &#x3D; [], newInterval &#x3D; [5,7]</span><br><span class="line">Output: [[5,7]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,5]], newInterval &#x3D; [2,3]</span><br><span class="line">Output: [[1,5]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,5]], newInterval &#x3D; [2,7]</span><br><span class="line">Output: [[1,7]]</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>（1）首先写出newIntervals与当前intervals[i]没有交集的判别条件。</p>
<p>（2）若有交集，计算并集，更新newIntervals</p>
<p>（3）在过程中用curr记录newInterval应该插入的位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; insert(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.size(); i++)&#123;</span><br><span class="line">            <span class="comment">//没有交集情况1</span></span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">1</span>] &lt; newInterval[<span class="number">0</span>])&#123;</span><br><span class="line">                res.push_back(intervals[i]);</span><br><span class="line">                curr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有交集情况2</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt; newInterval[<span class="number">1</span>])&#123;</span><br><span class="line">                res.push_back(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                newInterval[<span class="number">0</span>] = min(newInterval[<span class="number">0</span>], intervals[i][<span class="number">0</span>]);</span><br><span class="line">                newInterval[<span class="number">1</span>] = max(newInterval[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res.insert(res.begin()+curr, newInterval);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Intervals</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-56. Merge Intervals</title>
    <url>/2021/05/20/LeetCode-56-Merge-Intervals/</url>
    <content><![CDATA[<h1 id="LeetCode-56-Merge-Intervals"><a href="#LeetCode-56-Merge-Intervals" class="headerlink" title="LeetCode-56. Merge Intervals"></a>LeetCode-56. Merge Intervals</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an array of <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, merge all overlapping intervals, and return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,4],[4,5]]</span><br><span class="line">Output: [[1,5]]</span><br><span class="line">Explanation: Intervals [1,4] and [4,5] are considered overlapping.</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>（1）遍历intervals，若curr_intervals[0] &gt; res.back()[1]，则说明没有交集，可以将curr先放入res。</p>
<p>（2）其他情况，说明有交集，需要合并，合并的让时就是直接对res.back()[1]进行修改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; merge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        res.push_back(intervals[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr = intervals[i];</span><br><span class="line">            <span class="keyword">if</span>(curr[<span class="number">0</span>] &gt; res.back()[<span class="number">1</span>])&#123;</span><br><span class="line">                res.push_back(curr);  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res.back()[<span class="number">1</span>] = max(curr[<span class="number">1</span>], res.back()[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Intervals</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-986. Interval List Intersections</title>
    <url>/2021/05/20/LeetCode-986-Interval-List-Intersections/</url>
    <content><![CDATA[<h1 id="LeetCode-986-Interval-List-Intersections"><a href="#LeetCode-986-Interval-List-Intersections" class="headerlink" title="LeetCode-986. Interval List Intersections"></a>LeetCode-986. Interval List Intersections</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/interval-list-intersections/">https://leetcode.com/problems/interval-list-intersections/</a></p>
<p>You are given two lists of closed intervals, <code>firstList</code> and <code>secondList</code>, where <code>firstList[i] = [starti, endi]</code> and <code>secondList[j] = [startj, endj]</code>. Each list of intervals is pairwise <strong>disjoint</strong> and in <strong>sorted order</strong>.</p>
<p>Return <em>the intersection of these two interval lists</em>.</p>
<p>A <strong>closed interval</strong> <code>[a, b]</code> (with <code>a &lt; b</code>) denotes the set of real numbers <code>x</code> with <code>a &lt;= x &lt;= b</code>.</p>
<p>The <strong>intersection</strong> of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of <code>[1, 3]</code>and <code>[2, 4]</code> is <code>[2, 3]</code>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/01/30/interval1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: firstList &#x3D; [[0,2],[5,10],[13,23],[24,25]], secondList &#x3D; [[1,5],[8,12],[15,24],[25,26]]</span><br><span class="line">Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: firstList &#x3D; [[1,3],[5,9]], secondList &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: firstList &#x3D; [], secondList &#x3D; [[4,8],[10,12]]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: firstList &#x3D; [[1,7]], secondList &#x3D; [[3,10]]</span><br><span class="line">Output: [[3,7]]</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>（1）i和j的指针必须存在某种对应（不能一方走得太快），如何判断？</p>
<p>（2）首先写出无交集的情况，并让一定不会与后面有交集的interval的指针+1</p>
<p>（2）有交集的情况，则求出交集。具体哪个指针加1，看哪个interval的end端靠前。end端相等，则同时加一。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; intervalIntersection(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; firstList, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; secondList) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; firstList.size() &amp;&amp; j &lt; secondList.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(firstList[i][<span class="number">0</span>] &gt; secondList[j][<span class="number">1</span>])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(firstList[i][<span class="number">1</span>] &lt; secondList[j][<span class="number">0</span>])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t(<span class="number">2</span>);</span><br><span class="line">                t[<span class="number">0</span>] = max(firstList[i][<span class="number">0</span>], secondList[j][<span class="number">0</span>]);</span><br><span class="line">                t[<span class="number">1</span>] = min(firstList[i][<span class="number">1</span>], secondList[j][<span class="number">1</span>]);</span><br><span class="line">                res.push_back(t);</span><br><span class="line">                <span class="keyword">if</span>(firstList[i][<span class="number">1</span>] &lt; secondList[j][<span class="number">1</span>])</span><br><span class="line">                    i++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (firstList[i][<span class="number">1</span>] &gt; secondList[j][<span class="number">1</span>])</span><br><span class="line">                    j++;</span><br><span class="line">                <span class="comment">//这里必须将等价的情况单独写出来，不然会出错</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>（1）不用单独分情况讨论无交集的情况。</p>
<p>（2）直接求交集的左端lo，右端hi。若lo&lt;=hi，则表示有交集，加入res。</p>
<p>（3）同solution1，按照end来判别i++还是j++。但是此时不用对相等情况单独讨论（为什么？）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; intervalIntersection(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; B) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.size(), n = B.size(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> lo = max(A[i][<span class="number">0</span>], B[j][<span class="number">0</span>]), hi = min(A[i][<span class="number">1</span>], B[j][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (lo &lt;= hi) res.push_back(&#123;lo, hi&#125;);</span><br><span class="line">            (A[i][<span class="number">1</span>] &lt; B[j][<span class="number">1</span>]) ? ++i : ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Intervals</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-680. Valid Palindrome ||</title>
    <url>/2021/05/20/LeetCode-680-Valid-Palindrome/</url>
    <content><![CDATA[<h1 id="LeetCode-680-Valid-Palindrome"><a href="#LeetCode-680-Valid-Palindrome" class="headerlink" title="LeetCode-680. Valid Palindrome ||"></a>LeetCode-680. Valid Palindrome ||</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a string <code>s</code>, return <code>true</code> <em>if the</em> <code>s</code> <em>can be palindrome after deleting <strong>at most one</strong> character from it</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aba&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abca&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: You could delete the character &#39;c&#39;.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abc&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>（1）第一遇到不一致的，a. left++，再继续判断是否是回文；b. right–，再继续判断是否是回文。a、b两种情况下有一种是回文即可</p>
<p>（2）注意，第一次遇到不一致时，a、b两种情况一定要验证到底，不能只验证后一位是否相等。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[left] == s[right])&#123;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> is_valid(s, left+<span class="number">1</span>, right) || is_valid(s, left, right<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_valid</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;  right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[left] == s[right])&#123;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Palindrome</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-LintCode 391. 数飞机</title>
    <url>/2021/05/20/LeetCode-LintCode-391-%E6%95%B0%E9%A3%9E%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="LeetCode-LintCode-391-数飞机"><a href="#LeetCode-LintCode-391-数飞机" class="headerlink" title="LeetCode-LintCode 391. 数飞机"></a>LeetCode-LintCode 391. 数飞机</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://www.lintcode.com/problem/number-of-airplanes-in-the-sky/description">https://www.lintcode.com/problem/number-of-airplanes-in-the-sky/description</a></p>
<p>给出飞机的起飞和降落时间的列表，用序列 <code>interval</code> 表示. 请计算出天上同时最多有多少架飞机？</p>
<p>如果多架飞机降落和起飞在同一时刻，我们认为降落有优先权。</p>
<p>样例</p>
<p><strong>样例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [(1, 10), (2, 3), (5, 8), (4, 7)]</span><br><span class="line">输出: 3</span><br><span class="line">解释: </span><br><span class="line">第一架飞机在1时刻起飞, 10时刻降落.</span><br><span class="line">第二架飞机在2时刻起飞, 3时刻降落.</span><br><span class="line">第三架飞机在5时刻起飞, 8时刻降落.</span><br><span class="line">第四架飞机在4时刻起飞, 7时刻降落.</span><br><span class="line">在5时刻到6时刻之间, 天空中有三架飞机.</span><br></pre></td></tr></table></figure>

<p><strong>样例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [(1, 2), (2, 3), (3, 4)]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 降落优先于起飞.</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>（1）对序列interval中的全部时刻排序，并标记各时刻为起飞时间还是下落时间，得到v</p>
<p>（2）遍历v，遇到起飞时刻，num++，遇到下降时刻，num–</p>
<p>（3）sort的cmp函数必须是static类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition of Interval:</span></span><br><span class="line"><span class="comment"> * classs Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start, end;</span></span><br><span class="line"><span class="comment"> *     Interval(int start, int end) &#123;</span></span><br><span class="line"><span class="comment"> *         this-&gt;start = start;</span></span><br><span class="line"><span class="comment"> *         this-&gt;end = end;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param airplanes: An interval array</span></span><br><span class="line"><span class="comment">     * @return: Count of airplanes are in the sky.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; a, <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.first == b.first &amp;&amp; a.second == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countOfAirplanes</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt; &amp;airplanes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : airplanes)&#123;</span><br><span class="line">            v.push_back(&#123;i.start, <span class="number">0</span>&#125;);</span><br><span class="line">            v.push_back(&#123;i.end, <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(v.begin(), v.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> max_ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : v)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!i.second) num++;</span><br><span class="line">            <span class="keyword">else</span> num--;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(num&gt;max_) max_ = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Intervals</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-209. Miminum Size Subarray Sum</title>
    <url>/2021/06/08/LeetCode-209-Miminum-Size-Subarray-Sum/</url>
    <content><![CDATA[<h1 id="LeetCode-209-Miminum-Size-Subarray-Sum"><a href="#LeetCode-209-Miminum-Size-Subarray-Sum" class="headerlink" title="LeetCode-209. Miminum Size Subarray Sum"></a>LeetCode-209. Miminum Size Subarray Sum</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, return the minimal length of a <strong>contiguous subarray</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> of which the sum is greater than or equal to <code>target</code>. If there is no such subarray, return <code>0</code> instead.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The subarray [4,3] has the minimal length under the problem constraint.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: target &#x3D; 4, nums &#x3D; [1,4,4]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= target &lt;= 109</code></li>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>思路类似于76题，经典的滑动窗口问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//此种滑动窗口的思路即为，（1）固定left，right++，直到找到第一个符合条件的区间。（2）left++，缩小区间，当区间不满足题意时，right++，增大区间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res &gt; i-left+<span class="number">1</span>) res = i-left+<span class="number">1</span>;</span><br><span class="line">                sum -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res==INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Sliding Window</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-238. Product of Array Except Self</title>
    <url>/2021/06/08/LeetCode-238-Product-of-Array-Except-Self/</url>
    <content><![CDATA[<h1 id="LeetCode-238-Product-of-Array-Except-Self"><a href="#LeetCode-238-Product-of-Array-Except-Self" class="headerlink" title="LeetCode-238. Product of Array Except Self"></a>LeetCode-238. Product of Array Except Self</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/product-of-array-except-self/">https://leetcode.com/problems/product-of-array-except-self/</a></p>
<p>Given an integer array <code>nums</code>, return <em>an array</em> <code>answer</code> <em>such that</em> <code>answer[i]</code> <em>is equal to the product of all the elements of</em> <code>nums</code> <em>except</em> <code>nums[i]</code>.</p>
<p>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</p>
<p>You must write an algorithm that runs in <code>O(n)</code> time and without using the division operation.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4]</span><br><span class="line">Output: [24,12,8,6]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [-1,1,0,-3,3]</span><br><span class="line">Output: [0,0,9,0,0]</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>这道题目和295. Find Median from Data Stream这道求中位数的题目思路有异曲同工之处。</p>
<p>都将带求元素的左右部分分开。</p>
<p>本题思路是</p>
<p>（1）res[i]的值即为0～i-1的乘积和i+1~end的乘积相乘</p>
<p>（2）从后到前求乘积，再从前到后求乘积</p>
<p>（3）求得res[i]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul_back</span><span class="params">(nums.size()+<span class="number">1</span>)</span></span>;</span><br><span class="line">        mul_back[nums.size()] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            mul_back[i] = nums[i] * mul_back[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mul = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            res[i] = mul * mul_back[i+<span class="number">1</span>];</span><br><span class="line">            mul = mul * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-239. Sliding Window Maximum</title>
    <url>/2021/06/08/LeetCode-239-Sliding-Window-Maximum/</url>
    <content><![CDATA[<h1 id="LeetCode-239-Sliding-Window-Maximum"><a href="#LeetCode-239-Sliding-Window-Maximum" class="headerlink" title="LeetCode-239. Sliding Window Maximum"></a>LeetCode-239. Sliding Window Maximum</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>You are given an array of integers <code>nums</code>, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p>
<p>Return <em>the max sliding window</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3</span><br><span class="line">Output: [3,3,5,5,6,7]</span><br><span class="line">Explanation: </span><br><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1], k &#x3D; 1</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,-1], k &#x3D; 1</span><br><span class="line">Output: [1,-1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [9,11], k &#x3D; 2</span><br><span class="line">Output: [11]</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [4,-2], k &#x3D; 2</span><br><span class="line">Output: [4]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>（1）首先想到希望sliding window中的元素时有序的，所以使用priority_queue来做</p>
<p>（2）如果priority_queue中，最大的元素在sliding window外，则q.pop()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="comment">//当q队头的元素位置不在sliding window内，弹出队头元素</span></span><br><span class="line">            <span class="keyword">while</span>(!q.empty() &amp;&amp; q.top().second &lt; i-k+<span class="number">1</span>) q.pop();</span><br><span class="line">            q.push(&#123;nums[i], i&#125;);</span><br><span class="line">            <span class="comment">//如果sliding window足够大，弹出栈顶元素。</span></span><br><span class="line">            <span class="keyword">if</span>(i-k+<span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">                res.push_back(q.top().first);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Sliding Window</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 295. Find Median from Data Stream</title>
    <url>/2021/06/08/LeetCode-295-Find-Median-from-Data-Stream/</url>
    <content><![CDATA[<h1 id="LeetCode-295-Find-Median-from-Data-Stream"><a href="#LeetCode-295-Find-Median-from-Data-Stream" class="headerlink" title="LeetCode 295. Find Median from Data Stream"></a>LeetCode 295. Find Median from Data Stream</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/find-median-from-data-stream/">https://leetcode.com/problems/find-median-from-data-stream/</a></p>
<p>The <strong>median</strong> is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values.</p>
<ul>
<li>For example, for <code>arr = [2,3,4]</code>, the median is <code>3</code>.</li>
<li>For example, for <code>arr = [2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code>.</li>
</ul>
<p>Implement the MedianFinder class:</p>
<ul>
<li><code>MedianFinder()</code> initializes the <code>MedianFinder</code> object.</li>
<li><code>void addNum(int num)</code> adds the integer <code>num</code> from the data stream to the data structure.</li>
<li><code>double findMedian()</code> returns the median of all elements so far. Answers within <code>10-5</code> of the actual answer will be accepted.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;]</span><br><span class="line">[[], [1], [2], [], [3], []]</span><br><span class="line">Output</span><br><span class="line">[null, null, null, 1.5, null, 2.0]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">MedianFinder medianFinder &#x3D; new MedianFinder();</span><br><span class="line">medianFinder.addNum(1);    &#x2F;&#x2F; arr &#x3D; [1]</span><br><span class="line">medianFinder.addNum(2);    &#x2F;&#x2F; arr &#x3D; [1, 2]</span><br><span class="line">medianFinder.findMedian(); &#x2F;&#x2F; return 1.5 (i.e., (1 + 2) &#x2F; 2)</span><br><span class="line">medianFinder.addNum(3);    &#x2F;&#x2F; arr[1, 2, 3]</span><br><span class="line">medianFinder.findMedian(); &#x2F;&#x2F; return 2.0</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>此题很明显，希望维护一个有序的数组。</p>
<p>每次插入num的时候，使用二分法查找插入位置。（使用sort(_num.begin(), _num.end()会报错)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MedianFinder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_nums.empty())&#123;</span><br><span class="line">            _nums.push_back(num);</span><br><span class="line">            <span class="keyword">return</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = _nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(num == _nums[mid])&#123;</span><br><span class="line">                _nums.insert(_nums.begin()+mid, num);   </span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &lt; _nums[mid])&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _nums.insert(_nums.begin()+left, num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = _nums.size();</span><br><span class="line">        <span class="keyword">return</span> n%<span class="number">2</span> == <span class="number">0</span> ? (_nums[n/<span class="number">2</span><span class="number">-1</span>]+_nums[n/<span class="number">2</span>])/<span class="number">2.0</span> : _nums[n/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Soltuion-2"><a href="#Soltuion-2" class="headerlink" title="Soltuion 2"></a>Soltuion 2</h3><p>堆排序法。使用两个堆，一个大顶堆保存有序nums中左半边的元素，一个小顶堆保存有序nums右半边的元素。</p>
<p>使用priority_queue结构来构建堆。但是因为priority_queue没有下标索引机制，且从大到小保存元素。所以为了构造小顶堆的效果，large中的元素取相反数存入。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MedianFinder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        small.push(num);</span><br><span class="line">        large.push(-small.top());</span><br><span class="line">        small.pop();</span><br><span class="line">        <span class="keyword">if</span>(small.size() &lt; large.size())&#123;</span><br><span class="line">            small.push(-large.top());</span><br><span class="line">            large.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> small.size() &gt; large.size() ? small.top() : (small.top() - large.top())/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">long</span>&gt; small, large;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Heap</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-303. Range Sum Query - Immutable</title>
    <url>/2021/06/08/LeetCode-303-Range-Sum-Query-Immutable/</url>
    <content><![CDATA[<h1 id="LeetCode-303-Range-Sum-Query-Immutable"><a href="#LeetCode-303-Range-Sum-Query-Immutable" class="headerlink" title="LeetCode-303. Range Sum Query - Immutable"></a>LeetCode-303. Range Sum Query - Immutable</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/range-sum-query-immutable/">https://leetcode.com/problems/range-sum-query-immutable/</a></p>
<p>Given an integer array <code>nums</code>, handle multiple queries of the following type:</p>
<ol>
<li>Calculate the <strong>sum</strong> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <strong>inclusive</strong> where <code>left &lt;= right</code>.</li>
</ol>
<p>Implement the <code>NumArray</code> class:</p>
<ul>
<li><code>NumArray(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</li>
<li><code>int sumRange(int left, int right)</code> Returns the <strong>sum</strong> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <strong>inclusive</strong> (i.e. <code>nums[left] + nums[left + 1] + ... + nums[right]</code>).</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]</span><br><span class="line">[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]</span><br><span class="line">Output</span><br><span class="line">[null, 1, -1, -3]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">NumArray numArray &#x3D; new NumArray([-2, 0, 3, -5, 2, -1]);</span><br><span class="line">numArray.sumRange(0, 2); &#x2F;&#x2F; return (-2) + 0 + 3 &#x3D; 1</span><br><span class="line">numArray.sumRange(2, 5); &#x2F;&#x2F; return 3 + (-5) + 2 + (-1) &#x3D; -1</span><br><span class="line">numArray.sumRange(0, 5); &#x2F;&#x2F; return (-2) + 0 + 3 + (-5) + 2 + (-1) &#x3D; -3</span><br></pre></td></tr></table></figure>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>此题比较值得注意的是，它是一道design的题目。</p>
<p>第一反应是private中设定存储nums的vector，每次调用sumRange函数时遍历求和。</p>
<p>但是如果直接在NumArray接受nums时，记录累加和，而不是num本身，能大幅度减小sumRange的时间复杂度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)&#123;</span><br><span class="line">        dp.resize(nums.size()+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.size(); i++)</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + nums[i<span class="number">-1</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[right+<span class="number">1</span>] - dp[left];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-53. Maximum Subarray</title>
    <url>/2021/06/08/LeetCode-53-Maximum-Subarray/</url>
    <content><![CDATA[<h1 id="LeetCode-53-Maximum-Subarray"><a href="#LeetCode-53-Maximum-Subarray" class="headerlink" title="LeetCode-53. Maximum Subarray"></a>LeetCode-53. Maximum Subarray</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/maximum-subarray/">https://leetcode.com/problems/maximum-subarray/</a></p>
<p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return <em>its sum</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum &#x3D; 6.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [5,4,-1,7,8]</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure>


<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>利用动态规划的基本思想。dp[i] = max(dp[i-1]+nums[i], nums[i])。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> dp[n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max_ = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-1</span>]+nums[i], nums[i]);</span><br><span class="line">            max_ = max(max_, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然也可以省略dp数组，直接用prev记录dp[i-1]的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> prev = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max_ = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//int curr = nums[0]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            prev = max(prev+nums[i], nums[i]);</span><br><span class="line">            max_ = max(max_, prev);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-713 Subarray Product Less Than K</title>
    <url>/2021/06/08/LeetCode-713-Subarray-Product-Less-Than-K/</url>
    <content><![CDATA[<h1 id="LeetCode-713-Subarray-Product-Less-Than-K"><a href="#LeetCode-713-Subarray-Product-Less-Than-K" class="headerlink" title="LeetCode-713 Subarray Product Less Than K"></a>LeetCode-713 Subarray Product Less Than K</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/subarray-product-less-than-k/">(6) Subarray Product Less Than K - LeetCode</a></p>
<p>Given an array of integers <code>nums</code> and an integer <code>k</code>, return <em>the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than</em> <code>k</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [10,5,2,6], k &#x3D; 100</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: The 8 subarrays that have product less than 100 are:</span><br><span class="line">[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]</span><br><span class="line">Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3], k &#x3D; 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><p><code>1 &lt;= nums.length &lt;= 105</code></p>
</li>
<li><p><code>0 &lt; nums[i] &lt; 1000</code></p>
</li>
<li><p><code>0 &lt;= k &lt; 106</code></p>
</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>这道题和76，209不同的地方在于，76,209是不容易找到第一个符合条件的区间，需要先扩大右边界找到第一个符合条件的区间。而这道题是不容易找到第一个不符合条件的区间。</p>
<p>此题的思路是：</p>
<p>（1）维护一个sliding window M，其中所有元素的乘积&lt;k，则sliding window中的所有子区间都符合要求。每次sliding window的右边界+1时，对res增加。增加的大小即为sliding window的大小，即统计右边界为sliding window M右边界的子区间个数。这里固定子区间右边界是因为，子区间right&lt;sliding window M右边界的情况之前已经加进过res了。可知，符合要求的子区间即为区间的长度，为i-left+1。</p>
<p>（1）扩大右边界，计算符合要求的区间个数，直到找到不符合题目要求的区间</p>
<p>（2）若当前区间不符合要求，left++，缩小边界，直到区间M符合要求。根据（1）中的方法，更新res。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, prod = <span class="number">1</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            prod *= nums[i];</span><br><span class="line">            <span class="comment">//不符合要求时，缩小左边界。注意，这里要加入left&lt;=i的限定条件，left最多到i+1，此时res不会增长</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt;= i &amp;&amp; prod &gt;= k) prod /= nums[left++];</span><br><span class="line">            <span class="comment">//注意：求得的一个区间left~i内有i-left+1个符合要求的区间，不能直接res++一次</span></span><br><span class="line">            res += i - left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Sliding Window</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-76. Minimum Window Substring</title>
    <url>/2021/06/08/LeetCode-76-Minimum-Window-Substring/</url>
    <content><![CDATA[<h1 id="LeetCode-76-Minimum-Window-Substring"><a href="#LeetCode-76-Minimum-Window-Substring" class="headerlink" title="LeetCode-76. Minimum Window Substring"></a>LeetCode-76. Minimum Window Substring</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/minimum-window-substring/">(6) Minimum Window Substring - LeetCode</a></p>
<p>Given two strings <code>s</code> and <code>t</code> of lengths <code>m</code> and <code>n</code> respectively, return <em>the <strong>minimum window substring</strong> of</em> <code>s</code> <em>such that every character in</em> <code>t</code> <em>(<strong>including duplicates</strong>) is included in the window. If there is no such substring*</em>, return the empty string* <code>&quot;&quot;</code><em>.</em></p>
<p>The testcases will be generated such that the answer is <strong>unique</strong>.</p>
<p>A <strong>substring</strong> is a contiguous sequence of characters within the string.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;ADOBECODEBANC&quot;, t &#x3D; &quot;ABC&quot;</span><br><span class="line">Output: &quot;BANC&quot;</span><br><span class="line">Explanation: The minimum window substring &quot;BANC&quot; includes &#39;A&#39;, &#39;B&#39;, and &#39;C&#39; from string t.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;a&quot;, t &#x3D; &quot;a&quot;</span><br><span class="line">Output: &quot;a&quot;</span><br><span class="line">Explanation: The entire string s is the minimum window.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;a&quot;, t &#x3D; &quot;aa&quot;</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: Both &#39;a&#39;s from t must be included in the window.</span><br><span class="line">Since the largest window of s only has one &#39;a&#39;, return empty string.</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>m == s.length</code></li>
<li><code>n == t.length</code></li>
<li><code>1 &lt;= m, n &lt;= 105</code></li>
<li><code>s</code> and <code>t</code> consist of uppercase and lowercase English letters.</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>此题和<a href="https://leetcode.com/problems/minimum-size-subarray-sum/">209. Minimum Size Subarray Sum</a>思路很像，都是经典的sliding window做法。</p>
<p>sliding window的主要思路是：</p>
<p>（1）固定left，right边界扩增，直到找到符合要求的区域</p>
<p>（2）left++，查看区域是否符合要求，若符合，left++，缩小区域。若不符合，right++。</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>使用hash map。注意，hash_map的value表示区间内需要包含几个key。没有在t中的元素也会被加入hash_map中，不在t中的元素的value&lt;=0。</p>
<p>另外用count来标识现在找到的t中元素个数，判断符合要求的情况。count的加减根据hash_map的值来判断。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min_len = INT_MAX;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注意string s中，s[i]的类型为char</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : t) m[c]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(--m[s[i]] &gt;= <span class="number">0</span>) count++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(count == t.size())&#123;</span><br><span class="line">                <span class="keyword">if</span>(min_len &gt; i-left+<span class="number">1</span>)&#123;</span><br><span class="line">                    min_len = i-left+<span class="number">1</span>;</span><br><span class="line">                    res = s.substr(left, min_len);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(++m[s[left]] &gt; <span class="number">0</span>) count--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>ASCII中有256个字符，使用vector<int> m(256,0)来代替hash_map。</p>
<p>注意如果char c_ = ‘a’, 也可以直接使用m[c_] = 1赋值，应该是编译器会自动将char类型转换为int类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">m</span><span class="params">(<span class="number">256</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min_len = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:t) m[c]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(--m[s[i]] &gt;= <span class="number">0</span>) count++;</span><br><span class="line">            <span class="keyword">while</span>(count == t.size())&#123;</span><br><span class="line">                <span class="keyword">if</span>(min_len &gt; i-left+<span class="number">1</span>)&#123;</span><br><span class="line">                    min_len = i-left+<span class="number">1</span>;</span><br><span class="line">                    res = s.substr(left, min_len);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(++m[s[left++]]&gt;<span class="number">0</span>) count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Sliding Window</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1. Two Sum</title>
    <url>/2021/06/11/LeetCode-1-Two-Sum/</url>
    <content><![CDATA[<h1 id="LeetCode-1-Two-Sum"><a href="#LeetCode-1-Two-Sum" class="headerlink" title="LeetCode-1. Two Sum"></a>LeetCode-1. Two Sum</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p>
<p>You may assume that each input would have *<strong>exactly* one solution</strong>, and you may not use the <em>same</em> element twice.</p>
<p>You can return the answer in any order.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">Output: [0,1]</span><br><span class="line">Output: Because nums[0] + nums[1] &#x3D;&#x3D; 9, we return [0, 1].</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,4], target &#x3D; 6</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [3,3], target &#x3D; 6</span><br><span class="line">Output: [0,1]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 104</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
<li><strong>Only one valid answer exists.</strong></li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>（1）遍历一遍，求哈希表</p>
<p>（2）遍历一遍，查找</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            m[nums[i]] = i;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(m.count(t) &amp;&amp; m[t]!=i)</span><br><span class="line">                <span class="keyword">return</span> &#123;m[t], i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Array</category>
        <category>Hash Table</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-15. 3Sum</title>
    <url>/2021/06/11/LeetCode-15-3Sum/</url>
    <content><![CDATA[<h1 id="LeetCode-15-3Sum"><a href="#LeetCode-15-3Sum" class="headerlink" title="LeetCode-15. 3Sum"></a>LeetCode-15. 3Sum</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code>such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p>
<p>Notice that the solution set must not contain duplicate triplets.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [-1,0,1,2,-1,-4]</span><br><span class="line">Output: [[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [0]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>（1）先排序</p>
<p>（2）利用Two Pointers查找剩下两个num</p>
<p>（3）注意下面代码注释中的细节</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="comment">//注意写下面这句话</span></span><br><span class="line">        <span class="keyword">if</span>(nums.empty() || nums.front() &gt; <span class="number">0</span> || nums.back() &lt; <span class="number">0</span> ||nums.size()&lt;<span class="number">3</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size()<span class="number">-2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span> ) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> target = <span class="number">0</span> - nums[i];</span><br><span class="line">            <span class="keyword">int</span> left = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = nums.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[left]+nums[right] &lt; target)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="comment">//while(nums[left]==nums[left+1]) left++;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[left]+nums[right] &gt; target)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="comment">//while(nums[right]==nums[right-1]) right--;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    res.push_back(&#123;nums[i],nums[left],nums[right]&#125;);</span><br><span class="line">                    <span class="comment">//注意这里要先while，再left++,right--</span></span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left]==nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right]==nums[right<span class="number">-1</span>]) right--;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Array</category>
        <category>Two Pointers</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-528. Random Pick with Weight</title>
    <url>/2021/06/11/LeetCode-528-Random-Pick-with-Weight/</url>
    <content><![CDATA[<h1 id="LeetCode-528-Random-Pick-with-Weight"><a href="#LeetCode-528-Random-Pick-with-Weight" class="headerlink" title="LeetCode-528. Random Pick with Weight"></a>LeetCode-528. Random Pick with Weight</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>You are given an array of positive integers <code>w</code> where <code>w[i]</code> describes the weight of <code>i``th</code> index (0-indexed).</p>
<p>We need to call the function <code>pickIndex()</code> which <strong>randomly</strong> returns an integer in the range <code>[0, w.length - 1]</code>. <code>pickIndex()</code> should return the integer proportional to its weight in the <code>w</code> array. For example, for <code>w = [1, 3]</code>, the probability of picking the index <code>0</code> is <code>1 / (1 + 3) = 0.25</code> (i.e 25%) while the probability of picking the index <code>1</code> is <code>3 / (1 + 3) = 0.75</code> (i.e 75%).</p>
<p>More formally, the probability of picking index <code>i</code> is <code>w[i] / sum(w)</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;Solution&quot;,&quot;pickIndex&quot;]</span><br><span class="line">[[[1]],[]]</span><br><span class="line">Output</span><br><span class="line">[null,0]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">Solution solution &#x3D; new Solution([1]);</span><br><span class="line">solution.pickIndex(); &#x2F;&#x2F; return 0. Since there is only one single element on the array the only option is to return the first element.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;Solution&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;]</span><br><span class="line">[[[1,3]],[],[],[],[],[]]</span><br><span class="line">Output</span><br><span class="line">[null,1,1,1,1,0]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">Solution solution &#x3D; new Solution([1, 3]);</span><br><span class="line">solution.pickIndex(); &#x2F;&#x2F; return 1. It&#39;s returning the second element (index &#x3D; 1) that has probability of 3&#x2F;4.</span><br><span class="line">solution.pickIndex(); &#x2F;&#x2F; return 1</span><br><span class="line">solution.pickIndex(); &#x2F;&#x2F; return 1</span><br><span class="line">solution.pickIndex(); &#x2F;&#x2F; return 1</span><br><span class="line">solution.pickIndex(); &#x2F;&#x2F; return 0. It&#39;s returning the first element (index &#x3D; 0) that has probability of 1&#x2F;4.</span><br><span class="line"></span><br><span class="line">Since this is a randomization problem, multiple answers are allowed so the following outputs can be considered correct :</span><br><span class="line">[null,1,1,1,1,0]</span><br><span class="line">[null,1,1,1,1,1]</span><br><span class="line">[null,1,1,1,0,0]</span><br><span class="line">[null,1,1,1,0,1]</span><br><span class="line">[null,1,0,1,0,0]</span><br><span class="line">......</span><br><span class="line">and so on.</span><br></pre></td></tr></table></figure>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>（1）w的累加和为sum，则创建sum个元素，w[i]为多少，创建多少个i，则抽到i的几率为w[i]</p>
<p>（2）生成1～w.size()范围的随机数rand，来决定抽到的元素是从最小到大的第几个</p>
<p>（3）利用二分法查找rand对应的元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; w) &#123;</span><br><span class="line">        sum = w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sum.size(); i++)&#123;</span><br><span class="line">            sum[i] = sum[i<span class="number">-1</span>] + w[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意这里要+1，将x的范围变为1～sum.back()</span></span><br><span class="line">        <span class="keyword">int</span> x = rand()%sum.back()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = sum.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(sum[mid] == x)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(sum[mid] &lt; x)</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Binary Search</category>
        <category>Random</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-560. Subarray Sum Equals K</title>
    <url>/2021/06/11/LeetCode-560-Subarray-Sum-Equals-K/</url>
    <content><![CDATA[<h1 id="LeetCode-560-Subarray-Sum-Equals-K"><a href="#LeetCode-560-Subarray-Sum-Equals-K" class="headerlink" title="LeetCode-560. Subarray Sum Equals K"></a>LeetCode-560. Subarray Sum Equals K</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/subarray-sum-equals-k/">https://leetcode.com/problems/subarray-sum-equals-k/</a></p>
<p>Given an array of integers <code>nums</code> and an integer <code>k</code>, return <em>the total number of continuous subarrays whose sum equals to <code>k</code></em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3], k &#x3D; 3</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>-107 &lt;= k &lt;= 107</code></li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>（1）利用m存储累加和为key的子序列个数</p>
<p>（2）用sum记录到当前位置的累加和，利用HashMap寻找sum-k是否存在。如果有连续子数组的和为sum-k，那么和为k的子数组一定也存在。</p>
<p>问题：（1）为什么一定要加m[sum-k]，而不是m[k]？<br>（2）如果有两个序列累加和相等，例如sum[i]==sum[j]，那么不会重复加m[sum-k]吗？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            res += m[sum-k];</span><br><span class="line">            m[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Array</category>
        <category>Hash Table</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-18. 4Sum</title>
    <url>/2021/06/11/LeetCode-18-4Sum/</url>
    <content><![CDATA[<h1 id="LeetCode-18-4Sum"><a href="#LeetCode-18-4Sum" class="headerlink" title="LeetCode-18. 4Sum"></a>LeetCode-18. 4Sum</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an array <code>nums</code> of <code>n</code> integers, return <em>an array of all the <strong>unique</strong> quadruplets</em><code>[nums[a], nums[b], nums[c], nums[d]]</code> such that:</p>
<ul>
<li><code>0 &lt;= a, b, c, d &lt; n</code></li>
<li><code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are <strong>distinct</strong>.</li>
<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>
<p>You may return the answer in <strong>any order</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0</span><br><span class="line">Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,2,2,2,2], target &#x3D; 8</span><br><span class="line">Output: [[2,2,2,2]]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>和3Sum思想类似，不过多嵌套了一层循环。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">if</span>(nums.empty() || nums.size() &lt; <span class="number">4</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.size()<span class="number">-4</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//if(nums[i] &gt; target) break;</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= nums.size()<span class="number">-3</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> k = target - nums[i];</span><br><span class="line">                <span class="comment">//if(nums[j] &gt; k) break;</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt; i+<span class="number">1</span> &amp;&amp; nums[j] == nums[j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> left = j+<span class="number">1</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">int</span> t = k - nums[j];</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[left] + nums[right] == t)&#123;</span><br><span class="line">                        res.push_back(&#123;nums[i], nums[j], nums[left], nums[right]&#125;);</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right<span class="number">-1</span>]) right--;</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(nums[left] + nums[right] &lt; t)&#123;</span><br><span class="line">                        left++;  </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Array</category>
        <category>Two Pointers</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LintCode-382. TriangleCount</title>
    <url>/2021/06/11/LintCode-382-TriangleCount/</url>
    <content><![CDATA[<h1 id="LintCode-382-TriangleCount"><a href="#LintCode-382-TriangleCount" class="headerlink" title="LintCode-382. TriangleCount"></a>LintCode-382. TriangleCount</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://www.lintcode.com/problem/382/description">https://www.lintcode.com/problem/382/description</a></p>
<p>描述</p>
<p>给定一个整数数组，在该数组中，寻找三个数，分别代表三角形三条边的长度，问，可以寻找到多少组这样的三个数来组成三角形？</p>
<p>样例</p>
<p><strong>样例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3, 4, 6, 7]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">可以组成的是 (3, 4, 6), </span><br><span class="line">           (3, 6, 7),</span><br><span class="line">           (4, 6, 7)</span><br></pre></td></tr></table></figure>

<p><strong>样例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4, 4, 4, 4]</span><br><span class="line">输出: 4</span><br><span class="line">解释:</span><br><span class="line">任何三个数都可以构成三角形</span><br><span class="line">所以答案为 C(3, 4) &#x3D; 4</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>我的思路</p>
<p>（1）先固定第一个数S[i]，然后第二层for循环固定第二个数，也是最大的数S[right]。</p>
<p>（2）从而只需判断另外两个较小的数之和大于最大的数即可：S[i] + S[left] &gt; S[right]</p>
<p>（3）若S[i] + S[left]小了，则left++。找到一个满足S[i] + S[left] &gt; S[right]的，则left～right-1区间中的数作为left都满足条件，从而res+=right-left，之后right–。</p>
<p>单词方法超出了时间限制。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">triangleCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;S)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    sort(S.begin(), S.end());</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.size()<span class="number">-2</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//int left = i+1;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right = S.size()<span class="number">-1</span>; right &gt; i+<span class="number">1</span>; right--)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; S[left] + S[i] &lt;= S[right])</span><br><span class="line">                left++;</span><br><span class="line">            res += right-left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>其实和我的思路类似，不过先固定的是最大的数S[i]，然后i逆序遍历。剩下的部分类似于3Sum，4Sum的Two Pointers思想。之所以不能正序遍历是因为若先固定最小的数，那么当S[i]+S[left]&lt;=S[right]时，left++或者right–均可能令更新后的元素满足S[i]+S[left]&gt;S[right]，不好分类讨论。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">triangleCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;S)</span></span>&#123;</span><br><span class="line">    sort(S.begin(), S.end());</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = S.size()<span class="number">-1</span>; i&gt;=<span class="number">2</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[l] + S[r] &gt; S[i])&#123;</span><br><span class="line">                res += r-l;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Array</category>
        <category>Two Pointers</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-200. Number of Islands</title>
    <url>/2021/06/21/LeetCode-200-Number-of-Islands/</url>
    <content><![CDATA[<h1 id="LeetCode-200-Number-of-Islands"><a href="#LeetCode-200-Number-of-Islands" class="headerlink" title="LeetCode-200. Number of Islands"></a>LeetCode-200. Number of Islands</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/number-of-islands/">https://leetcode.com/problems/number-of-islands/</a></p>
<p>Given an <code>m x n</code> 2D binary grid <code>grid</code> which represents a map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), return <em>the number of islands</em>.</p>
<p>An <strong>island</strong> is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 300</code></li>
<li><code>grid[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>最直接的想法是DFS。</p>
<p>（1）将访问过的“1”节点值置为“#”。“0”节点可以不用处理</p>
<p>（2）对“1”节点从上下左右四个方位寻找其他“1”节点，再递归地找此”1“节点的邻域”1“节点。将找到的“1”节点置为“#“。这样每次停止递归，找到的都是整块岛屿，res+1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(i,j, grid);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= grid.size() || j&lt;<span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].size()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;0&#x27;</span> ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            grid[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            dfs(i+<span class="number">1</span>, j, grid);</span><br><span class="line">            dfs(i, j+<span class="number">1</span>, grid);</span><br><span class="line">            dfs(i<span class="number">-1</span>, j, grid);</span><br><span class="line">            dfs(i, j<span class="number">-1</span>, grid);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>BFS。</p>
<p>（1）整体思路和DFS很像，不过寻找一整块岛屿的时候，使用BFS方法来遍历。使用到队列，而不是递归。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    q.push(&#123;i,j&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">                        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; curr = q.front(); q.pop();</span><br><span class="line">                        <span class="keyword">int</span> m = curr.first, n = curr.second;</span><br><span class="line">                        grid[m][n] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">                        <span class="keyword">if</span>(m<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[m<span class="number">-1</span>][n] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                            q.push(<span class="built_in">pair</span>&#123;m<span class="number">-1</span>, n&#125;);</span><br><span class="line">                            grid[m<span class="number">-1</span>][n] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(m+<span class="number">1</span> &lt; grid.size() &amp;&amp; grid[m+<span class="number">1</span>][n] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                            q.push(<span class="built_in">pair</span>&#123;m+<span class="number">1</span>, n&#125;);</span><br><span class="line">                            grid[m+<span class="number">1</span>][n] = <span class="string">&#x27;#&#x27;</span>;   </span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(n<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[m][n<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                            q.push(&#123;m, n<span class="number">-1</span>&#125;);</span><br><span class="line">                            grid[m][n<span class="number">-1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(n+<span class="number">1</span> &lt; grid[<span class="number">0</span>].size() &amp;&amp; grid[m][n+<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                            q.push(&#123;m, n+<span class="number">1</span>&#125;);</span><br><span class="line">                            grid[m][n+<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;   </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Leetcode</category>
        <category>DFS</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-207. Course Schedule</title>
    <url>/2021/06/21/LeetCode-207-Course-Schedule/</url>
    <content><![CDATA[<h2 id="LeetCode-207-Course-Schedule"><a href="#LeetCode-207-Course-Schedule" class="headerlink" title="LeetCode-207. Course Schedule"></a>LeetCode-207. Course Schedule</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p><a href="https://leetcode.com/problems/course-schedule/">https://leetcode.com/problems/course-schedule/</a></p>
<p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [ai, bi]</code> indicates that you <strong>must</strong> take course <code>bi</code> first if you want to take course <code>ai</code>.</p>
<ul>
<li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li>
</ul>
<p>Return <code>true</code> if you can finish all courses. Otherwise, return <code>false</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">To take course 1 you should have finished course 0. So it is possible.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0],[0,1]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= numCourses &lt;= 105</code></li>
<li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li>
<li><code>prerequisites[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt; numCourses</code></li>
<li>All the pairs prerequisites[i] are <strong>unique</strong>.</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>思路基本类似于LintCode-127. Topological Sorting。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//map&lt;int, int&gt; m_0_1;</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">m_0_1</span><span class="params">(numCourses,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">//可以不用hash，直接用vector&lt;vector&lt;int&gt;&gt;</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m_1_0;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p : prerequisites)&#123;</span><br><span class="line">            m_0_1[p[<span class="number">0</span>]]++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(m_1_0.count(p[<span class="number">1</span>]))</span><br><span class="line">                m_1_0[p[<span class="number">1</span>]].push_back(p[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">                v.push_back(p[<span class="number">0</span>]);</span><br><span class="line">                m_1_0[p[<span class="number">1</span>]] = v;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!m_0_1[i]) &#123;</span><br><span class="line">                s.push(i);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = s.front();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> t : m_1_0[curr])&#123;</span><br><span class="line">                m_0_1[t]--;</span><br><span class="line">                <span class="keyword">if</span>(m_0_1[t]==<span class="number">0</span>) &#123;</span><br><span class="line">                    s.push(t);</span><br><span class="line">                    count++;   </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count == numCourses;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        for(int i = 0; i&lt;numCourses; i++)&#123;</span></span><br><span class="line"><span class="comment">            if(m_0_1[i]!=0) return false;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return true;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-210. Course Schedule ||</title>
    <url>/2021/06/21/LeetCode-210-Course-Schedule/</url>
    <content><![CDATA[<h1 id="LeetCode-210-Course-Schedule"><a href="#LeetCode-210-Course-Schedule" class="headerlink" title="LeetCode-210. Course Schedule ||"></a>LeetCode-210. Course Schedule ||</h1><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [ai, bi]</code> indicates that you <strong>must</strong> take course <code>bi</code> first if you want to take course <code>ai</code>.</p>
<ul>
<li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li>
</ul>
<p>Return <em>the ordering of courses you should take to finish all courses</em>. If there are many valid answers, return <strong>any</strong> of them. If it is impossible to finish all courses, return <strong>an empty array</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]</span><br><span class="line">Output: [0,1]</span><br><span class="line">Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: numCourses &#x3D; 4, prerequisites &#x3D; [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">Output: [0,2,1,3]</span><br><span class="line">Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.</span><br><span class="line">So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: numCourses &#x3D; 1, prerequisites &#x3D; []</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= numCourses &lt;= 2000</code></li>
<li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li>
<li><code>prerequisites[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt; numCourses</code></li>
<li><code>ai != bi</code></li>
<li>All the pairs <code>[ai, bi]</code> are <strong>distinct</strong>.</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>BFS.</p>
<p>相似的题目：LintCode-127. Topological Sorting，LeetCode-207. Course Schedule</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//map&lt;int, int&gt; m_0_1;</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">m_0_1</span><span class="params">(numCourses,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">//可以不用hash，直接用vector&lt;vector&lt;int&gt;&gt;</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m_1_0;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p : prerequisites)&#123;</span><br><span class="line">            m_0_1[p[<span class="number">0</span>]]++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(m_1_0.count(p[<span class="number">1</span>]))</span><br><span class="line">                m_1_0[p[<span class="number">1</span>]].push_back(p[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">                v.push_back(p[<span class="number">0</span>]);</span><br><span class="line">                m_1_0[p[<span class="number">1</span>]] = v;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!m_0_1[i]) &#123;</span><br><span class="line">                s.push(i);</span><br><span class="line">                res.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = s.front();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> t : m_1_0[curr])&#123;</span><br><span class="line">                m_0_1[t]--;</span><br><span class="line">                <span class="keyword">if</span>(m_0_1[t]==<span class="number">0</span>) &#123;</span><br><span class="line">                    s.push(t);</span><br><span class="line">                    res.push_back(t);  </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.size()!=numCourses) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        for(int i = 0; i&lt;numCourses; i++)&#123;</span></span><br><span class="line"><span class="comment">            if(m_0_1[i]!=0) return false;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return true;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-297. Serialize and Deserialize Binary Tree</title>
    <url>/2021/06/18/LeetCode-297-Serialize-and-Deserialize-Binary-Tree/</url>
    <content><![CDATA[<h1 id="LeetCode-297-Serialize-and-Deserialize-Binary-Tree"><a href="#LeetCode-297-Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="LeetCode-297. Serialize and Deserialize Binary Tree"></a>LeetCode-297. Serialize and Deserialize Binary Tree</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/">https://leetcode.com/problems/serialize-and-deserialize-binary-tree/</a></p>
<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>
<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<p><strong>Clarification:</strong> The input/output format is the same as <a href="https://leetcode.com/faq/#binary-tree">how LeetCode serializes a binary tree</a>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3,null,null,4,5]</span><br><span class="line">Output: [1,2,3,null,null,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[0, 104]</code>.</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>第一反应是层序遍历，然后deserialize的时候利用完全二叉树父节点和子节点的index关系。如果这样的话deserialize需要用到hash map来判断一个TreeNode是否已经创建了，hash map应该是&lt;int, TreeNode*&gt;的类型。但是因为传入的是string类型，且TreeNode的value可能超过一位数，故而无法正常读value。这里需要使用istringstream和outstringstream。</p>
<p><b>学习outstringstream和istringstream的使用方法</b></p>
<p><b>注意deserialize的写法，其实和serialize写法差不多，不需要hash map</b></p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>先序遍历递归方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ostringstream</span> out;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            TreeNode* curr = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(curr)&#123;</span><br><span class="line">                out &lt;&lt; curr-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                q.push(curr-&gt;left);</span><br><span class="line">                q.push(curr-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                out &lt;&lt; <span class="string">&quot;# &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out.str();   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="comment">//不能用hash map，因为node_val可能大于9，因而string中不是data[i]为一个node_val，可能data[i]~data[i+n]为一个node_val,所以无法使用index</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.empty()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="built_in">string</span> val;</span><br><span class="line">        in &gt;&gt; val;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(stoi(val));</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            TreeNode* curr = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(!(in &gt;&gt; val)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(val!=<span class="string">&quot;#&quot;</span>) &#123;</span><br><span class="line">                    TreeNode* l = <span class="keyword">new</span> TreeNode(stoi(val));</span><br><span class="line">                    q.push(l);</span><br><span class="line">                    curr-&gt;left = l;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!(in &gt;&gt; val)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(val!=<span class="string">&quot;#&quot;</span>)&#123;</span><br><span class="line">                    TreeNode* r = <span class="keyword">new</span> TreeNode(stoi(val));</span><br><span class="line">                    q.push(r);</span><br><span class="line">                    curr-&gt;right = r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>层次遍历，迭代法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ostringstream</span> out;</span><br><span class="line">        serialize(root, out);</span><br><span class="line">        <span class="keyword">return</span> out.str();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="comment">//不能用hash map，因为node_val可能大于9，因而string中不是data[i]为一个node_val，可能data[i]~data[i+n]为一个node_val,所以无法使用index</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.empty()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(data)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> deserialize(in);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode* curr, <span class="built_in">ostringstream</span>&amp; out)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!curr)&#123;</span><br><span class="line">            out &lt;&lt; <span class="string">&quot;# &quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        out &lt;&lt; curr-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        serialize(curr-&gt;left, out);</span><br><span class="line">        serialize(curr-&gt;right, out);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">istringstream</span>&amp; in)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> val;</span><br><span class="line">        in &gt;&gt; val;</span><br><span class="line">        <span class="keyword">if</span>(val==<span class="string">&quot;#&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* curr = <span class="keyword">new</span> TreeNode(stoi(val));</span><br><span class="line">        curr-&gt;left = deserialize(in);</span><br><span class="line">        curr-&gt;right = deserialize(in);</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-513. Find Bottom Left Tree Value</title>
    <url>/2021/06/18/LeetCode-513-Find-Bottom-Left-Tree-Value/</url>
    <content><![CDATA[<h1 id="LeetCode-513-Find-Bottom-Left-Tree-Value"><a href="#LeetCode-513-Find-Bottom-Left-Tree-Value" class="headerlink" title="LeetCode-513. Find Bottom Left Tree Value"></a>LeetCode-513. Find Bottom Left Tree Value</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given the <code>root</code> of a binary tree, return the leftmost value in the last row of the tree.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [2,1,3]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3,4,null,5,6,null,null,7]</span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[1, 104]</code>.</li>
<li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>自己想的奇葩solution</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = helper(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">return</span> helper(root-&gt;left, level+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!root-&gt;left &amp;&amp; root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">return</span> helper(root-&gt;right, level+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;right)&#123; </span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l, r;</span><br><span class="line">            l = helper(root-&gt;left, level+<span class="number">1</span>);</span><br><span class="line">            r = helper(root-&gt;right, level+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(l[<span class="number">0</span>] &gt;= r[<span class="number">0</span>]) <span class="keyword">return</span> l;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;level, root-&gt;val&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>从右往左层次遍历，遍历一遍后，取最后一个节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q&#123;&#123;root&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            root = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right) q.push(root-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left) q.push(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LintCode-127. Topological Sorting</title>
    <url>/2021/06/21/LintCode-127-Topological-Sorting/</url>
    <content><![CDATA[<h1 id="LintCode-127-Topological-Sorting"><a href="#LintCode-127-Topological-Sorting" class="headerlink" title="LintCode-127. Topological Sorting"></a>LintCode-127. Topological Sorting</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://www.lintcode.com/problem/127/">https://www.lintcode.com/problem/127/</a></p>
<p>给定一个有向图，图节点的拓扑排序定义如下:</p>
<ul>
<li>对于图中的每一条有向边 <code>A -&gt; B</code> , 在拓扑排序中A一定在B之前.</li>
<li>拓扑排序中的第一个节点可以是图中的任何一个没有其他节点指向它的节点.</li>
</ul>
<p>针对给定的有向图找到任意一种拓扑排序的顺序.</p>
<p>你可以假设图中至少存在一种拓扑排序<a href="http://www.lintcode.com/help/graph">有关图的表示详情请看这里</a>图结点的个数 &lt;= 5000</p>
<p>样例</p>
<p><strong>样例 1：</strong></p>
<p>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph &#x3D; &#123;0,1,2,3#1,4#2,4,5#3,4,5#4#5&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[0, 1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>图如下所示:</p>
<p><img src="https://media-cdn.jiuzhang.com/markdown/images/8/6/91cf07d2-b7ea-11e9-bb77-0242ac110002.jpg" alt="picture"></p>
<p>拓扑排序可以为:<br>[0, 1, 2, 3, 4, 5]<br>[0, 2, 3, 1, 5, 4]<br>…<br>您只需要返回给定图的任何一种拓扑顺序。</p>
<p>挑战</p>
<p>能否分别用BFS和DFS完成？</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>BFS。</p>
<p>（1）求每个节点的入度</p>
<p>（2）将入度为0的节点放入queue。每次从queue中选出一个节点加入排序，并将其neighborNode的出度减1，若neighborNode的出度为0，则加入queue</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param graph: A list of Directed graph node</span></span><br><span class="line"><span class="comment">     * @return: Any topological order for the given graph.</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">    vector&lt;DirectedGraphNode*&gt; topSort(vector&lt;DirectedGraphNode*&gt; graph) &#123;</span></span><br><span class="line"><span class="comment">        // write your code here</span></span><br><span class="line"><span class="comment">        vector&lt;DirectedGraphNode*&gt; res;</span></span><br><span class="line"><span class="comment">        //graphNode在vector中的index，graphNode的邻居数</span></span><br><span class="line"><span class="comment">        map&lt;DirectedGraphNode*, int&gt; m;</span></span><br><span class="line"><span class="comment">        if(graph.empty()) return res;</span></span><br><span class="line"><span class="comment">        for(auto g : graph)&#123;</span></span><br><span class="line"><span class="comment">            for(auto n : g-&gt;neighbors)&#123;</span></span><br><span class="line"><span class="comment">                if(!m.count(n))&#123;</span></span><br><span class="line"><span class="comment">                    m[n]  = 1;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                else m[n]++;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        queue&lt;DirectedGraphNode*&gt; q;</span></span><br><span class="line"><span class="comment">        for(auto g : graph)&#123;</span></span><br><span class="line"><span class="comment">            if(m[g] == 0) q.push(g);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        while(!q.empty())&#123;</span></span><br><span class="line"><span class="comment">            DirectedGraphNode* curr = q.front();</span></span><br><span class="line"><span class="comment">            q.pop();</span></span><br><span class="line"><span class="comment">            res.push_back(curr);</span></span><br><span class="line"><span class="comment">            for(auto n : curr-&gt;neighbors)&#123;</span></span><br><span class="line"><span class="comment">                m[n]--;</span></span><br><span class="line"><span class="comment">                if(m[n] == 0) q.push(n);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return res;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br></pre></td></tr></table></figure>



<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>DFS。</p>
<p>（1）DFS想法比较神奇，对一个节点，遍历其所有neighbors，当所有neighbor都被visited了，再将当前节点插入排序队列</p>
<p>（2）这样得到的排序队列是逆序的，保证了当前节点的位置在所有neighbor节点的后面，故而最后要将res倒过来</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param graph: A list of Directed graph node</span></span><br><span class="line"><span class="comment">     * @return: Any topological order for the given graph.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;DirectedGraphNode*&gt; <span class="title">topSort</span><span class="params">(<span class="built_in">vector</span>&lt;DirectedGraphNode*&gt; graph)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="built_in">set</span>&lt;DirectedGraphNode*&gt; visited;</span><br><span class="line">        <span class="built_in">vector</span>&lt;DirectedGraphNode*&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n : graph)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.count(n))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            dfs(visited, n, res);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">set</span>&lt;DirectedGraphNode*&gt;&amp; visited, DirectedGraphNode* curr, <span class="built_in">vector</span>&lt;DirectedGraphNode*&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n : curr-&gt;neighbors)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.count(n)) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(visited, n, res);</span><br><span class="line">        &#125;</span><br><span class="line">        visited.insert(curr);</span><br><span class="line">        res.push_back(curr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>DFS</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-733. Flood Fill</title>
    <url>/2021/06/23/LeetCode-733-Flood-Fill/</url>
    <content><![CDATA[<h1 id="LeetCode-733-Flood-Fill"><a href="#LeetCode-733-Flood-Fill" class="headerlink" title="LeetCode-733. Flood Fill"></a>LeetCode-733. Flood Fill</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/flood-fill/">https://leetcode.com/problems/flood-fill/</a></p>
<p>An image is represented by an <code>m x n</code> integer grid <code>image</code> where <code>image[i][j]</code>represents the pixel value of the image.</p>
<p>You are also given three integers <code>sr</code>, <code>sc</code>, and <code>newColor</code>. You should perform a <strong>flood fill</strong> on the image starting from the pixel <code>image[sr][sc]</code>.</p>
<p>To perform a <strong>flood fill</strong>, consider the starting pixel, plus any pixels connected <strong>4-directionally</strong> to the starting pixel of the same color as the starting pixel, plus any pixels connected <strong>4-directionally</strong> to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with <code>newColor</code>.</p>
<p>Return <em>the modified image after performing the flood fill</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/06/01/flood1-grid.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: image &#x3D; [[1,1,1],[1,1,0],[1,0,1]], sr &#x3D; 1, sc &#x3D; 1, newColor &#x3D; 2</span><br><span class="line">Output: [[2,2,2],[2,2,0],[2,0,1]]</span><br><span class="line">Explanation: From the center of the image with position (sr, sc) &#x3D; (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.</span><br><span class="line">Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: image &#x3D; [[0,0,0],[0,0,0]], sr &#x3D; 0, sc &#x3D; 0, newColor &#x3D; 2</span><br><span class="line">Output: [[2,2,2],[2,2,2]]</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>这道题主要注意的是当oldColor=newColor时，可能会导致遍历到curr的领域neigborNode时，neigborNode又遍历回curr，将curr加回队列，然后循环无法结束。</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>使用visited数组，来记录节点有没有被遍历过，防止无穷循环。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; floodFill(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">//二维数组初始化？</span></span><br><span class="line">        <span class="keyword">int</span> visited[<span class="number">51</span>][<span class="number">51</span>] = &#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> value = image[sr][sc];</span><br><span class="line">        q.push(&#123;sr, sc&#125;);</span><br><span class="line">        visited[sr][sc] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> r = q.front().first, c = q.front().second; q.pop();</span><br><span class="line">            image[r][c]  = newColor;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> d : dirs)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = r+d[<span class="number">0</span>], y = c+d[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= image.size() || y &lt;<span class="number">0</span> || y &gt;= image[<span class="number">0</span>].size() || image[x][y]!=value || visited[x][y])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                q.push(&#123;x, y&#125;);</span><br><span class="line">                visited[x][y] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>直接当newColor和初始点一样时，返回原始image</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; floodFill(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">//二维数组初始化？</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> value = image[sr][sc];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(value == newColor) <span class="keyword">return</span> image;</span><br><span class="line">        q.push(&#123;sr, sc&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> r = q.front().first, c = q.front().second; q.pop();</span><br><span class="line">            image[r][c]  = newColor;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> d : dirs)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = r+d[<span class="number">0</span>], y = c+d[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= image.size() || y &lt;<span class="number">0</span> || y &gt;= image[<span class="number">0</span>].size() || image[x][y]!=value)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                q.push(&#123;x, y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h3><p>DFS.</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>DFS</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-994. Rotting Oranges</title>
    <url>/2021/06/23/LeetCode-994-Rotting-Oranges/</url>
    <content><![CDATA[<h1 id="LeetCode-994-Rotting-Oranges"><a href="#LeetCode-994-Rotting-Oranges" class="headerlink" title="LeetCode-994. Rotting Oranges"></a>LeetCode-994. Rotting Oranges</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/rotting-oranges/">https://leetcode.com/problems/rotting-oranges/</a></p>
<p>You are given an <code>m x n</code> <code>grid</code> where each cell can have one of three values:</p>
<ul>
<li><code>0</code> representing an empty cell,</li>
<li><code>1</code> representing a fresh orange, or</li>
<li><code>2</code> representing a rotten orange.</li>
</ul>
<p>Every minute, any fresh orange that is <strong>4-directionally adjacent</strong> to a rotten orange becomes rotten.</p>
<p>Return <em>the minimum number of minutes that must elapse until no cell has a fresh orange</em>. If <em>this is impossible, return</em> <code>-1</code>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/02/16/oranges.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: grid &#x3D; [[2,1,1],[1,1,0],[0,1,1]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: grid &#x3D; [[2,1,1],[0,1,1],[1,0,1]]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: grid &#x3D; [[0,2]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0.</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 10</code></li>
<li><code>grid[i][j]</code> is <code>0</code>, <code>1</code>, or <code>2</code>.</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>本题可以结合01 Matrix一起看，都是需要从多个初始点一起发散进行BFS搜索。</p>
<p>此题显然要记录BFS遍历的层数。</p>
<p>注意，</p>
<p>（1）要将每个腐烂的橘子当作一个起始点同时发散。先将所有初始grid中腐烂的橘子都放入queue中，作为第一层</p>
<p>（2）不要用两个for循环和visited试图遍历一个初始腐烂橘子的领域，再寻找一下个初始腐烂的橘子遍历领域</p>
<p>（3）需要记录BFS遍历的层数时，要先记录当前层的大小，int s_ = q.size()。不能直接for(int i =0; i&lt;q.size(); i++)，因为queue的大小一直在波动。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> fresh_fruit = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>) fresh_fruit++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j] == <span class="number">2</span>) q.push(&#123;i,j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.empty() &amp;&amp; fresh_fruit &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> s_ = q.size();</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s_; i++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> d : dir) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = cur[<span class="number">0</span>] + d[<span class="number">0</span>], y = cur[<span class="number">1</span>] + d[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || grid[x][y] != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    grid[x][y] = <span class="number">2</span>;</span><br><span class="line">                    q.push(&#123;x, y&#125;);</span><br><span class="line">                    fresh_fruit--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> fresh_fruit &gt; <span class="number">0</span> ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-127. Word Ladder</title>
    <url>/2021/06/25/LeetCode-127-Word-Ladder/</url>
    <content><![CDATA[<h1 id="LeetCode-127-Word-Ladder"><a href="#LeetCode-127-Word-Ladder" class="headerlink" title="LeetCode-127. Word Ladder"></a>LeetCode-127. Word Ladder</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/word-ladder/">https://leetcode.com/problems/word-ladder/</a></p>
<p>A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code> such that:</p>
<ul>
<li>Every adjacent pair of words differs by a single letter.</li>
<li>Every <code>si</code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li>
<li><code>sk == endWord</code></li>
</ul>
<p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>the <strong>number of words</strong> in the <strong>shortest transformation sequence</strong> from</em> <code>beginWord</code><em>to</em> <code>endWord</code><em>, or</em> <code>0</code> <em>if no such sequence exists.</em></p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: One shortest transformation sequence is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; cog&quot;, which is 5 words long.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= beginWord.length &lt;= 10</code></li>
<li><code>endWord.length == beginWord.length</code></li>
<li><code>1 &lt;= wordList.length &lt;= 5000</code></li>
<li><code>wordList[i].length == beginWord.length</code></li>
<li><code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.</li>
<li><code>beginWord != endWord</code></li>
<li>All the words in <code>wordList</code> are <strong>unique</strong>.</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Soution-1"><a href="#Soution-1" class="headerlink" title="Soution 1"></a>Soution 1</h3><p>这道题bfs的思想体现在刚开始，一个个字母地遍历查找，按照ait, bit,cit,…,zit, hat, hbt, …,hot地顺序搜索路径，当搜索到hot时，hot在wordList中。如果使用BFS方法，则将hot放入队列，继续遍历hpt, hqt, hrt。如果使用DFS的方法，则先将hot当作transformation sequence上的一个点，然后搜索hot应该转换成什么，即遍历aot, bot, cot, …</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">s</span><span class="params">(wordList.begin(), wordList.end())</span></span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        m[beginWord] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(beginWord.size() != endWord.size()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q&#123;&#123;beginWord&#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="built_in">string</span> curr = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; endWord.size(); i++)&#123;</span><br><span class="line">                <span class="built_in">string</span> newWord = curr;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> ch = <span class="string">&#x27;a&#x27;</span>; ch&lt;=<span class="string">&#x27;z&#x27;</span>; ch++)&#123;</span><br><span class="line">                    newWord[i] = ch;</span><br><span class="line">                    <span class="keyword">if</span>(s.count(newWord) &amp;&amp; newWord == endWord) <span class="keyword">return</span> m[curr]+<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//注意这句，没有在hash map中的，才加入队列</span></span><br><span class="line">                    <span class="keyword">if</span>(s.count(newWord)&amp;&amp;!m.count(newWord))&#123;</span><br><span class="line">                        m[newWord] = m[curr]+<span class="number">1</span>;</span><br><span class="line">                        q.push(newWord);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>这道题能否用DFS做？为什么用BFS做更好？</p>
<p>答：可能是因为搜索最小路径，BFS由一起始点开始，一层层向外遍历，第一个满足要求的，则为最小的路径。而DFS是一条路走到黑，可能选择的路径可以走到终点，但不是最小路径，所以要找到所有路径，才能比较出最小路径。</p>
<p>这道题不用hash_map记录路径长度的solution，其实也体现了BFS一层层不同可能性的分支节点同时遍历，层数同时增加（想象n叉树的遍历），所以每一层相对于跟节点的深度都是一样的，最早满足条件的即为最短路径。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">wordSet</span><span class="params">(wordList.begin(), wordList.end())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!wordSet.count(endWord)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q&#123;&#123;beginWord&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = q.size(); k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">                <span class="built_in">string</span> word = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span> (word == endWord) <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.size(); ++i) &#123;</span><br><span class="line">                    <span class="built_in">string</span> newWord = word;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">char</span> ch = <span class="string">&#x27;a&#x27;</span>; ch &lt;= <span class="string">&#x27;z&#x27;</span>; ++ch) &#123;</span><br><span class="line">                        newWord[i] = ch;</span><br><span class="line">                        <span class="keyword">if</span> (wordSet.count(newWord) &amp;&amp; newWord != word) &#123;</span><br><span class="line">                            q.push(newWord);</span><br><span class="line">                            wordSet.erase(newWord);</span><br><span class="line">                        &#125;   </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-841. Keys and Rooms</title>
    <url>/2021/06/25/LeetCode-841-Keys-and-Rooms/</url>
    <content><![CDATA[<h1 id="LeetCode-841-Keys-and-Rooms"><a href="#LeetCode-841-Keys-and-Rooms" class="headerlink" title="LeetCode-841. Keys and Rooms"></a>LeetCode-841. Keys and Rooms</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/keys-and-rooms/">https://leetcode.com/problems/keys-and-rooms/</a></p>
<p>There are <code>N</code> rooms and you start in room <code>0</code>. Each room has a distinct number in <code>0, 1, 2, ..., N-1</code>, and each room may have some keys to access the next room. </p>
<p>Formally, each room <code>i</code> has a list of keys <code>rooms[i]</code>, and each key <code>rooms[i][j]</code> is an integer in <code>[0, 1, ..., N-1]</code> where <code>N = rooms.length</code>. A key <code>rooms[i][j] = v</code> opens the room with number <code>v</code>.</p>
<p>Initially, all the rooms start locked (except for room <code>0</code>). </p>
<p>You can walk back and forth between rooms freely.</p>
<p>Return <code>true</code> if and only if you can enter every room.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1],[2],[3],[]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:  </span><br><span class="line">We start in room 0, and pick up key 1.</span><br><span class="line">We then go to room 1, and pick up key 2.</span><br><span class="line">We then go to room 2, and pick up key 3.</span><br><span class="line">We then go to room 3.  Since we were able to go to every room, we return true.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,3],[3,0,1],[2],[0]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: We can&#39;t enter the room with number 2.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= rooms.length &lt;= 1000</code></li>
<li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li>
<li>The number of keys in all rooms combined is at most <code>3000</code>.</li>
</ol>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>BFS</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canVisitAllRooms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; <span class="title">q</span><span class="params">(&#123;<span class="number">0</span>&#125;)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">visited_room</span><span class="params">(&#123;<span class="number">0</span>&#125;)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> visited_num = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> n : rooms[curr])&#123;</span><br><span class="line">                <span class="keyword">if</span>(visited_room.count(n)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    visited_room.insert(n);</span><br><span class="line">                    q.push(n);</span><br><span class="line">                    visited_num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> visited_num == rooms.size();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>DFS</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>DFS</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-105. Construct Binary Tree from Preorder and Inorder Traversal</title>
    <url>/2021/06/28/LeetCode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/</url>
    <content><![CDATA[<h1 id="LeetCode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#LeetCode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="LeetCode-105. Construct Binary Tree from Preorder and Inorder Traversal"></a>LeetCode-105. Construct Binary Tree from Preorder and Inorder Traversal</h1><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>
<p>Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return <em>the binary tree</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: preorder &#x3D; [-1], inorder &#x3D; [-1]</span><br><span class="line">Output: [-1]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= preorder.length &lt;= 3000</code></li>
<li><code>inorder.length == preorder.length</code></li>
<li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li>
<li><code>preorder</code> and <code>inorder</code> consist of <strong>unique</strong> values.</li>
<li>Each value of <code>inorder</code> also appears in <code>preorder</code>.</li>
<li><code>preorder</code> is <strong>guaranteed</strong> to be the preorder traversal of the tree.</li>
<li><code>inorder</code> is <strong>guaranteed</strong> to be the inorder traversal of the tree.</li>
</ul>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>（1）用四个指针，preLeft，preRight，iLeft，iRight标识preorder和inorder数组中同样的子树对应的节点。</p>
<p>（2）利用preorder找根节点，利用inorder帮助划分左子树和右子树区域。preorder[preLeft]的节点即为根节点，找到根节点在inorder中的位置i，可以由i-iLeft算出左子树节点个数，则preLeft+i-iLeft+1即为在preorder中右子树根节点的位置。</p>
<p>注意：此题使用hash map会超过时间限制</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, preorder.size()<span class="number">-1</span>, <span class="number">0</span>, preorder.size()<span class="number">-1</span>, preorder, inorder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="keyword">int</span> preLeft, <span class="keyword">int</span> preRight, <span class="keyword">int</span> iLeft, <span class="keyword">int</span> iRight, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preLeft &gt; preRight || iLeft &gt; iRight) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[preLeft]);</span><br><span class="line">        <span class="comment">//如果提前用hash map存储，则会超时</span></span><br><span class="line">        <span class="comment">//int i = m[preorder[preLeft]];</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = iLeft; i &lt; iRight; i++)</span><br><span class="line">            <span class="keyword">if</span>(preorder[preLeft] == inorder[i]) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        root-&gt;left = helper(preLeft+<span class="number">1</span>, i-iLeft+preLeft, iLeft, i<span class="number">-1</span>, preorder, inorder);</span><br><span class="line">        root-&gt;right = helper(preLeft+<span class="number">1</span>+i-iLeft, preRight, i+<span class="number">1</span>, iRight, preorder, inorder);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Tree的复原题目整理</title>
    <url>/2021/06/29/Tree%E7%9A%84%E5%A4%8D%E5%8E%9F%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="Tree的复原题目整理"><a href="#Tree的复原题目整理" class="headerlink" title="Tree的复原题目整理"></a>Tree的复原题目整理</h2><h3 id="1、LeetCode-105-已知前序和中序"><a href="#1、LeetCode-105-已知前序和中序" class="headerlink" title="1、LeetCode-105. 已知前序和中序"></a>1、LeetCode-105. 已知前序和中序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, preorder.size()<span class="number">-1</span>, <span class="number">0</span>, preorder.size()<span class="number">-1</span>, preorder, inorder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="keyword">int</span> preLeft, <span class="keyword">int</span> preRight, <span class="keyword">int</span> iLeft, <span class="keyword">int</span> iRight, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preLeft &gt; preRight || iLeft &gt; iRight) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[preLeft]);</span><br><span class="line">        <span class="comment">//如果提前用hash map存储，则会超时</span></span><br><span class="line">        <span class="comment">//int i = m[preorder[preLeft]];</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = iLeft; i &lt; iRight; i++)</span><br><span class="line">            <span class="keyword">if</span>(preorder[preLeft] == inorder[i]) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        root-&gt;left = helper(preLeft+<span class="number">1</span>, i-iLeft+preLeft, iLeft, i<span class="number">-1</span>, preorder, inorder);</span><br><span class="line">        root-&gt;right = helper(preLeft+<span class="number">1</span>+i-iLeft, preRight, i+<span class="number">1</span>, iRight, preorder, inorder);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="2、LeetCode-106-已知中序和后序"><a href="#2、LeetCode-106-已知中序和后序" class="headerlink" title="2、LeetCode-106. 已知中序和后序"></a>2、LeetCode-106. 已知中序和后序</h3><p>思路和1差不多。</p>
<p>（1）后序postRight是当前子树根节点。在中序中找到子树的根节点，根节点左右划分左子树和右子树范围。对应找到后续中的左子树和右子树的范围。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, postorder.size()<span class="number">-1</span>, postorder, <span class="number">0</span>, inorder.size()<span class="number">-1</span>, inorder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="keyword">int</span> pLeft, <span class="keyword">int</span> pRight, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> iLeft, <span class="keyword">int</span> iRight, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pLeft &gt; pRight || iLeft &gt; iRight) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* curr = <span class="keyword">new</span> TreeNode(postorder[pRight]);</span><br><span class="line">        <span class="keyword">int</span> i = iLeft;</span><br><span class="line">        <span class="keyword">for</span>(i = iLeft; i&lt;=iRight; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == postorder[pRight])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        curr-&gt;left = helper(pLeft, pLeft+i-iLeft<span class="number">-1</span>, postorder, iLeft, i<span class="number">-1</span>, inorder);</span><br><span class="line">        curr-&gt;right = helper(pLeft+i-iLeft, pRight<span class="number">-1</span>, postorder, i+<span class="number">1</span>, iRight, inorder);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="3、LeetCode-889-已知前序和后序-If-there-exists-multiple-answers-you-can-return-any-of-them"><a href="#3、LeetCode-889-已知前序和后序-If-there-exists-multiple-answers-you-can-return-any-of-them" class="headerlink" title="3、LeetCode-889. 已知前序和后序(If there exists multiple answers, you can return any of them.)"></a>3、LeetCode-889. 已知前序和后序(If there exists multiple answers, you can return any of them.)</h3><p>（1）preLeft和postRight都是当前子树根节点。preLeft+1是子树根节点（这里可以不详细考虑只有左子树或者只有右子树的情况。因为只有单棵情况下实际上只知道前序和后序，组成的树是有歧义的。例如前序1367，后续6731，不知道3是1的左子树根节点还是右子树根节点）。在post中找到子树根节点pre[preLeft+1]的位置，然后可以找到左右子树的范围。</p>
<p>（2）注意，因为与1、2、不同的地方在于，需要根据子树根节点preLeft+1划分左右子树范围，而不是根据当前树根节点划分子树范围。所以对于preLeft==postRight的情况需要单独处理，这种情况表示当前树只有一个节点，可以直接返回curr，停止遍历。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* constructFromPrePost(vector&lt;int&gt;&amp; pre, vector&lt;int&gt;&amp; post) &#123;</span><br><span class="line">        return helper(0, pre.size()-1, pre, 0, post.size()-1, post);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode* helper(int preLeft, int preRight, vector&lt;int&gt;&amp; pre, int postLeft, int postRight, vector&lt;int&gt;&amp; post)&#123;</span><br><span class="line">        if(preLeft &gt; preRight || postLeft &gt; postRight) return NULL;</span><br><span class="line">        </span><br><span class="line">        TreeNode* curr &#x3D; new TreeNode(pre[preLeft]);</span><br><span class="line">        &#x2F;&#x2F;此时当前子树只有一个节点了，直接返回根节点</span><br><span class="line">        if(preLeft &#x3D;&#x3D; preRight) return curr;</span><br><span class="line">        </span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        for(i &#x3D; postLeft; i &lt; postRight; i++)&#123;</span><br><span class="line">            if(post[i] &#x3D;&#x3D; pre[preLeft+1]) break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        curr-&gt;left &#x3D; helper(preLeft+1, i-postLeft+preLeft+1, pre, postLeft, i, post);</span><br><span class="line">        curr-&gt;right &#x3D; helper(i-postLeft+preLeft+2, preRight, pre, i+1, postRight-1, post);</span><br><span class="line">        </span><br><span class="line">        return curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
        <category>整理</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Tree遍历整理</title>
    <url>/2021/06/29/Tree%E9%81%8D%E5%8E%86%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="Tree遍历整理"><a href="#Tree遍历整理" class="headerlink" title="Tree遍历整理"></a>Tree遍历整理</h2><h3 id="一、递归法"><a href="#一、递归法" class="headerlink" title="一、递归法"></a>一、递归法</h3><h4 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h4><p>Preorder、Inorder差不多</p>
<h4 id="2、Preorder"><a href="#2、Preorder" class="headerlink" title="2、Preorder"></a>2、Preorder</h4><h3 id="一、迭代法"><a href="#一、迭代法" class="headerlink" title="一、迭代法"></a>一、迭代法</h3><h4 id="1、思路-1"><a href="#1、思路-1" class="headerlink" title="1、思路"></a>1、思路</h4><h5 id="1、Preorder"><a href="#1、Preorder" class="headerlink" title="1、Preorder"></a>1、Preorder</h5><p>使用栈。根节点出栈，加入res-&gt;右节点入栈-&gt;左节点入栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="function"><span class="built_in">stack</span>&lt;TreeNode*&gt; <span class="title">s_</span><span class="params">(&#123;root&#125;)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!s_.empty())&#123;</span><br><span class="line">            TreeNode* curr = s_.top(); s_.pop();</span><br><span class="line">            res.push_back(curr-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;right) s_.push(curr-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;left) s_.push(curr-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="2、Inorder"><a href="#2、Inorder" class="headerlink" title="2、Inorder"></a>2、Inorder</h5><h6 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h6><p>使用栈，但要用一个标识符标识此节点左节点有没有被遍历。若标识符为1，表示其左节点已经被遍历过，此时该节点应该被加入res。若标识符为2，表示其左节点还未被遍历过，应该入栈右节点，入栈此节点，入栈左节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">pair</span>&lt;TreeNode*, <span class="keyword">int</span>&gt;&gt; s_(&#123;&#123;root,<span class="number">0</span>&#125;&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!s_.empty())&#123;</span><br><span class="line">            <span class="built_in">pair</span>&lt;TreeNode*, <span class="keyword">int</span>&gt; curr = s_.top(); s_.pop();</span><br><span class="line">            <span class="keyword">if</span>(curr.second == <span class="number">1</span>) res.push_back(curr.first-&gt;val);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(curr.first-&gt;right) s_.push(&#123;curr.first-&gt;right, <span class="number">0</span>&#125;);</span><br><span class="line">                s_.push(&#123;curr.first, <span class="number">1</span>&#125;);</span><br><span class="line">                <span class="keyword">if</span>(curr.first-&gt;left) s_.push(&#123;curr.first-&gt;left, <span class="number">0</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        <span class="keyword">while</span> (p || !s.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p) &#123;</span><br><span class="line">                s.push(p);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            p = s.top(); s.pop();</span><br><span class="line">            res.push_back(p-&gt;val);</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="2、PostOrder"><a href="#2、PostOrder" class="headerlink" title="2、PostOrder"></a>2、PostOrder</h5><p>思路和Inorder的迭代法基本没有区别</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">pair</span>&lt;TreeNode*, <span class="keyword">int</span>&gt;&gt; s_(&#123;&#123;root,<span class="number">0</span>&#125;&#125;);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!s_.empty())&#123;</span><br><span class="line">            TreeNode* curr = s_.top().first;</span><br><span class="line">            <span class="keyword">int</span> flag = s_.top().second;</span><br><span class="line">            s_.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(flag) res.push_back(curr-&gt;val);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s_.push(&#123;curr, <span class="number">1</span>&#125;);</span><br><span class="line">                <span class="keyword">if</span>(curr-&gt;right) s_.push(&#123;curr-&gt;right, <span class="number">0</span>&#125;);</span><br><span class="line">                <span class="keyword">if</span>(curr-&gt;left) s_.push(&#123;curr-&gt;left, <span class="number">0</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>法二</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        TreeNode* curr = root, *pre = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!st.empty() || curr)&#123;</span><br><span class="line">            <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">                st.push(curr);</span><br><span class="line">                curr = curr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = st.top();</span><br><span class="line">          <span class="comment">//如果有curr-&gt;right，且curr-&gt;right没有被遍历过，则先去遍历curr-&gt;right</span></span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;right &amp;&amp; curr-&gt;right!=pre) curr = curr-&gt;right;</span><br><span class="line">          <span class="comment">//如果没有curr-&gt;right，或者curr-&gt;right已经被遍历过了，curr也可以加入res中，并且再向上回溯</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pre = curr;</span><br><span class="line">                res.push_back(curr-&gt;val);</span><br><span class="line">                st.pop();</span><br><span class="line">                curr = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
        <category>整理</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-173. Binary Search Tree Iterator</title>
    <url>/2021/07/01/LeetCode-173-Binary-Search-Tree-Iterator/</url>
    <content><![CDATA[<h1 id="LeetCode-173-Binary-Search-Tree-Iterator"><a href="#LeetCode-173-Binary-Search-Tree-Iterator" class="headerlink" title="LeetCode-173. Binary Search Tree Iterator"></a>LeetCode-173. Binary Search Tree Iterator</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/binary-search-tree-iterator/">https://leetcode.com/problems/binary-search-tree-iterator/</a></p>
<p>Implement the <code>BSTIterator</code> class that represents an iterator over the <strong><a href="https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)">in-order traversal</a></strong> of a binary search tree (BST):</p>
<ul>
<li><code>BSTIterator(TreeNode root)</code> Initializes an object of the <code>BSTIterator</code>class. The <code>root</code> of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.</li>
<li><code>boolean hasNext()</code> Returns <code>true</code> if there exists a number in the traversal to the right of the pointer, otherwise returns <code>false</code>.</li>
<li><code>int next()</code> Moves the pointer to the right, then returns the number at the pointer.</li>
</ul>
<p>Notice that by initializing the pointer to a non-existent smallest number, the first call to <code>next()</code> will return the smallest element in the BST.</p>
<p>You may assume that <code>next()</code> calls will always be valid. That is, there will be at least a next number in the in-order traversal when <code>next()</code> is called.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]</span><br><span class="line">[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]</span><br><span class="line">Output</span><br><span class="line">[null, 3, 7, true, 9, true, 15, true, 20, false]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">BSTIterator bSTIterator &#x3D; new BSTIterator([7, 3, 15, null, null, 9, 20]);</span><br><span class="line">bSTIterator.next();    &#x2F;&#x2F; return 3</span><br><span class="line">bSTIterator.next();    &#x2F;&#x2F; return 7</span><br><span class="line">bSTIterator.hasNext(); &#x2F;&#x2F; return True</span><br><span class="line">bSTIterator.next();    &#x2F;&#x2F; return 9</span><br><span class="line">bSTIterator.hasNext(); &#x2F;&#x2F; return True</span><br><span class="line">bSTIterator.next();    &#x2F;&#x2F; return 15</span><br><span class="line">bSTIterator.hasNext(); &#x2F;&#x2F; return True</span><br><span class="line">bSTIterator.next();    &#x2F;&#x2F; return 20</span><br><span class="line">bSTIterator.hasNext(); &#x2F;&#x2F; return False</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>主要是要学会中序遍历的迭代写法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BSTIterator(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            s_.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode* curr = s_.top();</span><br><span class="line">        s_.pop();</span><br><span class="line">        <span class="keyword">int</span> res = curr-&gt;val;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(curr-&gt;right)&#123;</span><br><span class="line">            curr = curr-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">                s_.push(curr);</span><br><span class="line">                curr = curr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !s_.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-230. Kth Smallest Element in a BST</title>
    <url>/2021/07/01/LeetCode-230-Kth-Smallest-Element-in-a-BST/</url>
    <content><![CDATA[<h1 id="LeetCode-230-Kth-Smallest-Element-in-a-BST"><a href="#LeetCode-230-Kth-Smallest-Element-in-a-BST" class="headerlink" title="LeetCode-230. Kth Smallest Element in a BST"></a>LeetCode-230. Kth Smallest Element in a BST</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">https://leetcode.com/problems/kth-smallest-element-in-a-bst/</a></p>
<p>Given the <code>root</code> of a binary search tree, and an integer <code>k</code>, return <em>the</em> <code>kth</code> (<strong>1-indexed</strong>) <em>smallest element in the tree</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is <code>n</code>.</li>
<li><code>1 &lt;= k &lt;= n &lt;= 104</code></li>
<li><code>0 &lt;= Node.val &lt;= 104</code></li>
</ul>
<p><strong>Follow up:</strong> If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>（1）二叉搜索树，想到中序遍历。中序遍历直接能获得排好序的二叉搜索树节点</p>
<h3 id="Soution-1"><a href="#Soution-1" class="headerlink" title="Soution 1"></a>Soution 1</h3><p>迭代法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s_;</span><br><span class="line">        TreeNode* curr = root;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(curr || !s_.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">                s_.push(curr);</span><br><span class="line">                curr = curr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = s_.top(); s_.pop();</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt == k) <span class="keyword">return</span> curr-&gt;val;</span><br><span class="line">            curr = curr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>递归法。不是特别理解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> val = helper(root-&gt;left, k);</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> val;</span><br><span class="line">        <span class="keyword">if</span>(--k == <span class="number">0</span>) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> helper(root-&gt;right, k);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Heap &amp; Stack</title>
    <url>/2021/07/01/Heap-Stack/</url>
    <content><![CDATA[<h1 id="Heap-amp-Stack"><a href="#Heap-amp-Stack" class="headerlink" title="Heap &amp; Stack"></a>Heap &amp; Stack</h1><p>参考资料：<a href="https://www.cnblogs.com/ricklz/p/10090969.html">https://www.cnblogs.com/ricklz/p/10090969.html</a></p>
<p><a href="https://blog.csdn.net/qq_34803821/article/details/87717205">https://blog.csdn.net/qq_34803821/article/details/87717205</a></p>
<h2 id="数据结构中的堆-amp-栈"><a href="#数据结构中的堆-amp-栈" class="headerlink" title="数据结构中的堆&amp;栈"></a>数据结构中的堆&amp;栈</h2><p>（1）栈：先进后出</p>
<p>（2）堆：二叉树，每个子节点都不大于（不小于）父节点，称为大顶堆（小顶堆）。编程时会使用priority_queue</p>
<h2 id="内存中的堆-amp-栈"><a href="#内存中的堆-amp-栈" class="headerlink" title="内存中的堆&amp;栈"></a>内存中的堆&amp;栈</h2><p>一半程序放在Rom（只读内存，比如硬盘）或Flash中，运行时拷贝到RAM中执行。</p>
<p>RAM存储信息结构如下图：</p>
<p>![image-20210701164033872](/Users/alice/Library/Application Support/typora-user-images/image-20210701164033872.png)</p>
<p>（1）栈从高地址-&gt;低地址分配，栈的最大容量事先由系统分配好</p>
<p>（2）堆低地址-&gt;高地址分配，是不连续的内存区域。</p>
<p>操作系统分配堆的操作：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的 delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中</p>
<p>（3）栈存储局部变量，系统自动分配，速度快。堆由new/malloc申请分配，速度慢，容易产生内存碎片和内存泄漏，需要delete/free。</p>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Heap</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-98. Validate Binary Search Tree</title>
    <url>/2021/07/02/Leetcode-98-Validate-Binary-Search-Tree/</url>
    <content><![CDATA[<h1 id="Leetcode-98-Validate-Binary-Search-Tree"><a href="#Leetcode-98-Validate-Binary-Search-Tree" class="headerlink" title="Leetcode-98. Validate Binary Search Tree"></a>Leetcode-98. Validate Binary Search Tree</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p>
<p>A <strong>valid BST</strong> is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [2,1,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [5,1,4,null,null,3,6]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The root node&#39;s value is 5 but its right child&#39;s value is 4.</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[1, 104]</code>.</li>
<li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>（1）先中序遍历一遍，存到res中</p>
<p>（2）再判断res是不是严格递增数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        inorder(root, res);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; res.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res[i] &lt;= res[i<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        inorder(root-&gt;left, res);</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        inorder(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>递归法</p>
<p>（1）注意，这道题并不能简单地将child和最近的parent节点比较，因为还需要满足和parent的parent之间的大小关系。所以递归的时候要保留一个max，一个min，来指代当前节点最大不能超过max，最小不能小于min。</p>
<p>（2）对于leftchild来说，因为其值要小于root，且root-&gt;val小于当前的max，因此max应该更新为root-&gt;val，min应该不变。</p>
<p>​        对于rightchild来说，因为其值要大于root，且root-&gt;val&gt;当前的min，因此min应该更新为root-&gt;val，max值应该不变。</p>
<p>（3）因为node值的范围为-2^31~2^31-1，故而应该将max和min设置为long类型的，否则会报错。</p>
<p>因为假如初始时max = INT_MAX, min = INT_MIN，而节点值为2^31-1或者-2^31，那么if(root-&gt;val &gt;= max || root-&gt;val &lt;= min) return false;会直接return false.，而实际上不一定会出错，如下示例：</p>
<p>![image-20210702120153877](/Users/alice/Library/Application Support/typora-user-images/image-20210702120153877.png)</p>
<p>所以为了更好地处理边界情况，将max和min改为long类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">return</span> helper(root, LONG_MAX, LONG_MIN);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//max表示当前节点最大不能大过max，min表示当前节点最小不能小过min</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">long</span> max, <span class="keyword">long</span> min)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt;= max || root-&gt;val &lt;= min) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(root-&gt;left, root-&gt;val, min) &amp;&amp; helper(root-&gt;right, max, root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-112. Path Sum</title>
    <url>/2021/07/03/Leetcode-112-Path-Sum/</url>
    <content><![CDATA[<h1 id="Leetcode-112-Path-Sum"><a href="#Leetcode-112-Path-Sum" class="headerlink" title="Leetcode-112. Path Sum"></a>Leetcode-112. Path Sum</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/path-sum/">https://leetcode.com/problems/path-sum/</a></p>
<p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <code>true</code> if the tree has a <strong>root-to-leaf</strong> path such that adding up all the values along the path equals <code>targetSum</code>.</p>
<p>A <strong>leaf</strong> is a node with no children.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3], targetSum &#x3D; 5</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2], targetSum &#x3D; 0</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>递归法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        targetSum = targetSum - root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; targetSum == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left, targetSum) || hasPathSum(root-&gt;right, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>迭代法。</p>
<p>其实就是先序遍历，然后顺便计算现在累加数。比较讨巧的是，直接改变node的val来积累累加数，而不是另外设置变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function"><span class="built_in">stack</span>&lt;TreeNode*&gt; <span class="title">s</span><span class="params">(&#123;root&#125;)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            TreeNode* curr = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;val == targetSum &amp;&amp; !curr-&gt;left &amp;&amp; !curr-&gt;right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;right)&#123;</span><br><span class="line">                curr-&gt;right-&gt;val += curr-&gt;val;</span><br><span class="line">                s.push(curr-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;left)&#123;</span><br><span class="line">                curr-&gt;left-&gt;val += curr-&gt;val;</span><br><span class="line">                s.push(curr-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-113. Path Sum||</title>
    <url>/2021/07/09/LeetCode-113-Path-Sum/</url>
    <content><![CDATA[<h1 id="LeetCode-113-Path-Sum"><a href="#LeetCode-113-Path-Sum" class="headerlink" title="LeetCode-113. Path Sum||"></a>LeetCode-113. Path Sum||</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return all <strong>root-to-leaf</strong>paths where each path’s sum equals <code>targetSum</code>.</p>
<p>A <strong>leaf</strong> is a node with no children.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22</span><br><span class="line">Output: [[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3], targetSum &#x3D; 5</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2], targetSum &#x3D; 0</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>递归法</p>
<p>直接先序遍历，当当前节点是叶节点，且pathSum满足要求，将当前路径加入res。</p>
<p><b>注意：这里的vector curr只能传值，不能传地址，否则记录的path会错乱</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> targetSum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;    </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr;</span><br><span class="line">        helper(root, res, curr, targetSum);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        curr.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; target == root-&gt;val)&#123;</span><br><span class="line">            res.push_back(curr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        helper(root-&gt;left, res, curr, target-root-&gt;val);</span><br><span class="line">        helper(root-&gt;right, res, curr, target-root-&gt;val);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>迭代法</p>
<p>说是中序遍历的思想，但我觉得有点像后续遍历。后续遍历能否这样写出递归的方式???<br>（1）注意：需要利用vector来模拟栈，因为需要统计路上遇到的node<br>（2）注意，遍历时，curr要面临遍历curr-&gt;right，以及curr-&gt;right已经遍历过，要将curr从路径中删除两种选择。需要记录curr的上一个node，来判断curr-&gt;right有没有遍历过。<br>（3）如果要将curr从路径中删除，要置curr=NULL。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> targetSum)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>&#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* curr = root, *pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!st.empty() || curr)&#123;</span><br><span class="line">            <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">                st.push_back(curr);</span><br><span class="line">                value += curr-&gt;val;</span><br><span class="line">                curr = curr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = st.back();</span><br><span class="line">            <span class="keyword">if</span>(!curr-&gt;left &amp;&amp; !curr-&gt;right &amp;&amp; value == targetSum)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> s : st) v.push_back(s-&gt;val);</span><br><span class="line">                res.push_back(v);</span><br><span class="line">            &#125; </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;right &amp;&amp; curr-&gt;right != pre)&#123;</span><br><span class="line">                curr = curr-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//else语句实际上是回退操作。如左图的11。因为遍历右子树时，不想标准的中序遍历写法，没有将11移出st。所以从11的左子树回溯可能到达11，从11的右子树回溯，也可能到达11。pre记录了此次回溯到11时，前一个节点是左子节点还是右子节点。若是7，则应该遍历11的右子树。若是2，则应该将11从路径中删除，继续回溯。</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pre = curr;</span><br><span class="line">                value -= curr-&gt;val;</span><br><span class="line">                st.pop_back();</span><br><span class="line">                <span class="comment">//令curr=NULL，而不是st.back()是因为防止再遍历一次st.back()的左子树</span></span><br><span class="line">                curr = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>根据此思路写出来的后续遍历：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        TreeNode* curr = root, *pre = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!st.empty() || curr)&#123;</span><br><span class="line">            <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">                st.push(curr);</span><br><span class="line">                curr = curr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = st.top();</span><br><span class="line">          <span class="comment">//如果有curr-&gt;right，且curr-&gt;right没有被遍历过，则先去遍历curr-&gt;right</span></span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;right &amp;&amp; curr-&gt;right!=pre) curr = curr-&gt;right;</span><br><span class="line">          <span class="comment">//如果没有curr-&gt;right，或者curr-&gt;right已经被遍历过了，curr也可以加入res中，并且再向上回溯</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pre = curr;</span><br><span class="line">                res.push_back(curr-&gt;val);</span><br><span class="line">                st.pop();</span><br><span class="line">                curr = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-124. Binary Tree Maximum Path Sum</title>
    <url>/2021/07/09/LeetCode-124-Binary-Tree-Maximum-Path-Sum/</url>
    <content><![CDATA[<h1 id="LeetCode-124-Binary-Tree-Maximum-Path-Sum"><a href="#LeetCode-124-Binary-Tree-Maximum-Path-Sum" class="headerlink" title="LeetCode-124. Binary Tree Maximum Path Sum"></a>LeetCode-124. Binary Tree Maximum Path Sum</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>A <strong>path</strong> in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence <strong>at most once</strong>. Note that the path does not need to pass through the root.</p>
<p>The <strong>path sum</strong> of a path is the sum of the node’s values in the path.</p>
<p>Given the <code>root</code> of a binary tree, return <em>the maximum <strong>path sum</strong> of any path</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The optimal path is 2 -&gt; 1 -&gt; 3 with a path sum of 2 + 1 + 3 &#x3D; 6.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [-10,9,20,null,null,15,7]</span><br><span class="line">Output: 42</span><br><span class="line">Explanation: The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 &#x3D; 42.</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[1, 3 * 104]</code>.</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> a=depth(root-&gt;left), b=depth(root-&gt;right);</span><br><span class="line">        res=max(res,a+b+root-&gt;val);<span class="comment">//if *root is the top node in the path</span></span><br><span class="line">        <span class="keyword">return</span> max(<span class="number">0</span>,max(a, b)+root-&gt;val);<span class="comment">//if *root is in the path, if this branch a burden or a plus</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        res=root-&gt;val;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-199. Binary Tree Right Side View</title>
    <url>/2021/07/09/LeetCode-199-Binary-Tree-Right-Side-View/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LeetCode-236. Lowest Common Ancestor of a Binary Tree</title>
    <url>/2021/07/09/LeetCode-236-Lowest-Common-Ancestor-of-a-Binary-Tree/</url>
    <content><![CDATA[<h1 id="LeetCode-236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#LeetCode-236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="LeetCode-236. Lowest Common Ancestor of a Binary Tree"></a>LeetCode-236. Lowest Common Ancestor of a Binary Tree</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>
<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The LCA of nodes 5 and 1 is 3.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[2, 105]</code>.</li>
<li><code>-109 &lt;= Node.val &lt;= 109</code></li>
<li>All <code>Node.val</code> are <strong>unique</strong>.</li>
<li><code>p != q</code></li>
<li><code>p</code> and <code>q</code> will exist in the tree.</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>（1）p和q分别在right和left中，则返回root。</p>
<p>（2）p和q同时在right和left中，则返回非空的那一个</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root || p == root || q == root) <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="comment">//如果p和q分别在root的两个子树中，返回root</span></span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//p和q同时在root的left子树或root的right子树中</span></span><br><span class="line">        <span class="keyword">return</span> left ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>优化后的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root || p == root || q == root) <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        <span class="comment">//此种情况下表示，left返回的是q和p的最近祖先，表示p和q同时在左子树中，此时直接return，省去右子树的遍历。若left存在，且left==q||left==p，并不能确定q和p同时在左子树中，还是有分别在左右子树中，需要遍历右子树</span></span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; left != q &amp;&amp; left != p) <span class="keyword">return</span> left;</span><br><span class="line">        </span><br><span class="line">        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(right &amp;&amp; left) <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-331. Verify Preorder Serialization of a Binary Tree</title>
    <url>/2021/07/10/LeetCode-331-Verify-Preorder-Serialization-of-a-Binary-Tree/</url>
    <content><![CDATA[<h1 id="LeetCode-331-Verify-Preorder-Serialization-of-a-Binary-Tree"><a href="#LeetCode-331-Verify-Preorder-Serialization-of-a-Binary-Tree" class="headerlink" title="LeetCode-331. Verify Preorder Serialization of a Binary Tree"></a>LeetCode-331. Verify Preorder Serialization of a Binary Tree</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/">https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/</a></p>
<p>One way to serialize a binary tree is to use <strong>preorder traversal</strong>. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as <code>&#39;#&#39;</code>.</p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/12/pre-tree.jpg" alt="img"></p>
<p>For example, the above binary tree can be serialized to the string <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>, where <code>&#39;#&#39;</code> represents a null node.</p>
<p>Given a string of comma-separated values <code>preorder</code>, return <code>true</code> if it is a correct preorder traversal serialization of a binary tree.</p>
<p>It is <strong>guaranteed</strong> that each comma-separated value in the string must be either an integer or a character <code>&#39;#&#39;</code> representing null pointer.</p>
<p>You may assume that the input format is always valid.</p>
<ul>
<li>For example, it could never contain two consecutive commas, such as <code>&quot;1,,3&quot;</code>.</li>
</ul>
<p><strong>Note:</strong> You are not allowed to reconstruct the tree.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: preorder &#x3D; &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: preorder &#x3D; &quot;1,#&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: preorder &#x3D; &quot;9,#,#,1&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= preorder.length &lt;= 104</code></li>
<li><code>preoder</code> consist of integers in the range <code>[0, 100]</code> and <code>&#39;#&#39;</code> separated by commas <code>&#39;,&#39;</code>.</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>判断是否是先序的方式：（1）#比数字多一个（2）最后一个一定是#号（怎么找到的规律？？？）</p>
<p><b>注意：c++没有split，拆分字符串需要用到getline(in, t, ‘,’)，其中in为字符流，t为分割后得到的字符串，’,’为分割符</b></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSerialization</span><span class="params">(<span class="built_in">string</span> preorder)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(preorder)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">        <span class="built_in">string</span> t = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(getline(in, t, <span class="string">&#x27;,&#x27;</span>)) v.push_back(t);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i] == <span class="string">&quot;#&quot;</span>)&#123;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span>(count &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span> &amp;&amp; v.back() == <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-449. Serialize and Deserialize BST</title>
    <url>/2021/07/10/LeetCode-449-Serialize-and-Deserialize-BST/</url>
    <content><![CDATA[<h1 id="LeetCode-449-Serialize-and-Deserialize-BST"><a href="#LeetCode-449-Serialize-and-Deserialize-BST" class="headerlink" title="LeetCode-449. Serialize and Deserialize BST"></a>LeetCode-449. Serialize and Deserialize BST</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/serialize-and-deserialize-bst/">https://leetcode.com/problems/serialize-and-deserialize-bst/</a></p>
<p>Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>
<p>Design an algorithm to serialize and deserialize a <strong>binary search tree</strong>. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.</p>
<p><strong>The encoded string should be as compact as possible.</strong></p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [2,1,3]</span><br><span class="line">Output: [2,1,3]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[0, 104]</code>.</li>
<li><code>0 &lt;= Node.val &lt;= 104</code></li>
<li>The input tree is <strong>guaranteed</strong> to be a binary search tree.</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>基本上和LeetCode-297. Serialize and Deserialize Binary Tree <a href="https://yachialice.gitee.io/2021/06/18/LeetCode-297-Serialize-and-Deserialize-Binary-Tree/#LeetCode-297-Serialize-and-Deserialize-Binary-Tree%E4%B8%80%E6%A0%B7">https://yachialice.gitee.io/2021/06/18/LeetCode-297-Serialize-and-Deserialize-Binary-Tree/#LeetCode-297-Serialize-and-Deserialize-Binary-Tree一样</a></p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>层序遍历迭代法</p>
<p>（1）注意，空指针也可以直接加入queue，所以遍历的时候不需要特别处理。出队的时候，遇到空指针，加”# “到string里即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">ostringstream</span> out;</span><br><span class="line">        <span class="function"><span class="built_in">queue</span>&lt;TreeNode*&gt; <span class="title">q</span><span class="params">(&#123;root&#125;)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            TreeNode* curr = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span>(curr)&#123;</span><br><span class="line">                out &lt;&lt; curr-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                q.push(curr-&gt;left);</span><br><span class="line">                q.push(curr-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                out &lt;&lt; <span class="string">&quot;# &quot;</span>;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> out.str();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.empty()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> val;</span><br><span class="line">        in &gt;&gt; val;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(stoi(val));</span><br><span class="line">        <span class="function"><span class="built_in">queue</span>&lt;TreeNode*&gt; <span class="title">q</span><span class="params">(&#123;root&#125;)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            TreeNode* curr = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span>(in &gt;&gt; val)&#123;</span><br><span class="line">               <span class="keyword">if</span>(val == <span class="string">&quot;#&quot;</span>) curr-&gt;left = <span class="literal">NULL</span>; </span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    TreeNode* left = <span class="keyword">new</span> TreeNode(stoi(val));</span><br><span class="line">                    q.push(left);</span><br><span class="line">                    curr-&gt;left = left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="keyword">if</span>(in &gt;&gt; val)&#123;</span><br><span class="line">                <span class="keyword">if</span>(val == <span class="string">&quot;#&quot;</span>) curr-&gt;right = <span class="literal">NULL</span>;   </span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    TreeNode* right = <span class="keyword">new</span> TreeNode(stoi(val));</span><br><span class="line">                    q.push(right);</span><br><span class="line">                    curr-&gt;right = right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>先序递归法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ostringstream</span> out;</span><br><span class="line">        serialize(root, out);</span><br><span class="line">        <span class="keyword">return</span> out.str();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> deserialize(in);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode* root, <span class="built_in">ostringstream</span>&amp; out)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            out &lt;&lt; <span class="string">&quot;# &quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        out &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        serialize(root-&gt;left, out);</span><br><span class="line">        serialize(root-&gt;right, out);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">istringstream</span>&amp; in)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> val;</span><br><span class="line">        in &gt;&gt; val;</span><br><span class="line">        <span class="keyword">if</span>(val == <span class="string">&quot;#&quot;</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* curr = <span class="keyword">new</span> TreeNode(stoi(val));</span><br><span class="line">        curr-&gt;left = deserialize(in);</span><br><span class="line">        curr-&gt;right = deserialize(in);</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-39. Combination Sum</title>
    <url>/2021/07/19/LeetCode-39-Combination-Sum/</url>
    <content><![CDATA[<h1 id="LeetCode-39-Combination-Sum"><a href="#LeetCode-39-Combination-Sum" class="headerlink" title="LeetCode-39. Combination Sum"></a>LeetCode-39. Combination Sum</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/combination-sum/">https://leetcode.com/problems/combination-sum/</a></p>
<p>Given an array of <strong>distinct</strong> integers <code>candidates</code> and a target integer <code>target</code>, return <em>a list of all <strong>unique combinations</strong> of</em> <code>candidates</code> <em>where the chosen numbers sum to</em> <code>target</code><em>.</em> You may return the combinations in <strong>any order</strong>.</p>
<p>The <strong>same</strong> number may be chosen from <code>candidates</code> an <strong>unlimited number of times</strong>. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</p>
<p>It is <strong>guaranteed</strong> that the number of unique combinations that sum up to <code>target</code> is less than <code>150</code> combinations for the given input.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates &#x3D; [2,3,6,7], target &#x3D; 7</span><br><span class="line">Output: [[2,2,3],[7]]</span><br><span class="line">Explanation:</span><br><span class="line">2 and 3 are candidates, and 2 + 2 + 3 &#x3D; 7. Note that 2 can be used multiple times.</span><br><span class="line">7 is a candidate, and 7 &#x3D; 7.</span><br><span class="line">These are the only two combinations.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates &#x3D; [2,3,5], target &#x3D; 8</span><br><span class="line">Output: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates &#x3D; [2], target &#x3D; 1</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates &#x3D; [1], target &#x3D; 1</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates &#x3D; [1], target &#x3D; 2</span><br><span class="line">Output: [[1,1]]</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>很经典的一道dfs题目。</p>
<p>因为题目中的元素可以无限重复，因而每一次dfs遍历时：dfs(curr, candidates, res, target-candidates[i], i)，注意最后一个参数为i，而不是start。意思是，下一个加入curr的元素还可以是当前元素i。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr;</span><br><span class="line">        </span><br><span class="line">        dfs(curr, candidates, res, target, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意这里curr可以用&amp;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; curr, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            res.push_back(curr);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.size(); i++)&#123;</span><br><span class="line">            curr.push_back(candidates[i]);</span><br><span class="line">            dfs(curr, candidates, res, target-candidates[i], i);</span><br><span class="line">            curr.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Backtracking</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-40. Combination Sum ||</title>
    <url>/2021/07/19/LeetCode-40-Combination-Sum/</url>
    <content><![CDATA[<h1 id="LeetCode-40-Combination-Sum"><a href="#LeetCode-40-Combination-Sum" class="headerlink" title="LeetCode-40. Combination Sum ||"></a>LeetCode-40. Combination Sum ||</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/combination-sum-ii/">https://leetcode.com/problems/combination-sum-ii/</a></p>
<p>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sum to <code>target</code>.</p>
<p>Each number in <code>candidates</code> may only be used <strong>once</strong> in the combination.</p>
<p><strong>Note:</strong> The solution set must not contain duplicate combinations.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8</span><br><span class="line">Output: </span><br><span class="line">[</span><br><span class="line">[1,1,6],</span><br><span class="line">[1,2,5],</span><br><span class="line">[1,7],</span><br><span class="line">[2,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5</span><br><span class="line">Output: </span><br><span class="line">[</span><br><span class="line">[1,2,2],</span><br><span class="line">[5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= candidates.length &lt;= 100</code></li>
<li><code>1 &lt;= candidates[i] &lt;= 50</code></li>
<li><code>1 &lt;= target &lt;= 30</code></li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>有点类似于39.Combination。</p>
<p>（1）因为candidates中的元素会重复，且res中的vector需要时unique的。因而要加入if(i &gt; start &amp;&amp; candidates[i] == candidates[i-1]) continue;这样可以避免重复元素出现。<br><b>区分和47、90的写法区别！！！！！</b></p>
<p>（2）因为candidates中的元素不能多次使用，所以下次dfs的start从i+1开始</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr;</span><br><span class="line">        dfs(res, curr, candidates, <span class="number">0</span>, target);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; curr, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> start, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            res.push_back(curr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.size(); i++)&#123;</span><br><span class="line">            <span class="comment">//不要写作i&gt;0&amp;&amp;candidats[i]==candidates[i-1]。</span></span><br><span class="line">            <span class="comment">//注意下面这句话怎么理解。</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            curr.push_back(candidates[i]);</span><br><span class="line">          <span class="comment">//注意这里i+1</span></span><br><span class="line">            dfs(res, curr, candidates, i+<span class="number">1</span>, target-candidates[i]);</span><br><span class="line">            curr.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Backtracking</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-46. Permutations</title>
    <url>/2021/07/19/LeetCode-46-Permutations/</url>
    <content><![CDATA[<h1 id="LeetCode-46-Permutations"><a href="#LeetCode-46-Permutations" class="headerlink" title="LeetCode-46. Permutations"></a>LeetCode-46. Permutations</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/permutations/">https://leetcode.com/problems/permutations/</a></p>
<p>Given an array <code>nums</code> of distinct integers, return <em>all the possible permutations</em>. You can return the answer in <strong>any order</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1]</span><br><span class="line">Output: [[0,1],[1,0]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1]</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 6</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li>All the integers of <code>nums</code> are <strong>unique</strong>.</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>（1）因为是nums中的元素是dstinct的，所以不考虑重复情况</p>
<p>（2）建立一个dp，注意dp使用vector类型，不要使用int[]类型。不能这样：int dp[nums.size()]声明。</p>
<p>（3）每次从i=0开始遍历，如果dp[i]==1，则continue。pop()的时候，也要记得修改dp[i] = 0;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr;</span><br><span class="line">        </span><br><span class="line">        dfs(res, curr, nums, dp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; curr, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.size() == nums.size())&#123;</span><br><span class="line">            res.push_back(curr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            curr.push_back(nums[i]);</span><br><span class="line">            dfs(res, curr, nums, dp);</span><br><span class="line">            curr.pop_back();</span><br><span class="line">            dp[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Backtracking</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-47. Permutations||</title>
    <url>/2021/07/19/LeetCode-47-Permutations/</url>
    <content><![CDATA[<h1 id="LeetCode-47-Permutations"><a href="#LeetCode-47-Permutations" class="headerlink" title="LeetCode-47. Permutations||"></a>LeetCode-47. Permutations||</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/permutations-ii/">https://leetcode.com/problems/permutations-ii/</a></p>
<p>Given a collection of numbers, <code>nums</code>, that might contain duplicates, return <em>all possible unique permutations <strong>in any order</strong>.</em></p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,2]</span><br><span class="line">Output:</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 8</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>（1）不是distinct nums，所以先排序</p>
<p>（2）因为要跳过重复的，所以遍历时，if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; dp[i-1] == 0) continue;这句话中dp[i-1]==0的限制可以理解为，我们其实将nums排序后，相等的元素看作不同的，比如2(1)，2(2)，2(3)。我们希望每次2存在于curr中时，无论有几个2，能保证2(1)，2(2)，2(3)的优先级进入curr。比如curr中只有一个2，必然是2(1)；两个2，必然是2(1)，2(2)；三个2，必然是2(1)，2(2)，2(3)。所以如果前面的2不再curr中，后面的2没有被加入curr中的机会。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        </span><br><span class="line">        dfs(res, curr, dp, nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; curr, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; dp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.size() == nums.size())&#123;</span><br><span class="line">            res.push_back(curr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//dp[i-1]==0的限制条件主要在于，保证排序过的数组nums，相同的数字要按照nums中的顺序在curr中出现。</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &amp;&amp; dp[i<span class="number">-1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            curr.push_back(nums[i]);</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            dfs(res, curr, dp, nums);</span><br><span class="line">            curr.pop_back();</span><br><span class="line">            dp[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Backtracking</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker学习</title>
    <url>/2021/07/24/Docker%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Docker学习"><a href="#Docker学习" class="headerlink" title="Docker学习"></a>Docker学习</h1><h2 id="Docker构架"><a href="#Docker构架" class="headerlink" title="Docker构架"></a>Docker构架</h2><p>1、镜像（Image）：类似于类，需要基于镜像创建容器，才可以运行。一个镜像可以创建多个容器。</p>
<p>2、容器（Container）：类似于对象。使用的时候运行、停止、创建容器，在容器内进行操作。</p>
<p>3、仓库（Repository）：镜像的仓库。一个Docker Registry中可以包含多个仓库（Repository）。一个仓库中包含一个软件镜像的多个版本，例如Ubuntu 15.10，Ubuntu 14.0，利用tag标识这个镜像是哪个版本，方便创造环境。利用docker images可以看到所有镜像。</p>
<p>![image-20210712161900494](/Users/alice/Library/Application Support/typora-user-images/image-20210712161900494.png)</p>
<p>Docker构架示意图</p>
<p>![image-20210712161929702](/Users/alice/Library/Application Support/typora-user-images/image-20210712161929702.png)</p>
<h2 id="Docker相关指令"><a href="#Docker相关指令" class="headerlink" title="Docker相关指令"></a>Docker相关指令</h2><h3 id="0、docker帮助"><a href="#0、docker帮助" class="headerlink" title="0、docker帮助"></a>0、docker帮助</h3><p>以下指令查看所有docker命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker</span><br></pre></td></tr></table></figure>

<p>以下指令查看COMMAND指令的具体用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker COMMAND --help</span><br></pre></td></tr></table></figure>



<h3 id="1、docker容器操作"><a href="#1、docker容器操作" class="headerlink" title="1、docker容器操作"></a>1、docker容器操作</h3><h4 id="（1）创建一个新容器"><a href="#（1）创建一个新容器" class="headerlink" title="（1）创建一个新容器"></a>（1）创建一个新容器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker run -i -t ubuntu:15.10 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>-t：在新容器内指定一个终端或伪终端</p>
<p>-i：允许对容器内的标准输入（STDIN）进行交互</p>
<p>ubuntu:15.10：镜像版本，是ubuntu仓库中，tag为15.10版本。</p>
<p>/bin/bash：容器中执行的命令。</p>
<p><b>如果当前仓库中没有指定镜像，那么docker会在执行此命令时从远程库中pull一个到本地</b></p>
<p>也可以使用如下命令，-d是后台运行，不会自动进入到容器内部</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker run -itd ubuntu:15.10 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<h4 id="（2）查看现有容器"><a href="#（2）查看现有容器" class="headerlink" title="（2）查看现有容器"></a>（2）查看现有容器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;查看运行容器</span><br><span class="line">docker ps</span><br><span class="line">&#x2F;&#x2F;查看所有容器</span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<h4 id="（3）进入容器"><a href="#（3）进入容器" class="headerlink" title="（3）进入容器"></a>（3）进入容器</h4><p>一般在docker run时，执行/bin/bash命令，就会进入容器内部，如下图，表示进入了container id为4eda299a523a的容器内。</p>
<p>![image-20210712162902996](/Users/alice/Library/Application Support/typora-user-images/image-20210712162902996.png)</p>
<p>如果在docker run时使用了-d参数，则默认不会进入容器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -i -t -d ubuntu:15.10 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>如果需要进入容器，需要使用以下指令：</p>
<p><b>（a）使用docker exec进入容器</b></p>
<p>例：其中，243c32535da7为container id，可以通过docker ps指令查看。</p>
<p><b>docker exec指令必须带有参数container id以及operation，这里的operation位/bin/bash</b></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it 243c32535da7 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p><b>使用docker exec指令，使用exit退出容器时不会导致容器停止，而docker attach会</b></p>
<p><b>（b）使用docker attaach进入容器</b></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker attach 243c32535da7</span><br></pre></td></tr></table></figure>

<h4 id="（3）运行、停止、删除容器"><a href="#（3）运行、停止、删除容器" class="headerlink" title="（3）运行、停止、删除容器"></a>（3）运行、停止、删除容器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;停止</span><br><span class="line">docker stop [CONTAINER ID]</span><br><span class="line">&#x2F;&#x2F;运行</span><br><span class="line">docker start [CONTAINER ID]</span><br><span class="line">docker restart [CONTAINER ID]</span><br><span class="line">&#x2F;&#x2F;删除,-f表示强制</span><br><span class="line">docker rm -f [CONTAINER ID]</span><br><span class="line">&#x2F;&#x2F;删除所有处于终止状态容器</span><br><span class="line">docker container prune</span><br></pre></td></tr></table></figure>

<h4 id="（4）docker端口映射"><a href="#（4）docker端口映射" class="headerlink" title="（4）docker端口映射"></a>（4）docker端口映射</h4><p> 参考资料：<a href="https://www.cnblogs.com/wholj/p/10551999.html">https://www.cnblogs.com/wholj/p/10551999.html</a></p>
<p>docker容器在启动的时候,如果不指定<em>端口映射</em>参数,在容器外部是无法通过网络来访问容器内的网络应用和服务的</p>
<p>示例1：利用-P将容器内部使用的网络端口映射到本地主机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~# docker run -d -P training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure>

<p><b>（a）通过以下指令，查看端口映射结果</b></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p>![image-20210712155036392](/Users/alice/Library/Application Support/typora-user-images/image-20210712155036392.png)</p>
<p>可见是将容器5000的端口号映射到了本地55000端口。</p>
<p><b>（b）也可通过以下指令查看端口映射。</b></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker port CONTAINERID</span><br></pre></td></tr></table></figure>

<p>示例2：利用-p指定映射端口和ip地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:5000:5000 training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure>

<p>将容器的5000端口映射到指定地址127.0.0.1的5000端口上。打开<a href="http://127.0.0.1:5000即可看到网页。">http://127.0.0.1:5000即可看到网页。</a></p>
<h3 id="2、Docker镜像操作"><a href="#2、Docker镜像操作" class="headerlink" title="2、Docker镜像操作"></a>2、Docker镜像操作</h3><h4 id="（1）查看素有镜像"><a href="#（1）查看素有镜像" class="headerlink" title="（1）查看素有镜像"></a>（1）查看素有镜像</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;列出主机上的镜像</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p>![image-20210712164634889](/Users/alice/Library/Application Support/typora-user-images/image-20210712164634889.png)</p>
<p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，使用 REPOSITORY:TAG 来定义不同的镜像，例如：ubuntu:15.10</p>
<h4 id="（2）获取、查找镜像"><a href="#（2）获取、查找镜像" class="headerlink" title="（2）获取、查找镜像"></a>（2）获取、查找镜像</h4><p><b>（a）获取镜像，docker pull</b></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu:13.10</span><br></pre></td></tr></table></figure>

<p><b>（b）查找镜像，docker search [IMAGE NAME]。</b></p>
<p>例如查找ubuntu镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search ubuntu</span><br></pre></td></tr></table></figure>

<p>![image-20210712165051800](/Users/alice/Library/Application Support/typora-user-images/image-20210712165051800.png)</p>
<p>其中，</p>
<p>NAME：镜像名字</p>
<p>STARS：点赞数</p>
<p>OFFICIAL：是否官方镜像</p>
<p>AUTOMATED：自动构建（？）</p>
<p>搜到所需镜像后，使用docker pull [IMAGE NAME] 即可下载镜像。</p>
<h4 id="（3）创建镜像"><a href="#（3）创建镜像" class="headerlink" title="（3）创建镜像"></a>（3）创建镜像</h4><p>参考资料：<a href="https://www.runoob.com/docker/docker-image-usage.html">https://www.runoob.com/docker/docker-image-usage.html</a></p>
<p><b>（a）更新镜像</b></p>
<p>首先，容器内<b>apt-get update</b>指令进行更新，然后<b>exit</b>。</p>
<p>然后，使用docker commit指令，将修改后的容器对应的镜像加入仓库中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker commit -m&#x3D;&quot;has update&quot; -a&#x3D;&quot;runoob&quot; e218edb10161 runoob&#x2F;ubuntu:v2</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<p>-m：提交信息描述</p>
<p>-a：作者</p>
<p>e218edb10161：容器ID</p>
<p>runoob/ubuntu:v2：镜像名称</p>
<p><b>（b）使用Dockerfile和docker build重新构建镜像</b></p>
<p>待补充，参考资料：<a href="https://www.runoob.com/docker/docker-image-usage.html">https://www.runoob.com/docker/docker-image-usage.html</a></p>
<p>参考资料2:<a href="https://www.runoob.com/docker/docker-dockerfile.html">https://www.runoob.com/docker/docker-dockerfile.html</a></p>
<h4 id="（4）为镜像添加tag"><a href="#（4）为镜像添加tag" class="headerlink" title="（4）为镜像添加tag"></a>（4）为镜像添加tag</h4> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker tag 860c279d2fec runoob&#x2F;centos:dev</span><br></pre></td></tr></table></figure>

<p>860c279d2fec：IMAGE ID，通过docker images指令查看</p>
<p>runoob/centos:dev：新的镜像名。其中dev为tag，runoob/centos为镜像所在仓库</p>
<h2 id="Docker容器互联"><a href="#Docker容器互联" class="headerlink" title="Docker容器互联"></a>Docker容器互联</h2>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习</title>
    <url>/2021/07/24/Java%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Java学习"><a href="#Java学习" class="headerlink" title="Java学习"></a>Java学习</h1><h2 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h2><ul>
<li>一个源文件中只能有一个 public 类</li>
<li>一个源文件可以有多个非 public 类</li>
<li>源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。</li>
<li>如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。</li>
<li>如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。</li>
<li>import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li>
</ul>
<h2 id="2、final"><a href="#2、final" class="headerlink" title="2、final"></a>2、final</h2><p>java中使用final关键字修饰常量，声明方式和变量类似：（应该类似于C++中的const）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.1415926</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-78. Subsets</title>
    <url>/2021/07/24/LeetCode-78-Subsets-0/</url>
    <content><![CDATA[<h1 id="LeetCode-78-Subsets"><a href="#LeetCode-78-Subsets" class="headerlink" title="LeetCode-78. Subsets"></a>LeetCode-78. Subsets</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/subsets/">https://leetcode.com/problems/subsets/</a></p>
<p>Given an integer array <code>nums</code> of <strong>unique</strong> elements, return <em>all possible subsets (the power set)</em>.</p>
<p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [0]</span><br><span class="line">Output: [[],[0]]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li>All the numbers of <code>nums</code> are <strong>unique</strong>.</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>（1）因为是subset，所以没有限制条件，直接每个curr都可以加入res。因为一个元素只能用一次，所以下一次从i+1开始。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr;</span><br><span class="line">        dfs(res, curr, nums, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; curr, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        res.push_back(curr);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            curr.push_back(nums[i]);</span><br><span class="line">            dfs(res, curr, nums, i+<span class="number">1</span>);</span><br><span class="line">            curr.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-90. Subsets||</title>
    <url>/2021/07/24/LeetCode-90-Subsets-0/</url>
    <content><![CDATA[<h1 id="LeetCode-90-Subsets"><a href="#LeetCode-90-Subsets" class="headerlink" title="LeetCode-90. Subsets||"></a>LeetCode-90. Subsets||</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an integer array <code>nums</code> that may contain duplicates, return <em>all possible subsets (the power set)</em>.</p>
<p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,2]</span><br><span class="line">Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [0]</span><br><span class="line">Output: [[],[0]]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>（1）此题也需要一个visited数组，并且sort nums来存储元素是否被遍历过</p>
<p>（2）比较其他两道nums不为distinct nums的题目：40. Combination Sum ||（sort）、47. Permutations ||（sort+visited）。重点观察continue的判定条件写法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        </span><br><span class="line">        dfs(res, nums, curr, visited, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; curr, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited, <span class="keyword">int</span> start)</span></span>&#123;        </span><br><span class="line">        res.push_back(curr);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &amp;&amp; visited[i<span class="number">-1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            curr.push_back(nums[i]);</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            dfs(res, nums, curr, visited, i+<span class="number">1</span>);</span><br><span class="line">            curr.pop_back();</span><br><span class="line">            visited[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode题目难度梳理</title>
    <url>/2021/07/24/Leetcode%E9%A2%98%E7%9B%AE%E9%9A%BE%E5%BA%A6%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<h1 id="Leetcode题目难度梳理"><a href="#Leetcode题目难度梳理" class="headerlink" title="Leetcode题目难度梳理"></a>Leetcode题目难度梳理</h1><p><font color = red>难</font>        <font color = blue>一般</font>       <font color=green>易</font></p>
<h3 id="第六章-多指针"><a href="#第六章-多指针" class="headerlink" title="第六章 多指针"></a>第六章 多指针</h3><p><font color = blue> 912. Sort an Array (Quick Sort and Merge Sort)</font>    快排、计数排序</p>
<p><font color = red>75. Sort Colors</font>    计数排序、三指针</p>
<p><font color=blue>26. Remove Duplicates from Sorted Array</font>    双指针</p>
<p><font color=red>80. Remove Duplicates from Sorted Array ||</font>   双指针</p>
<p><font color=blue>88. Merge Sorted Array</font>  双指针，倒序</p>
<p><font color=red>283. Move Zeroes</font>    双指针</p>
<p><font color=red>215. Kth largetst Element in an Array</font>    快排，快排变形</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>整理</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
</search>
